<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
      <title>RED ZONE</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>üêß</text></svg>">
  <style>
    :root {
      color-scheme: dark;
      --bg: #0b0f14;
      --panel: #11161e;
      --panel-2: #0f141c;
      --text: #e6edf3;
      --accent: #f04747;
      --accent-2: #3a86ff;
      --ok: #27d07e;
      --warn: #ffbf00;
    }

    html, body {
      margin: 0;
      height: 100%;
      background: radial-gradient(1200px 70% at 50% 50%, #0b0f14, #070a0f 60%, #05080c 100%);
      color: var(--text);
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial, "Noto Sans", "Apple Color Emoji", "Segoe UI Emoji";
      overflow: hidden;
    }

    #wrap {
      position: relative;
      width: 100vw;
      height: 100vh;
    }

    canvas#game {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      display: block;
      image-rendering: crisp-edges;
      image-rendering: pixelated;
      cursor: crosshair;
    }

    /* HUD */
    #hud {
      position: absolute;
      inset: 0;
      pointer-events: none;
      display: grid;
      grid-template-rows: auto 1fr;
    }

    .topbar {
      display: flex;
      gap: 12px;
      align-items: center;
      padding: 10px 14px;
      background: linear-gradient(#0c121a88, #0c121a00);
      backdrop-filter: blur(2px);
    }

    .chip {
      pointer-events: auto;
      padding: 6px 10px;
      border-radius: 10px;
      background: #0e151e;
      border: 1px solid #151d28;
      box-shadow: inset 0 0 0 1px #090d13;
      font-size: 12px;
      letter-spacing: 0.3px;
      color: #b9c3cf;
    }

    .chip strong { color: #e6edf3; }

    .bars {
      display: flex;
      gap: 10px;
      align-items: center;
      margin-left: auto;
    }

    .bar {
      position: relative;
      width: 200px;
      height: 12px;
      border-radius: 999px;
      background: #0b1118;
      border: 1px solid #121a25;
      overflow: hidden;
    }
    
    .bar.reload {
      width: 80px; /* Even smaller width for reload bar */
      height: 6px; /* Smaller height */
    }
    

    .bar .fill {
      position: absolute;
      inset: 0 auto 0 0;
      width: 50%;
      background: linear-gradient(90deg, #ff5555, #c92424);
      box-shadow: 0 0 14px #e01e1e55 inset;
    }
    .bar.stam .fill { background: linear-gradient(90deg, #2fafff, #0b6bd1); box-shadow: 0 0 14px #1171e355 inset; }
    .bar.reload .fill { background: linear-gradient(90deg, #ffbf00, #b88400); box-shadow: 0 0 14px #ffbf0055 inset; }

    .bottombar {
      display: flex;
      justify-content: center;
      padding: 10px 14px 16px;
      background: linear-gradient(#0c121a00, #0c121a88);
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      z-index: 10;
    }
    
    .minimap-container {
      position: absolute;
      top: 80px;
      right: 20px;
      background: rgba(0,0,0,0.3);
      border: 1px solid #333;
      border-radius: 8px;
      padding: 8px;
      backdrop-filter: blur(2px);
    }
    
    #minimap {
      display: block;
      border-radius: 4px;
      image-rendering: pixelated;
    }

    .weapons {
      display: grid;
      grid-auto-flow: column;
      gap: 10px;
      pointer-events: auto;
      align-items: start;
    }

    .slot {
      min-width: 120px;
      padding: 10px 12px;
      border-radius: 12px;
      border: 1px solid #151d28;
      background: linear-gradient(180deg, #0f151e, #0b1017);
      box-shadow: inset 0 0 0 1px #0a0f15, 0 1px 0 0 #0a0f15;
      display: grid;
      grid-template-columns: 1fr auto;
      gap: 6px 10px;
      align-items: center;
      opacity: 0.6;
      transform: translateY(0);
      transition: 120ms ease;
      height: 50px;
      overflow: hidden;
    }
    .slot.active {
      opacity: 1;
      border-color: #2a3546;
      box-shadow: inset 0 0 0 1px #162033, 0 0 0 2px #0a0f15;
      transform: translateY(-2px);
    }
    .slot .name { font-weight: 600; letter-spacing: 0.3px; }
    .slot .ammo { 
      font-variant-numeric: tabular-nums; 
      color: #b9c3cf; 
      font-size: 11px;
      line-height: 1;
      white-space: nowrap;
    }
    .slot .ammo.low { color: #ff4444; animation: pulse 1s ease-in-out infinite; }
    
    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }
    .slot .key {
      font-size: 11px; padding: 2px 6px; border-radius: 6px; background: #0b1118; border: 1px solid #121a25; color: #9fb0c5;
    }
    
    .weapon-info {
      margin-top: 8px;
      font-size: 11px;
      color: #aaa;
      text-align: center;
      background: rgba(0,0,0,0.3);
      padding: 6px 12px;
      border-radius: 8px;
      border: 1px solid #151d28;
    }
    
    .weapon-stats {
      display: flex;
      gap: 12px;
    }
    
    .weapon-stats span {
      background: rgba(0,0,0,0.3);
      padding: 2px 6px;
    }
    
    /* Settings Screen Styles */
    .settings-section {
      margin: 20px 0;
      padding: 15px;
      background: rgba(0,0,0,0.2);
      border-radius: 8px;
      border: 1px solid #151d28;
    }
    
    .settings-section h3 {
      margin: 0 0 15px 0;
      color: #e6edf3;
      font-size: 16px;
    }
    
    .setting-row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin: 10px 0;
      padding: 8px 0;
    }
    
    .setting-row label {
      color: #b9c3cf;
      font-size: 14px;
      min-width: 120px;
    }
    
    .slider {
      width: 150px;
      height: 6px;
      background: #0b1118;
      border-radius: 3px;
      outline: none;
      -webkit-appearance: none;
    }
    
    .slider::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 18px;
      height: 18px;
      background: #4a90e2;
      border-radius: 50%;
      cursor: pointer;
    }
    
    .slider::-moz-range-thumb {
      width: 18px;
      height: 18px;
      background: #4a90e2;
      border-radius: 50%;
      cursor: pointer;
      border: none;
    }
    
    .setting-row span {
      color: #e6edf3;
      font-size: 12px;
      min-width: 40px;
      text-align: right;
    }
    
    .setting-row select {
      background: #0b1118;
      border: 1px solid #151d28;
      color: #e6edf3;
      padding: 6px 10px;
      border-radius: 4px;
      font-size: 12px;
    }
    
    .setting-row input[type="checkbox"] {
      width: 16px;
      height: 16px;
      accent-color: #4a90e2;
    }

    /* Credits Screen Styles */
    .credits-section {
      margin: 20px 0;
      padding: 15px;
      background: rgba(0,0,0,0.2);
      border-radius: 8px;
      border: 1px solid #151d28;
    }
    
    .credits-section h3 {
      margin: 0 0 15px 0;
      color: #ff4444;
      font-size: 16px;
    }
    
    .credits-section p {
      margin: 8px 0;
      color: #cccccc;
      font-size: 14px;
      line-height: 1.4;
    }
    
    /* Controls Screen Styles */
    .controls-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 20px;
      margin: 20px 0;
    }
    
    .control-category {
      background: rgba(0,0,0,0.2);
      padding: 15px;
      border-radius: 8px;
      border: 1px solid #151d28;
    }
    
    .control-category h3 {
      margin: 0 0 15px 0;
      color: #e6edf3;
      font-size: 16px;
      text-align: center;
    }
    
    .control-item {
      display: flex;
      align-items: center;
      margin: 8px 0;
      font-size: 13px;
      color: #b9c3cf;
    }
    
        .control-item .kbd {
      margin-right: 8px;
      min-width: 40px;
      text-align: center;
    }

    /* Screens */
    .screen {
      position: absolute;
      inset: 0;
      display: grid;
      place-items: center;
      background: radial-gradient(800px 60% at 50% 40%, #0b0f1480, #070a0fdd, #05080cff);
      backdrop-filter: blur(3px);
      transition: opacity 200ms ease, visibility 200ms steps(1,end);
    }
    .screen.hide { opacity: 0; visibility: hidden; }

    .panel {
      width: min(680px, 92vw);
      border-radius: 16px;
      background: linear-gradient(180deg, var(--panel), var(--panel-2));
      border: 1px solid #1b2432;
      box-shadow: 0 10px 50px #0008, inset 0 0 0 1px #0a0f15;
      padding: 20px;
    }

    .panel h1 {
      margin: 6px 0 2px;
      font-size: 28px;
      letter-spacing: 0.4px;
    }
    .panel p { color: #aeb8c7; margin: 0 0 6px; }

    .controls {
      display: grid; gap: 6px; margin-top: 12px; color: #b9c3cf; font-size: 14px;
    }

    .row { display: flex; gap: 10px; align-items: center; flex-wrap: wrap; }

    .btn {
      appearance: none;
      border: 1px solid #273243;
      background: linear-gradient(180deg, #1b2635, #0f1621);
      color: #e6edf3;
      font-weight: 700;
      letter-spacing: 0.3px;
      padding: 10px 14px;
      border-radius: 12px;
      cursor: pointer;
      transition: 120ms ease;
      box-shadow: 0 4px 20px #0006, inset 0 0 0 1px #0a0f15;
    }
    .btn.primary {
      border-color: #3a2b2b;
      background: linear-gradient(180deg, #f04747, #b02b2b);
      box-shadow: 0 8px 30px #f0474740, inset 0 0 0 1px #0a0f15;
    }
    .btn:hover { filter: brightness(1.07); transform: translateY(-1px); }
    .btn:active { transform: translateY(0); }

    .kbd {
      padding: 4px 8px;
      border-radius: 8px;
      background: #0b1118;
      border: 1px solid #121a25;
      color: #9fb0c5;
      font-size: 12px;
      font-weight: 700;
      letter-spacing: 0.2px;
    }

    .statline {
      display: grid;
      grid-template-columns: 1fr auto;
      gap: 6px;
      color: #b9c3cf;
      margin-top: 8px;
      font-variant-numeric: tabular-nums;
    }

    .hint {
      color: #9fb0c5; font-size: 12px; opacity: 0.9; margin-top: 8px;
    }
    
    /* Enhanced Title Screen Styles */
    .story-section {
      margin: 20px 0;
      padding: 20px;
      background: rgba(255,0,0,0.1);
      border: 1px solid rgba(255,0,0,0.3);
      border-radius: 12px;
    }
    
    .story-intro {
      color: #e6edf3;
      font-size: 16px;
      line-height: 1.5;
      margin-bottom: 15px;
    }
    
    .story-background {
      color: #b9c3cf;
      font-size: 14px;
      line-height: 1.4;
      margin-bottom: 15px;
      font-style: italic;
    }
    
    .story-mission {
      color: #ffaa00;
      font-size: 14px;
      line-height: 1.4;
      margin-bottom: 15px;
      font-weight: 600;
    }
    
    .story-warning {
      color: #ff4444;
      font-size: 14px;
      line-height: 1.4;
      font-weight: 700;
      text-shadow: 0 0 10px rgba(255,68,68,0.5);
    }
    
    .menu-buttons {
      margin: 25px 0;
    }
    
    .game-info {
      margin: 25px 0;
    }
    
    .info-grid {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 15px;
      max-width: 500px;
      margin: 0 auto;
    }
    
    .info-item {
      background: rgba(0,0,0,0.3);
      padding: 12px;
      border-radius: 8px;
      border: 1px solid #151d28;
      text-align: center;
    }
    
    .info-item h4 {
      margin: 0 0 8px 0;
      color: #e6edf3;
      font-size: 14px;
    }
    
    .info-item p {
      margin: 0;
      color: #b9c3cf;
      font-size: 12px;
    }
      /* Skill Tree Styles */
    .skill-tree {
      margin: 20px 0;
    }
    .skill-row {
      display: flex;
      gap: 20px;
      margin-bottom: 20px;
    }
    .skill {
      flex: 1;
      background: #2a2a2a;
      border: 2px solid #444;
      border-radius: 8px;
      padding: 15px;
      text-align: center;
    }
    .skill h3 {
      margin: 0 0 8px 0;
      color: #ffaa00;
    }
    .skill p {
      margin: 0 0 10px 0;
      color: #ccc;
      font-size: 12px;
    }
    .skill-level {
      margin: 8px 0;
      color: #aaa;
      font-size: 12px;
    }
    .skill-btn {
      background: #4a4a4a;
      border: 1px solid #666;
      color: #fff;
      padding: 8px 16px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 12px;
    }
    .skill-btn:hover {
      background: #5a5a5a;
    }
    .skill-btn:disabled {
      background: #333;
      color: #666;
      cursor: not-allowed;
    }
    
    /* Enhanced Message System */
    .messages {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      text-align: center;
      pointer-events: none;
      z-index: 100;
    }
    
    .message {
      background: linear-gradient(135deg, rgba(0,0,0,0.9), rgba(20,30,50,0.9));
      color: #fff;
      padding: 12px 20px;
      border-radius: 12px;
      margin: 8px 0;
      font-size: 16px;
      font-weight: 700;
      letter-spacing: 1px;
      opacity: 0;
      transform: translateY(30px) scale(0.8);
      animation: messageSlide 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards;
      border: 1px solid rgba(255,255,255,0.2);
      box-shadow: 0 4px 20px rgba(0,0,0,0.5), 0 0 0 1px rgba(255,255,255,0.1);
      text-shadow: 0 2px 4px rgba(0,0,0,0.8);
    }
    
    .message.weapon { background: linear-gradient(135deg, rgba(255,107,107,0.9), rgba(200,50,50,0.9)); }
    .message.heal { background: linear-gradient(135deg, rgba(39,208,126,0.9), rgba(20,150,80,0.9)); }
    .message.ammo { background: linear-gradient(135deg, rgba(255,191,0,0.9), rgba(200,150,0,0.9)); }
    .message.turret { background: linear-gradient(135deg, rgba(74,144,226,0.9), rgba(50,100,180,0.9)); }
    .message.combo { background: linear-gradient(135deg, rgba(255,170,0,0.9), rgba(200,130,0,0.9)); }
    .message.death { background: linear-gradient(135deg, rgba(255,0,0,0.9), rgba(150,0,0,0.9)); color: #fff; text-shadow: 0 0 10px rgba(255,0,0,0.8); }
    .message.power { background: linear-gradient(135deg, rgba(255,255,0,0.9), rgba(255,200,0,0.9)); color: #000; }
    
    @keyframes messageSlide {
      0% {
        opacity: 0;
        transform: translateY(30px) scale(0.8);
      }
      50% {
        opacity: 1;
        transform: translateY(-5px) scale(1.05);
      }
      100% {
        opacity: 1;
        transform: translateY(0) scale(1);
      }
    }
    </style>
  </head>
<body>
  <div id="wrap">
    <canvas id="game"></canvas>

    <!-- HUD -->
    <div id="hud">
      <div class="topbar">
        <div class="chip"><strong>RED ZONE</strong></div>
        <div class="chip">Wave: <strong id="wave">1</strong> <span id="waveTimer" style="opacity:0.7">(20s)</span></div>
        <div class="chip">Score: <strong id="score">0</strong></div>
        <div class="chip">Turrets: <strong id="turrets">3</strong></div>
        <div class="chip">Barricades: <strong id="barricades">5</strong></div>
        <div class="chip">Vines: <strong id="spikes">3</strong></div>
        <div class="chip">Mines: <strong id="mines">2</strong></div>
        <div class="chip">Healing: <strong id="healingPlatforms">2</strong></div>
        <div class="bars">
          <div class="bar" aria-label="Health"><div id="hpFill" class="fill" style="width:100%"></div></div>
          <div class="bar stam" aria-label="Stamina"><div id="stamFill" class="fill" style="width:100%"></div></div>
          <div class="bar reload" aria-label="Reload"><div id="reloadFill" class="fill" style="width:0%"></div></div>
        </div>
      </div>

      <div class="minimap-container">
        <canvas id="minimap" width="200" height="150"></canvas>
      </div>

      <div class="bottombar">
        <div id="weapons" class="weapons" role="toolbar" aria-label="Weapons"></div>
        <div id="weaponInfo" class="weapon-info"></div>
      </div>
    </div>

    <!-- Screens -->
    <div id="screenStart" class="screen">
      <div class="panel">
        <h1>RED ZONE</h1>
        <div class="story-section">
          <p class="story-intro">The year is 2047. You are Captain Favnon Peng, elite tactical specialist and leading the last defenders of Sector 7, a critical military outpost on the edge of the Red Zone - a wasteland overrun by mutated creatures and rogue AI constructs.</p>
          <p class="story-background">After the AI uprising of 2042, humanity's last strongholds are scattered across the globe. Sector 7 houses critical research data and the last known cure for the neural plague that's spreading through the remaining population. The facility's experimental neural enhancement programs have created enhanced human operatives with AI-bonded animal companions - all fighting to preserve what remains of civilization.</p>
          <p class="story-mission">Your mission: Hold the perimeter at all costs. The enemy waves are endless, but you must survive. Use every weapon, every strategy, every ally at your disposal. The fate of humanity depends on your survival.</p>
          <p class="story-warning">The Red Zone doesn't forgive. The Red Zone doesn't forget. The Red Zone is coming for you.</p>
        </div>
        
        <div class="menu-buttons">
          <div class="row" style="margin-top:20px; justify-content: center;">
            <button id="startBtn" class="btn primary">Enter the Red Zone</button>
          </div>
          <div class="row" style="margin-top:10px; justify-content: center;">
            <button id="controlsBtn" class="btn">Controls</button>
            <button id="settingsBtn" class="btn">Settings</button>
          </div>
                      <div class="row" style="margin-top:10px; justify-content: center;">
              <button id="nightBtn" class="btn">Toggle Night Mode</button>
              <button id="creditsBtn" class="btn">Credits</button>
            </div>
          </div>
        
        <div class="game-info">
          <div class="info-grid">
            <div class="info-item">
              <h4>üéØ Objective</h4>
              <p>Survive endless waves of enemies</p>
            </div>
            <div class="info-item">
              <h4>‚öîÔ∏è Combat</h4>
              <p>8 unique weapons to discover</p>
            </div>
            <div class="info-item">
              <h4>üèóÔ∏è Defense</h4>
              <p>Build turrets, barricades, and more</p>
            </div>
            <div class="info-item">
              <h4>üê∫ Allies</h4>
              <p>Animal companions join the fight</p>
            </div>
          </div>
        </div>
        

      </div>
    </div>

    <div id="screenPause" class="screen hide">
      <div class="panel">
        <h1>Paused</h1>
        <p>Catch your breath. They won't.</p>
        <div class="row" style="margin-top:14px; justify-content: center;">
          <button id="resumeBtn" class="btn primary">Resume</button>
        </div>
        <div class="row" style="margin-top:10px; justify-content: center;">
          <button id="retryBtn" class="btn">Restart</button>
          <button id="pauseMenuBtn" class="btn">Main Menu</button>
        </div>
        <div class="row" style="margin-top:10px; justify-content: center;">
          <button id="pauseControlsBtn" class="btn">Controls</button>
          <button id="pauseSettingsBtn" class="btn">Settings</button>
        </div>
        <div class="row" style="margin-top:10px; justify-content: center;">
          <button id="pauseSkillTreeBtn" class="btn">Skill Tree</button>
        </div>
      </div>
    </div>

    <div id="screenOver" class="screen hide">
      <div class="panel">
        <h1>Zone Overrun</h1>
        <div class="statline"><span>Waves survived</span><strong id="wavesStat">0</strong></div>
        <div class="statline"><span>Total score</span><strong id="scoreStat">0</strong></div>
        <div class="statline"><span>Total kills</span><strong id="killsStat">0</strong></div>
        <div class="row" style="margin-top:14px">
          <button id="retryBtn2" class="btn primary">Try Again</button>
          <button id="menuBtn" class="btn">Main Menu</button>
        </div>
      </div>
    </div>

    <div id="screenSkillTree" class="screen hide">
      <div class="panel" style="max-width: 600px;">
        <h1>Skill Tree</h1>
        <div class="statline"><span>Skill Points</span><strong id="skillPoints">0</strong></div>
        <div class="skill-tree">
          <div class="skill-row">
            <div class="skill" data-skill="health">
              <h3>Health Boost</h3>
              <p>+20 HP per level</p>
              <div class="skill-level">Level <span id="healthLevel">0</span>/5</div>
              <button class="skill-btn" data-skill="health">Upgrade (1 point)</button>
            </div>
            <div class="skill" data-skill="speed">
              <h3>Speed Boost</h3>
              <p>+10% speed per level</p>
              <div class="skill-level">Level <span id="speedLevel">0</span>/5</div>
              <button class="skill-btn" data-skill="speed">Upgrade (1 point)</button>
            </div>
          </div>
          <div class="skill-row">
            <div class="skill" data-skill="damage">
              <h3>Damage Boost</h3>
              <p>+15% damage per level</p>
              <div class="skill-level">Level <span id="damageLevel">0</span>/5</div>
              <button class="skill-btn" data-skill="damage">Upgrade (1 point)</button>
            </div>
            <div class="skill" data-skill="reload">
              <h3>Reload Speed</h3>
              <p>+20% reload speed per level</p>
              <div class="skill-level">Level <span id="reloadLevel">0</span>/5</div>
              <button class="skill-btn" data-skill="reload">Upgrade (1 point)</button>
            </div>
          </div>
          <div class="skill-row">
            <div class="skill" data-skill="stamina">
              <h3>Stamina Boost</h3>
              <p>+25 stamina per level</p>
              <div class="skill-level">Level <span id="staminaLevel">0</span>/5</div>
              <button class="skill-btn" data-skill="stamina">Upgrade (1 point)</button>
            </div>
            <div class="skill" data-skill="pickupRange">
              <h3>Pickup Magnet</h3>
              <p>+50 pickup range per level</p>
              <div class="skill-level">Level <span id="pickupRangeLevel">0</span>/5</div>
              <button class="skill-btn" data-skill="pickupRange">Upgrade (1 point)</button>
            </div>
          </div>
        </div>
        <div class="row" style="margin-top:14px">
          <button id="closeSkillTree" class="btn primary">Close</button>
        </div>
      </div>
    </div>

    <div id="screenSettings" class="screen hide">
      <div class="panel" style="max-width: 500px;">
        <h1>Settings</h1>
        
        <div class="settings-section">
          <h3>Audio</h3>
          <div class="setting-row">
            <label>Master Volume</label>
            <input type="range" id="masterVolume" min="0" max="100" value="80" class="slider">
            <span id="masterVolumeValue">80%</span>
          </div>
          <div class="setting-row">
            <label>SFX Volume</label>
            <input type="range" id="sfxVolume" min="0" max="100" value="90" class="slider">
            <span id="sfxVolumeValue">90%</span>
          </div>
        </div>

        <div class="settings-section">
          <h3>Graphics</h3>
          <div class="setting-row">
            <label>Particle Effects</label>
            <select id="particleQuality">
              <option value="high">High</option>
              <option value="medium" selected>Medium</option>
              <option value="low">Low</option>
            </select>
          </div>
          <div class="setting-row">
            <label>Screen Shake</label>
            <input type="checkbox" id="screenShakeEnabled" checked>
          </div>
          <div class="setting-row">
            <label>Camera Flash</label>
            <input type="checkbox" id="cameraFlashEnabled" checked>
          </div>
        </div>

        <div class="settings-section">
          <h3>Gameplay</h3>
          <div class="setting-row">
            <label>Damage Numbers</label>
            <input type="checkbox" id="damageNumbersEnabled" checked>
          </div>
          <div class="setting-row">
            <label>Show FPS</label>
            <input type="checkbox" id="showFPS">
          </div>
        </div>

        <div class="row" style="margin-top:14px">
          <button id="closeSettings" class="btn primary">Save & Close</button>
          <button id="resetSettings" class="btn">Reset to Default</button>
        </div>
      </div>
    </div>

    <div id="screenCredits" class="screen hide">
      <div class="panel" style="max-width: 400px;">
        <h1>Credits</h1>
        
        <div class="credits-section">
          <h3>Game Development</h3>
          <p><strong>Created by:</strong> Fabio Votta</p>
          <p><strong>Developed with:</strong> Cursor AI</p>
        </div>

        <div class="credits-section">
          <h3>Game Features</h3>
          <p>‚Ä¢ Procedural 8-bit music generation</p>
          <p>‚Ä¢ Dynamic weather and particle effects</p>
          <p>‚Ä¢ AI-powered companion system</p>
        </div>

        <div class="credits-section">
          <h3>Special Thanks</h3>
          <p>To all the players who will defend the Red Zone but especially the Fennec!</p>
        </div>

        <div class="row" style="margin-top:14px">
          <button id="closeCredits" class="btn primary">Back</button>
        </div>
      </div>
    </div>

    <div id="screenControls" class="screen hide">
      <div class="panel" style="max-width: 600px;">
        <h1>Controls</h1>
        <p>Master the battlefield with these controls:</p>
        
        <div class="controls-grid">
          <div class="control-category">
            <h3>Movement & Combat</h3>
            <div class="control-item">
              <span class="kbd">WASD</span> Move
            </div>
            <div class="control-item">
              <span class="kbd">Mouse</span> Aim
            </div>
            <div class="control-item">
              <span class="kbd">LMB</span> Fire
            </div>
            <div class="control-item">
              <span class="kbd">R</span> Reload
            </div>
            <div class="control-item">
              <span class="kbd">Space</span> Dash
            </div>
            <div class="control-item">
              <span class="kbd">1-8</span> Switch Weapons
            </div>
          </div>

          <div class="control-category">
            <h3>Defense & Support</h3>
            <div class="control-item">
              <span class="kbd">T</span> Place Turret
            </div>
            <div class="control-item">
              <span class="kbd">B</span> Place Barricade
            </div>
            <div class="control-item">
              <span class="kbd">V</span> Place Vines
            </div>
            <div class="control-item">
              <span class="kbd">M</span> Place Mine
            </div>
            <div class="control-item">
              <span class="kbd">H</span> Place Healing Platform
            </div>
            <div class="control-item">
              <span class="kbd">Tab</span> Switch Turret Type
            </div>
          </div>

          <div class="control-category">
            <h3>Interface</h3>
            <div class="control-item">
              <span class="kbd">K</span> Skill Tree
            </div>
            <div class="control-item">
              <span class="kbd">F</span> Toggle Damage Numbers
            </div>

            <div class="control-item">
              <span class="kbd">Esc</span> Pause
            </div>
            <div class="control-item">
              <span class="kbd">Q</span> Special Ability
            </div>
          </div>
        </div>

        <div class="row" style="margin-top:14px">
          <button id="closeControls" class="btn primary">Got It!</button>
        </div>
      </div>
    </div>
  </div>

  <script>
  "use strict";

  // Canvas setup
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d', { alpha: false });
  const minimapCanvas = document.getElementById('minimap');
  const minimapCtx = minimapCanvas.getContext('2d');
  const TAU = Math.PI * 2;

  const $hud = {
    wave: document.getElementById('wave'),
    waveTimer: document.getElementById('waveTimer'),
    direction: document.getElementById('direction'),
    score: document.getElementById('score'),
    combo: document.getElementById('combo'),
    hpFill: document.getElementById('hpFill'),
    stamFill: document.getElementById('stamFill'),
    reloadFill: document.getElementById('reloadFill'),
    weapons: document.getElementById('weapons'),
    turrets: document.getElementById('turrets'),
    barricades: document.getElementById('barricades'),
    spikes: document.getElementById('spikes'),
    mines: document.getElementById('mines'),
    healingPlatforms: document.getElementById('healingPlatforms'),


    weaponInfo: document.getElementById('weaponInfo'),
  };

  const $screenStart = document.getElementById('screenStart');
  const $screenPause = document.getElementById('screenPause');
  const $screenOver = document.getElementById('screenOver');
  const $startBtn = document.getElementById('startBtn');
  const $nightBtn = document.getElementById('nightBtn');
  const $resumeBtn = document.getElementById('resumeBtn');
  const $retryBtn = document.getElementById('retryBtn');
  const $retryBtn2 = document.getElementById('retryBtn2');
  const $menuBtn = document.getElementById('menuBtn');
  const $wavesStat = document.getElementById('wavesStat');
  const $scoreStat = document.getElementById('scoreStat');
  const $killsStat = document.getElementById('killsStat');
  const $screenSkillTree = document.getElementById('screenSkillTree');
  const $closeSkillTree = document.getElementById('closeSkillTree');
  const $skillPoints = document.getElementById('skillPoints');

  const state = {
    w: 0, h: 0, time: 0, dt: 0.016, playing: false, paused: false,
    flash: 0, vignette: 0.6, night: false,
    wave: 1, waveTime: 0, score: 0, kills: 0,
    rng: Math.random() * 1e9,
    messages: [], // Array for announcement messages
    speechBubbles: [], // Array for speech bubbles
    combo: 0, // Kill combo counter
    maxCombo: 0, // Highest combo achieved
    powerMode: false, // Power mode for rapid kills
    powerModeTimer: 0, // Power mode duration
    autoReload: true, // Auto-reload when empty
    showDamage: false, // Show damage numbers
    damageNumbers: [], // Array for damage numbers
    screenShake: 0, // Screen shake effect
    screenShakeX: 0, screenShakeY: 0, // Screen shake offset
    achievements: new Set(), // Track unlocked achievements
    skillPoints: 0, // Skill tree points
    skillTree: {
      health: 0,
      speed: 0,
      damage: 0,
      reload: 0,
      stamina: 0,
      pickupRange: 0
    },
    speechBubbles: [], // Array for speech bubbles
    graveyard: [], // Array for fallen allies' resting places
    // New features
    weather: 'clear', // Weather state: clear, rain, storm, fog
    weatherTimer: 0, // Weather duration
    bloodSplatter: 0, // Blood splatter effect timer
    bloodSplatterX: 0, bloodSplatterY: 0, // Blood splatter position
    powerUps: [], // Active power-ups
    musicIntensity: 0 // Music intensity level
  };

  const input = {
    keys: new Set(),
    mouse: { x: 0, y: 0, down: false },
    dash: false,
  };

  const player = {
    x: 0, y: 0, r: 16,
    vx: 0, vy: 0,
    speed: 230,
    angle: 0,
    hp: 100, hpMax: 100,
    stam: 100, stamMax: 100,
    inv: 0,
    dashCD: 0,
    weapon: 0,
    reloadT: 0,
    turrets: 3, // Number of placeable turrets
    barricades: 5, // Number of placeable barricades
    spikes: 3, // Number of placeable spikes
    mines: 2, // Number of placeable mines
    healingPlatforms: 1, // Number of placeable healing platforms (1 per wave)
    healingPlatformCooldown: 0, // Cooldown for healing platform
    turretType: 0, // Current turret type (0=basic, 1=heavy, 2=sniper)
    specialAbility: 'none', // Current special ability
    specialCooldown: 0, // Cooldown for special ability
  };

  const bullets = [];
  const enemies = [];
  const pickups = [];
  const particles = [];
  const turrets = []; // Add turrets array
  const barricades = []; // Add barricades array
  const spikes = []; // Add spikes array
  const mines = []; // Add mines array
  const allies = []; // Add friendly soldiers array
  const healingPlatforms = []; // Add healing platforms array
  const hazards = []; // Add environmental hazards array

  // Audio system
  let audioContext, masterGain;
  let musicOscillator, musicGain, musicFilter;
  let musicPattern = [];
  let musicStep = 0;
  let musicTimer = 0;
  const sounds = {
    gunshot(volume = 0.3) {
      if (!audioContext) return;
      const osc = audioContext.createOscillator();
      const gain = audioContext.createGain();
      const filter = audioContext.createBiquadFilter();
      
      osc.type = 'square';
      osc.frequency.setValueAtTime(800 + Math.random() * 200, audioContext.currentTime);
      osc.frequency.exponentialRampToValueAtTime(200, audioContext.currentTime + 0.08);
      
      filter.type = 'bandpass';
      filter.frequency.setValueAtTime(1200, audioContext.currentTime);
      filter.Q.value = 8;
      
      gain.gain.setValueAtTime(0, audioContext.currentTime);
      gain.gain.linearRampToValueAtTime(volume, audioContext.currentTime + 0.001);
      gain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.08);
      
      osc.connect(filter);
      filter.connect(gain);
      gain.connect(masterGain);
      
      osc.start(audioContext.currentTime);
      osc.stop(audioContext.currentTime + 0.08);
    },
    
    explosion(volume = 0.4) {
      if (!audioContext) return;
      const osc = audioContext.createOscillator();
      const gain = audioContext.createGain();
      
      osc.type = 'sawtooth';
      osc.frequency.setValueAtTime(120, audioContext.currentTime);
      osc.frequency.exponentialRampToValueAtTime(40, audioContext.currentTime + 0.4);
      
      gain.gain.setValueAtTime(0, audioContext.currentTime);
      gain.gain.linearRampToValueAtTime(volume, audioContext.currentTime + 0.002);
      gain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.4);
      
      osc.connect(gain);
      gain.connect(masterGain);
      
      osc.start(audioContext.currentTime);
      osc.stop(audioContext.currentTime + 0.4);
    },
    
    reload(volume = 0.2) {
      if (!audioContext) return;
      const osc = audioContext.createOscillator();
      const gain = audioContext.createGain();
      const filter = audioContext.createBiquadFilter();
      
      // Dark, mechanical reload sound
      osc.type = 'sawtooth';
      osc.frequency.setValueAtTime(80, audioContext.currentTime);
      osc.frequency.exponentialRampToValueAtTime(40, audioContext.currentTime + 0.3);
      
      // Low-pass filter for darker tone
      filter.type = 'lowpass';
      filter.frequency.setValueAtTime(200, audioContext.currentTime);
      filter.frequency.exponentialRampToValueAtTime(100, audioContext.currentTime + 0.3);
      
      gain.gain.setValueAtTime(0, audioContext.currentTime);
      gain.gain.linearRampToValueAtTime(volume, audioContext.currentTime + 0.01);
      gain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.3);
      
      osc.connect(filter);
      filter.connect(gain);
      gain.connect(masterGain);
      
      osc.start(audioContext.currentTime);
      osc.stop(audioContext.currentTime + 0.3);
    },
    
    hit(volume = 0.3) {
      if (!audioContext) return;
      const osc = audioContext.createOscillator();
      const gain = audioContext.createGain();
      
      osc.type = 'sine';
      osc.frequency.setValueAtTime(400 + Math.random() * 200, audioContext.currentTime);
      osc.frequency.exponentialRampToValueAtTime(200, audioContext.currentTime + 0.1);
      
      gain.gain.setValueAtTime(0, audioContext.currentTime);
      gain.gain.linearRampToValueAtTime(volume, audioContext.currentTime + 0.001);
      gain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.1);
      
      osc.connect(gain);
      gain.connect(masterGain);
      
      osc.start(audioContext.currentTime);
      osc.stop(audioContext.currentTime + 0.1);
    },
    
    pickup(volume = 0.2) {
      if (!audioContext) return;
      const osc = audioContext.createOscillator();
      const gain = audioContext.createGain();
      
      osc.type = 'sine';
      osc.frequency.setValueAtTime(800, audioContext.currentTime);
      osc.frequency.linearRampToValueAtTime(1200, audioContext.currentTime + 0.15);
      
      gain.gain.setValueAtTime(0, audioContext.currentTime);
      gain.gain.linearRampToValueAtTime(volume, audioContext.currentTime + 0.01);
      gain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.15);
      
      osc.connect(gain);
      gain.connect(masterGain);
      
      osc.start(audioContext.currentTime);
      osc.stop(audioContext.currentTime + 0.15);
    },
    
    dash(volume = 0.25) {
      if (!audioContext) return;
      const osc = audioContext.createOscillator();
      const gain = audioContext.createGain();
      
      osc.type = 'sawtooth';
      osc.frequency.setValueAtTime(300, audioContext.currentTime);
      osc.frequency.exponentialRampToValueAtTime(100, audioContext.currentTime + 0.2);
      
      gain.gain.setValueAtTime(0, audioContext.currentTime);
      gain.gain.linearRampToValueAtTime(volume, audioContext.currentTime + 0.001);
      gain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.2);
      
      osc.connect(gain);
      gain.connect(masterGain);
      
      osc.start(audioContext.currentTime);
      osc.stop(audioContext.currentTime + 0.2);
    }
  };

  function initAudio() {
    try {
      audioContext = new (window.AudioContext || window.webkitAudioContext)();
      masterGain = audioContext.createGain();
      masterGain.connect(audioContext.destination);
      masterGain.gain.value = 0.4;
      
      // Initialize music system
      musicGain = audioContext.createGain();
      musicFilter = audioContext.createBiquadFilter();
      musicFilter.type = 'lowpass';
      musicFilter.frequency.setValueAtTime(800, audioContext.currentTime);
      musicGain.connect(musicFilter);
      musicFilter.connect(masterGain);
      musicGain.gain.setValueAtTime(0.1, audioContext.currentTime);
      
      generateMusicPattern();
    } catch (e) {
      console.log('Audio not supported');
    }
  }
  
  function generateMusicPattern() {
    musicPattern = [];
    const baseNote = 55; // A1 - even lower, more bass-heavy
    const dubstepScale = [0, 2, 4, 7, 9, 11, 12]; // Minor scale with added notes for dubstep
    const cyberpunkScale = [0, 1, 4, 5, 7, 8, 11]; // Chromatic/dissonant scale for futuristic feel
    
    // Generate 16-step pattern with dubstep/futuristic elements
    for (let i = 0; i < 16; i++) {
      // Use cyberpunk scale more often for futuristic feel
      const useCyberpunk = Math.random() < 0.8;
      const currentScale = useCyberpunk ? cyberpunkScale : dubstepScale;
      const note = currentScale[Math.floor(Math.random() * currentScale.length)];
      
      // Lower octave range for heavy bass
      const octave = Math.floor(Math.random() * 2); // 0-2 octaves for bass variation
      const frequency = baseNote * Math.pow(2, (note + octave * 12) / 12);
      
      // Dubstep-style timing - longer notes with occasional staccato
      const duration = Math.random() < 0.7 ? 1.2 : (Math.random() < 0.3 ? 0.2 : 0.6);
      
      // More dynamic volume for dubstep feel
      const volume = 0.2 + Math.random() * 0.4;
      
      musicPattern.push({
        frequency: frequency,
        duration: duration,
        volume: volume
      });
    }
  }
  
  function updateMusic(dt) {
    if (!audioContext || !state.playing) return;
    
    musicTimer += dt;
    const stepDuration = 0.8; // Dubstep tempo - 1.25 steps per second
    
    if (musicTimer >= stepDuration) {
      musicTimer = 0;
      
      if (musicStep < musicPattern.length) {
        const note = musicPattern[musicStep];
        
        // Create oscillator for this note
        const osc = audioContext.createOscillator();
        const gain = audioContext.createGain();
        
        osc.type = 'square'; // 8-bit dubstep sound
        osc.frequency.setValueAtTime(note.frequency, audioContext.currentTime);
        
        // Add dubstep-style filter with wobble
        const filter = audioContext.createBiquadFilter();
        filter.type = 'lowpass';
        const wobbleFreq = 4 + Math.sin(state.time * 2) * 2; // Wobble effect
        filter.frequency.setValueAtTime(600 + Math.sin(state.time * wobbleFreq) * 200, audioContext.currentTime);
        filter.Q.setValueAtTime(0.8, audioContext.currentTime);
        
        // Add distortion for dubstep feel
        const distortion = audioContext.createWaveShaper();
        distortion.curve = makeDistortionCurve(50);
        
        gain.gain.setValueAtTime(0, audioContext.currentTime);
        gain.gain.linearRampToValueAtTime(note.volume * (0.08 + state.musicIntensity * 0.2), audioContext.currentTime + 0.01);
        gain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + note.duration);
        
        osc.connect(filter);
        filter.connect(distortion);
        distortion.connect(gain);
        gain.connect(musicGain);
        
        osc.start(audioContext.currentTime);
        osc.stop(audioContext.currentTime + note.duration);
        
        musicStep++;
      } else {
        musicStep = 0;
        generateMusicPattern(); // Generate new pattern
      }
    }
  }
  
  // Helper function for distortion
  function makeDistortionCurve(amount) {
    const k = typeof amount === 'number' ? amount : 50;
    const n_samples = 44100;
    const curve = new Float32Array(n_samples);
    const deg = Math.PI / 180;
    
    for (let i = 0; i < n_samples; ++i) {
      const x = (i * 2) / n_samples - 1;
      curve[i] = (3 + k) * x * 20 * deg / (Math.PI + k * Math.abs(x));
    }
    return curve;
  }
  
  function updateWeather(dt) {
    state.weatherTimer += dt;
    
    // Change weather every 30-60 seconds
    if (state.weatherTimer > 30 + Math.random() * 30) {
      state.weatherTimer = 0;
      const weathers = ['clear', 'rain', 'storm', 'fog'];
      state.weather = weathers[Math.floor(Math.random() * weathers.length)];
      
      // Weather announcement
      const weatherMessages = {
        'rain': 'Rain begins to fall...',
        'storm': 'A storm approaches!',
        'fog': 'Fog rolls in...',
        'clear': 'Weather clears up!'
      };
      if (weatherMessages[state.weather]) {
        addMessage(weatherMessages[state.weather], 'weather');
      }
    }
    
    // Update music intensity based on weather and wave
    state.musicIntensity = Math.min(1, (state.wave - 1) / 10);
    if (state.weather === 'storm') state.musicIntensity += 0.3;
    if (state.weather === 'rain') state.musicIntensity += 0.1;
  }

  // Weapons definition
  const arsenal = [
    { name: 'Pistol', key: '1', color: '#e6edf3', magSize: 12, reserve: 120, damage: 22, speed: 900, spread: 0.02, fireDelay: 0.18, auto: false, pellets: 1, reload: 1.2, tracer: 30, width: 2, pierce: 0, knock: 140, unlocked: true },
    { name: 'SMG', key: '2', color: '#a8d1ff', magSize: 30, reserve: 300, damage: 12, speed: 820, spread: 0.06, fireDelay: 0.07, auto: true,  pellets: 1, reload: 1.6, tracer: 24, width: 2, pierce: 0, knock: 80, unlocked: false },
    { name: 'Shotgun', key: '3', color: '#ffd39a', magSize: 6,  reserve: 48,  damage: 10, speed: 780, spread: 0.22, fireDelay: 0.7,  auto: false, pellets: 8, reload: 2.2, tracer: 22, width: 2.6, pierce: 0, knock: 260, unlocked: false },
    { name: 'Marksman', key: '4', color: '#ff9abe', magSize: 10, reserve: 120, damage: 40, speed: 1050,spread: 0.01, fireDelay: 0.28, auto: false, pellets: 1, reload: 1.8, tracer: 40, width: 2.2, pierce: 1, knock: 180, unlocked: false },
    { name: 'LMG', key: '5', color: '#d2f59c', magSize: 80, reserve: 320, damage: 16, speed: 820, spread: 0.09, fireDelay: 0.08, auto: true, pellets: 1, reload: 3.2, tracer: 28, width: 2.2, pierce: 0, knock: 120, unlocked: false },
    { name: 'Sniper', key: '6', color: '#b8a2ff', magSize: 5,  reserve: 40,  damage: 120,speed: 1400,spread: 0.003,fireDelay: 0.9,  auto: false, pellets: 1, reload: 2.6, tracer: 60, width: 3, pierce: 3, knock: 420, unlocked: false },
    { name: 'Grenade Launcher', key: '7', color: '#ff7a7a', magSize: 6,  reserve: 30,  damage: 80,speed: 400, spread: 0.05, fireDelay: 1.2,  auto: false, pellets: 1, reload: 2.8, tracer: 15, width: 5, pierce: 0, knock: 300, splash: 120, splashFall: 0.5, unlocked: false, grenade: true },
    { name: 'Flamethrower', key: '8', color: '#ff4444', magSize: 50, reserve: 200, damage: 8, speed: 300, spread: 0.15, fireDelay: 0.1, auto: true, pellets: 1, reload: 3.5, tracer: 12, width: 3, pierce: 0, knock: 60, unlocked: false, flamethrower: true, burnDamage: 5, burnDuration: 2 },
  ].map(w => ({ ...w, mag: w.magSize, fireT: 0 }));

  // Build HUD weapon slots
  function renderWeaponHUD() {
    $hud.weapons.innerHTML = '';
    arsenal.forEach((w, i) => {
      if (!w.unlocked) return; // Skip locked weapons
      const el = document.createElement('div');
      el.className = 'slot' + (i === player.weapon ? ' active' : '');
      
      // Add low ammo warning
      const isLowAmmo = w.mag <= 0 || w.reserve <= w.magSize * 0.2;
      const ammoClass = isLowAmmo ? 'ammo low' : 'ammo';
      
      el.innerHTML = `
        <div class="name">${w.name}</div>
        <div class="key">${w.key}</div>
        <div class="${ammoClass}"><span>${w.mag.toString().padStart(2,'0')}</span>/<span>${w.reserve}</span></div>
      `;
      $hud.weapons.appendChild(el);
    });
  }

  // Resize
  function resize() {
    const dpr = Math.min(2, window.devicePixelRatio || 1);
    state.w = canvas.width = Math.floor(canvas.clientWidth * dpr);
    state.h = canvas.height = Math.floor(canvas.clientHeight * dpr);
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    
    // Ensure player starts in center of visible area
    if (state.playing) {
      player.x = state.w / 2;
      player.y = state.h / 2;
    }
  }
  window.addEventListener('resize', resize);

  // Input
  window.addEventListener('mousemove', e => {
    const rect = canvas.getBoundingClientRect();
    input.mouse.x = (e.clientX - rect.left);
    input.mouse.y = (e.clientY - rect.top);
  });
  window.addEventListener('mousedown', e => { if (e.button === 0) input.mouse.down = true; });
  window.addEventListener('mouseup', e => { if (e.button === 0) input.mouse.down = false; });

  window.addEventListener('keydown', e => {
    if (['Shift','Control','Alt','Meta'].includes(e.key)) return;
    input.keys.add(e.key.toLowerCase());
    if (e.key === ' ') { e.preventDefault(); input.dash = true; }
    if (e.key === 'Escape') { togglePause(); }
    // Switch weapons 1-8 with enhanced feedback
    if (/^[1-8]$/.test(e.key)) {
      const idx = Number(e.key) - 1;
      if (arsenal[idx] && arsenal[idx].unlocked) {
        player.weapon = idx;
        renderWeaponHUD();
        addMessage(`Switched to ${arsenal[idx].name}`, 'weapon');
        screenShake(0.1, 0.1);
        
        // Enhanced visual feedback
        particlesBurst(player.x, player.y, '#4a90e2', 12, 150);
        
        // Player speech bubble
        const weaponPhrases = ['Let\'s try this!', 'This should work!', 'Time for this!', 'Perfect!'];
        const phrase = weaponPhrases[Math.floor(Math.random() * weaponPhrases.length)];
        state.speechBubbles.push({
          x: player.x,
          y: player.y - 40,
          text: phrase,
          time: 0,
          life: 2.0,
          owner: null
        });
        
        // Quick weapon info flash with stats
        const weapon = arsenal[idx];
        const weaponInfo = `${weapon.name}: ${weapon.damage} dmg, ${(1/weapon.fireDelay).toFixed(1)}/s, ${weapon.mag}/${weapon.reserve} ammo`;
        addMessage(weaponInfo);
      }
    }
    if (e.key.toLowerCase() === 'r') {
      startReload();
    }
    // Place turret with T
    if (e.key.toLowerCase() === 't') {
      placeTurret();
    }
    // Place barricade with B
    if (e.key.toLowerCase() === 'b') {
      placeBarricade();
    }
    // Place vines with V
    if (e.key.toLowerCase() === 'v') {
      placeVines();
    }
    // Place mine with M
    if (e.key.toLowerCase() === 'm') {
      placeMine();
    }
    // Place healing platform with H
    if (e.key.toLowerCase() === 'h') {
      placeHealingPlatform();
    }
    if (e.key.toLowerCase() === 'k') {
      openSkillTree();
    }
    // Switch turret type with Tab
    if (e.key === 'Tab') {
      e.preventDefault();
      player.turretType = (player.turretType + 1) % 5;
      updateTurretHUD();
      const turretNames = ['Basic', 'Heavy', 'Sniper', 'Shotgun', 'Flamethrower'];
      addMessage(`Switched to ${turretNames[player.turretType]} Turret`);
    }
    
    // Special ability with Q
    if (e.key.toLowerCase() === 'q' && player.specialCooldown <= 0) {
      activateSpecialAbility();
    }
    

    
    // Toggle damage numbers with F
    if (e.key.toLowerCase() === 'f') {
      state.showDamage = !state.showDamage;
      addMessage(`Damage numbers ${state.showDamage ? 'ON' : 'OFF'}`);
    }
  });
  window.addEventListener('keyup', e => input.keys.delete(e.key.toLowerCase()));
  
  // Mouse wheel weapon switching with visual feedback
  window.addEventListener('wheel', e => {
    if (state.playing && !state.paused) {
      if (e.deltaY > 0) {
        // Scroll down - next weapon
        let nextWeapon = (player.weapon + 1) % arsenal.length;
        while (!arsenal[nextWeapon].unlocked && nextWeapon !== player.weapon) {
          nextWeapon = (nextWeapon + 1) % arsenal.length;
        }
        if (arsenal[nextWeapon].unlocked) {
          player.weapon = nextWeapon;
          renderWeaponHUD();
          addMessage(`Switched to ${arsenal[nextWeapon].name}`);
          screenShake(0.1, 0.1);
          
          // Visual weapon switch effect
          particlesBurst(player.x, player.y, '#4a90e2', 8, 120);
        }
      } else if (e.deltaY < 0) {
        // Scroll up - previous weapon
        let prevWeapon = (player.weapon - 1 + arsenal.length) % arsenal.length;
        while (!arsenal[prevWeapon].unlocked && prevWeapon !== player.weapon) {
          prevWeapon = (prevWeapon - 1 + arsenal.length) % arsenal.length;
        }
        if (arsenal[prevWeapon].unlocked) {
          player.weapon = prevWeapon;
          renderWeaponHUD();
          addMessage(`Switched to ${arsenal[prevWeapon].name}`);
          screenShake(0.1, 0.1);
          
          // Visual weapon switch effect
          particlesBurst(player.x, player.y, '#4a90e2', 8, 120);
        }
      }
    }
  });

  // Screens and buttons
  $startBtn.addEventListener('click', () => { startGame(true); });
  $nightBtn.addEventListener('click', () => { state.night = !state.night; });
  $resumeBtn.addEventListener('click', () => { togglePause(false); });
  $retryBtn.addEventListener('click', () => { startGame(false); });
  $retryBtn2.addEventListener('click', () => { startGame(false); });
  if ($menuBtn) {
    console.log('Menu button found, adding event listener');
    $menuBtn.addEventListener('click', () => {
      console.log('Menu button clicked - returning to start screen');
      showScreen('start');
    });
  } else {
    console.log('Menu button not found!');
  }
  $closeSkillTree.addEventListener('click', () => {
    // Use the same logic as ESC key - toggle pause to return to game
    if (state.playing) {
      togglePause();
    } else {
      // If not in game, return to start screen
      showScreen('start');
    }
  });
  
  // Setup button event listeners
  function setupButtonListeners() {
    console.log('Setting up button listeners...');
    
    // New screen buttons - with null checks
    const controlsBtn = document.getElementById('controlsBtn');
    const settingsBtn = document.getElementById('settingsBtn');
    const skillTreeBtn = document.getElementById('skillTreeBtn');
    const closeControls = document.getElementById('closeControls');
    const closeSettings = document.getElementById('closeSettings');
    const resetSettings = document.getElementById('resetSettings');
  
  if (controlsBtn) {
    console.log('Controls button found, adding listener');
    controlsBtn.addEventListener('click', () => {
      console.log('Controls button clicked');
      showScreen('controls');
    });
  } else {
    console.log('Controls button not found');
  }
  if (settingsBtn) {
    console.log('Settings button found, adding listener');
    settingsBtn.addEventListener('click', () => {
      console.log('Settings button clicked');
      showScreen('settings');
    });
  } else {
    console.log('Settings button not found');
  }
  if (skillTreeBtn) {
    console.log('Skill tree button found, adding listener');
    skillTreeBtn.addEventListener('click', () => {
      console.log('Skill tree button clicked');
      // Set previous screen based on current game state
      if (state.playing && state.paused) {
        state.previousScreen = 'pause'; // Return to pause menu if paused
      } else if (state.playing) {
        state.previousScreen = null; // Return to game if playing
      } else {
        state.previousScreen = 'start'; // Return to start menu if not in game
      }
      showScreen('skillTree');
    });
  } else {
    console.log('Skill tree button not found');
  }
  if (closeControls) {
    console.log('Close controls button found, adding listener');
    closeControls.addEventListener('click', () => {
      console.log('Close controls clicked');
      const targetScreen = state.previousScreen || 'start';
      showScreen(targetScreen);
    });
  } else {
    console.log('Close controls button not found');
  }
  if (closeSettings) {
    console.log('Close settings button found, adding listener');
    closeSettings.addEventListener('click', () => {
      console.log('Close settings clicked');
      saveSettings();
      const targetScreen = state.previousScreen || 'start';
      showScreen(targetScreen);
    });
  } else {
    console.log('Close settings button not found');
  }
  if (resetSettings) resetSettings.addEventListener('click', () => resetSettings());
  
  // Credits button
  const creditsBtn = document.getElementById('creditsBtn');
  if (creditsBtn) {
    console.log('Credits button found, adding listener');
    creditsBtn.addEventListener('click', () => {
      console.log('Credits button clicked');
      showScreen('credits');
    });
  } else {
    console.log('Credits button not found!');
  }
  
  // Close credits button
  const closeCredits = document.getElementById('closeCredits');
  if (closeCredits) {
    console.log('Close credits button found, adding listener');
    closeCredits.addEventListener('click', () => {
      console.log('Close credits clicked');
      const targetScreen = state.previousScreen || 'start';
      showScreen(targetScreen);
    });
  } else {
    console.log('Close credits button not found!');
  }
  
  // Death screen menu button - ensure it works
  const menuBtn = document.getElementById('menuBtn');
  if (menuBtn) {
    console.log('Death screen menu button found, adding listener');
    menuBtn.addEventListener('click', () => {
      console.log('Death screen menu button clicked');
      showScreen('start');
    });
  } else {
    console.log('Death screen menu button not found!');
  }
  
  // Pause menu buttons - with null checks
  const pauseControlsBtn = document.getElementById('pauseControlsBtn');
  const pauseSkillTreeBtn = document.getElementById('pauseSkillTreeBtn');
  const pauseSettingsBtn = document.getElementById('pauseSettingsBtn');
  const pauseMenuBtn = document.getElementById('pauseMenuBtn');
  
  if (pauseControlsBtn) pauseControlsBtn.addEventListener('click', () => {
    state.previousScreen = 'pause';
    showScreen('controls');
  });
  if (pauseSkillTreeBtn) pauseSkillTreeBtn.addEventListener('click', () => {
    state.previousScreen = 'pause';
    showScreen('skillTree');
  });
  if (pauseSettingsBtn) pauseSettingsBtn.addEventListener('click', () => {
    state.previousScreen = 'pause';
    showScreen('settings');
  });
  if (pauseMenuBtn) pauseMenuBtn.addEventListener('click', () => showScreen('start'));
  }
  
  // Skill upgrade buttons
  document.querySelectorAll('.skill-btn').forEach(btn => {
    btn.addEventListener('click', () => {
      upgradeSkill(btn.dataset.skill);
    });
  });

  // Accessibility for buttons (Enter/Space)
  for (const el of [$startBtn,$resumeBtn,$retryBtn,$retryBtn2,$menuBtn,$nightBtn]) {
    el && el.addEventListener('keydown', e => {
      if (e.key === 'Enter' || e.key === ' ') { e.preventDefault(); el.click(); }
    });
  }

  function showScreen(which) {
    $screenStart.classList.toggle('hide', which !== 'start');
    $screenPause.classList.toggle('hide', which !== 'pause');
    $screenOver.classList.toggle('hide', which !== 'over');
    document.getElementById('screenSettings').classList.toggle('hide', which !== 'settings');
    document.getElementById('screenControls').classList.toggle('hide', which !== 'controls');
    document.getElementById('screenSkillTree').classList.toggle('hide', which !== 'skillTree');
    document.getElementById('screenCredits').classList.toggle('hide', which !== 'credits');
    
    // Hide HUD when showing screens (except pause screen)
    const shouldHideHUD = which !== null && which !== 'pause';
    document.getElementById('hud').style.display = shouldHideHUD ? 'none' : 'grid';
  }

  // Settings management
  function loadSettings() {
    const settings = JSON.parse(localStorage.getItem('redzone_settings') || '{}');
    
    // Load settings with defaults
    document.getElementById('masterVolume').value = settings.masterVolume || 80;
    document.getElementById('sfxVolume').value = settings.sfxVolume || 90;
    document.getElementById('particleQuality').value = settings.particleQuality || 'medium';
    document.getElementById('screenShakeEnabled').checked = settings.screenShakeEnabled !== false;
    document.getElementById('cameraFlashEnabled').checked = settings.cameraFlashEnabled !== false;

    document.getElementById('damageNumbersEnabled').checked = settings.damageNumbers !== false;
    document.getElementById('showFPS').checked = settings.showFPS || false;
    
    // Update display values
    document.getElementById('masterVolumeValue').textContent = document.getElementById('masterVolume').value + '%';
    document.getElementById('sfxVolumeValue').textContent = document.getElementById('sfxVolume').value + '%';
    
    // Apply settings
    applySettings();
  }
  
  function saveSettings() {
    const settings = {
      masterVolume: parseInt(document.getElementById('masterVolume').value),
      sfxVolume: parseInt(document.getElementById('sfxVolume').value),
      particleQuality: document.getElementById('particleQuality').value,
      screenShakeEnabled: document.getElementById('screenShakeEnabled').checked,
      cameraFlashEnabled: document.getElementById('cameraFlashEnabled').checked,

      damageNumbers: document.getElementById('damageNumbersEnabled').checked,
      showFPS: document.getElementById('showFPS').checked
    };
    
    localStorage.setItem('redzone_settings', JSON.stringify(settings));
    applySettings();
  }
  
  function resetSettings() {
    localStorage.removeItem('redzone_settings');
    loadSettings();
  }
  
  function applySettings() {
    // Apply volume settings
    const masterVolume = parseInt(document.getElementById('masterVolume').value) / 100;
    const sfxVolume = parseInt(document.getElementById('sfxVolume').value) / 100;
    
    // Apply gameplay settings
    state.autoReload = true; // Always enabled
    state.showDamage = document.getElementById('damageNumbersEnabled').checked;
    state.screenShakeEnabled = document.getElementById('screenShakeEnabled').checked;
    state.cameraFlashEnabled = document.getElementById('cameraFlashEnabled').checked;
    state.showFPS = document.getElementById('showFPS').checked;
    state.previousScreen = 'start'; // Track previous screen for navigation
    
    // Apply particle quality
    const particleQuality = document.getElementById('particleQuality').value;
    state.particleQuality = particleQuality;
  }
  
  // Settings slider event listeners
  document.getElementById('masterVolume').addEventListener('input', (e) => {
    document.getElementById('masterVolumeValue').textContent = e.target.value + '%';
  });
  
  document.getElementById('sfxVolume').addEventListener('input', (e) => {
    document.getElementById('sfxVolumeValue').textContent = e.target.value + '%';
  });

  function startGame(fromMenu) {
    // Initialize audio
    initAudio();
    
    state.playing = true;
    state.paused = false;
    state.wave = 1;
    state.waveTime = 0;
    state.score = 0;
    state.kills = 0;
    state.combo = 0;
    state.maxCombo = 0;
    state.powerMode = false;
    state.powerModeTimer = 0;
    state.autoReload = true;
    state.showDamage = false;
    
    // Clear background structures so they get regenerated
    state.backgroundStructures = null;
    state.damageNumbers = [];
    state.flash = 0;

    player.x = state.w / 2;
    player.y = state.h / 2;
    player.vx = player.vy = 0;
    player.hp = player.hpMax;
    player.stam = player.stamMax;
    player.inv = 0;
    player.dashCD = 0;
    player.weapon = 0;
    player.reloadT = 0;
    player.turrets = 3;
    player.barricades = 5;
    player.spikes = 3;
    player.mines = 2;
    player.turretType = 0;
    player.specialAbility = 'none';
    player.specialCooldown = 0;

    // Reset weapons
    for (const w of arsenal) {
      w.mag = w.magSize;
      w.reserve = Math.max(w.reserve, w.magSize);
      w.fireT = 0;
      // Only pistol unlocked at start
      w.unlocked = w.name === 'Pistol';
    }

    bullets.length = 0;
    enemies.length = 0;
    pickups.length = 0;
    particles.length = 0;
    turrets.length = 0; // Clear turrets
    barricades.length = 0; // Clear barricades
    spikes.length = 0; // Clear spikes
    mines.length = 0; // Clear mines
    allies.length = 0; // Clear allies
    state.speechBubbles.length = 0; // Clear speech bubbles
    state.graveyard.length = 0; // Clear graveyard

    spawnInitial();
    renderWeaponHUD();
    updateTurretHUD();
    updateHUD();
    
    // Start the game loop
    requestAnimationFrame(loop);
    
    // Ensure weapon selection is properly displayed
    const slots = $hud.weapons.children;
    for (let i = 0; i < slots.length; i++) {
      slots[i].classList.toggle('active', i === player.weapon);
    }

    if (fromMenu) showScreen(null);
    else showScreen(null);
  }

  function togglePause(forceState) {
    if (!state.playing) return;
    const next = typeof forceState === 'boolean' ? forceState : !state.paused;
    state.paused = next;
    showScreen(next ? 'pause' : null);
  }

  function gameOver() {
    state.playing = false;
    showScreen('over');
    $wavesStat.textContent = state.wave;
    $scoreStat.textContent = state.score;
    $killsStat.textContent = state.kills;
  }

  // HUD updates
  function updateHUD() {
    $hud.wave.textContent = state.wave;
    
    // Update wave timer with enhanced progress indicator
    if (state.waveTime <= 20) {
      const timeLeft = Math.ceil(20 - state.waveTime);
      $hud.waveTimer.textContent = `(${timeLeft}s)`;
    } else {
      const waveTime = Math.ceil(35 + state.wave * 3 - state.waveTime);
      $hud.waveTimer.textContent = `(${waveTime}s)`;
    }
    
    // Enhanced wave progress indicator
    const totalWaveTime = 35 + state.wave * 3;
    const waveProgress = Math.min(1, Math.max(0, state.waveTime / totalWaveTime));
    const filledBars = Math.floor(waveProgress * 10);
    const emptyBars = Math.max(0, 10 - filledBars);
    const progressBar = '‚ñà'.repeat(filledBars) + '‚ñë'.repeat(emptyBars);
    $hud.waveTimer.textContent += ` [${progressBar}]`;
    
    // Color-coded progress
    if (waveProgress > 0.8) {
      $hud.waveTimer.style.color = '#ff4444'; // Red when almost done
    } else if (waveProgress > 0.5) {
      $hud.waveTimer.style.color = '#ffaa00'; // Orange when halfway
    } else {
      $hud.waveTimer.style.color = '#b9c3cf'; // Normal color
    }
    
    // Update direction indicator (if element exists)
    if ($hud.direction) {
      const waveDirection = Math.floor((state.wave - 1) / 3) % 4;
      const directions = ['Top', 'Right', 'Bottom', 'Left'];
      $hud.direction.textContent = directions[waveDirection];
    }
    
    if ($hud.score) $hud.score.textContent = state.score;
    if ($hud.combo) $hud.combo.textContent = Math.round(state.combo);
    
    // Visual indicator when close to power mode
    if ($hud.combo) {
      if (state.combo >= 80 && !state.powerMode) {
        $hud.combo.style.color = '#ffaa00'; // Orange when very close
      } else if (state.combo >= 50) {
        $hud.combo.style.color = '#ff8800'; // Dark orange when close
      } else if (state.combo >= 25) {
        $hud.combo.style.color = '#ff4444'; // Red when building
      } else if (state.combo >= 10) {
        $hud.combo.style.color = '#ff6666'; // Light red when starting
      } else {
        $hud.combo.style.color = '#ffffff'; // White normally
      }
    }
    if ($hud.turrets) $hud.turrets.textContent = player.turrets;
    if ($hud.barricades) $hud.barricades.textContent = player.barricades;
    if ($hud.spikes) $hud.spikes.textContent = player.spikes;
    if ($hud.mines) $hud.mines.textContent = player.mines;
    if ($hud.healingPlatforms) $hud.healingPlatforms.textContent = player.healingPlatformCooldown > 0 ? Math.ceil(player.healingPlatformCooldown) + 's' : 'Ready';
    

    
    if ($hud.hpFill) $hud.hpFill.style.width = Math.max(0, (player.hp / player.hpMax) * 100).toFixed(1) + '%';
    if ($hud.stamFill) $hud.stamFill.style.width = Math.max(0, (player.stam / player.stamMax) * 100).toFixed(1) + '%';
    const w = arsenal[player.weapon];
    const re = player.reloadT > 0 ? (1 - player.reloadT / w.reload) : 0;
    if ($hud.reloadFill) $hud.reloadFill.style.width = Math.max(0, Math.min(100, re * 100)).toFixed(1) + '%';
    
    // Show ammo in the weapon info instead of reload bar
    const ammoPercent = w.mag / w.magSize;
    const ammoBar = document.querySelector('.ammo-bar');
    if (ammoBar) {
      ammoBar.style.width = (ammoPercent * 100).toFixed(1) + '%';
    }
    
    // Health status indicator with pulse animation
    if ($hud.hpFill) {
      const healthPercent = player.hp / player.hpMax;
      if (healthPercent <= 0.25) {
        $hud.hpFill.style.animation = 'pulse 1s ease-in-out infinite';
      } else {
        $hud.hpFill.style.animation = 'none';
      }
    }

    // Refresh weapon ammo display without rebuilding the whole grid
    if ($hud.weapons) {
      const slots = $hud.weapons.children;
      for (let i = 0; i < slots.length; i++) {
        slots[i].classList.toggle('active', i === player.weapon);
        const ammo = slots[i].querySelector('.ammo');
        if (ammo) {
          const weapon = arsenal[i];
          const ammoColor = weapon.mag <= 0 ? '#ff4444' : weapon.mag <= weapon.magSize * 0.2 ? '#ffaa00' : '#ffffff';
          ammo.innerHTML = `<span style="color: ${ammoColor}">${weapon.mag}</span>/<span>${weapon.reserve}</span>`;
        }
      }
    }
    
    // Update weapon info with enhanced details
    if ($hud.weaponInfo) {
      const currentWeapon = arsenal[player.weapon];
      const fireRate = (1/currentWeapon.fireDelay).toFixed(1);
      const damageColor = currentWeapon.damage > 80 ? '#ff4444' : currentWeapon.damage > 40 ? '#ffaa00' : '#ffffff';
      const fireRateColor = currentWeapon.fireDelay < 0.1 ? '#ff4444' : currentWeapon.fireDelay < 0.2 ? '#ffaa00' : '#ffffff';
      const ammoColor = currentWeapon.mag <= 0 ? '#ff4444' : currentWeapon.mag <= currentWeapon.magSize * 0.2 ? '#ffaa00' : '#ffffff';
      
      $hud.weaponInfo.innerHTML = `
        <div class="weapon-stats">
          <span style="color: ${damageColor}">Damage: ${currentWeapon.damage}</span>
          <span style="color: ${fireRateColor}">Fire Rate: ${fireRate}/s</span>
          <span>Range: ${currentWeapon.speed}</span>
          <span style="color: ${ammoColor}">${currentWeapon.auto ? 'AUTO' : 'SEMI'}</span>
          <span style="color: ${ammoColor}">Ammo: ${currentWeapon.mag}/${currentWeapon.magSize}</span>
        </div>
      `;
    }
  }

  // Spawning
  function spawnInitial() {
    // Give player 20 seconds to prepare - no enemies initially
    // Enemies will start spawning after 20 seconds
  }

  function placeTurret() {
    if (player.turrets <= 0) return;
    
    // Different turret types based on player.turretType
    const turretTypes = [
      { // Basic turret
        fireDelay: 0.8,
        range: 200,
        damage: 25,
        speed: 850,
        color: '#4a90e2',
        health: 100,
        name: 'Basic',
        cost: 1
      },
      { // Heavy turret
        fireDelay: 1.2,
        range: 180,
        damage: 45,
        speed: 700,
        color: '#ff6b35',
        health: 150,
        name: 'Heavy',
        cost: 2
      },
      { // Sniper turret
        fireDelay: 1.8,
        range: 350,
        damage: 80,
        speed: 1200,
        color: '#9b59b6',
        health: 80,
        name: 'Sniper',
        cost: 2
      },
      { // Shotgun turret
        fireDelay: 0.4,
        range: 150,
        damage: 15,
        speed: 600,
        color: '#ffaa00',
        health: 120,
        name: 'Shotgun',
        cost: 2,
        pellets: 5
      },
      { // Flamethrower turret
        fireDelay: 0.6,
        range: 120,
        damage: 35,
        speed: 400,
        color: '#ff4444',
        health: 90,
        name: 'Flamethrower',
        cost: 3,
        burnDamage: 8,
        burnDuration: 3
      }
    ];
    
    const turretConfig = turretTypes[player.turretType];
    
    // Check if player has enough turrets for this type
    if (player.turrets < turretConfig.cost) {
      addMessage(`Need ${turretConfig.cost} turrets for ${turretConfig.name}`);
      return;
    }
    
    turrets.push({
      x: player.x,
      y: player.y,
      r: 20,
      angle: 0,
      fireT: 0,
      fireDelay: turretConfig.fireDelay,
      range: turretConfig.range,
      damage: turretConfig.damage,
      speed: turretConfig.speed,
      color: turretConfig.color,
      health: turretConfig.health,
      maxHealth: turretConfig.health,
      target: null,
      type: player.turretType,
      pellets: turretConfig.pellets || 1,
      burnDamage: turretConfig.burnDamage || 0,
      burnDuration: turretConfig.burnDuration || 0
    });
    
    player.turrets -= turretConfig.cost;
    particlesBurst(player.x, player.y, turretConfig.color, 12, 150);
    sounds.pickup();
    addMessage(`Placed ${turretConfig.name} Turret`);
    
    // Visual placement indicator
    for (let i = 0; i < 8; i++) {
      const angle = (i / 8) * TAU;
      const x = player.x + Math.cos(angle) * 30;
      const y = player.y + Math.sin(angle) * 30;
      particles.push({
        x, y,
        vx: Math.cos(angle) * 50,
        vy: Math.sin(angle) * 50,
        r: 3,
        color: turretConfig.color,
        t: 0,
        life: 1.0
      });
    }
    
    // Player speech bubble
    const turretPhrases = ['Turret ready!', 'Defense up!', 'This will help!', 'Perfect placement!'];
    const phrase = turretPhrases[Math.floor(Math.random() * turretPhrases.length)];
    state.speechBubbles.push({
      x: player.x,
      y: player.y - 40,
      text: phrase,
      time: 0,
      life: 2.0,
      owner: null
    });
  }

  function updateTurretHUD() {
    const turretNames = ['Basic', 'Heavy', 'Sniper', 'Shotgun', 'Flamethrower'];
    const turretColors = ['#4a90e2', '#ff6b35', '#9b59b6', '#ffaa00', '#ff4444'];
    const turretCosts = [1, 2, 2, 2, 3];
    
    // Update turret counter with type indicator and cost
    const cost = turretCosts[player.turretType];
    $hud.turrets.innerHTML = `${player.turrets} <span style="color: ${turretColors[player.turretType]}">(${turretNames[player.turretType]} -${cost})</span>`;
  }

  function placeBarricade() {
    if (player.barricades <= 0) return;
    
    // Place rectangular barricade perpendicular to player's aim
    const angle = player.angle;
    const distance = 30;
    const barricadeX = player.x + Math.cos(angle) * distance;
    const barricadeY = player.y + Math.sin(angle) * distance;
    
    barricades.push({
      x: barricadeX,
      y: barricadeY,
      r: 35, // Larger radius
      width: 100, // Wider for better coverage
      height: 25, // Slightly taller
      angle: angle + Math.PI/2, // Perpendicular to aim direction (90 degrees)
      health: 300,
      maxHealth: 300
    });
    
    player.barricades--;
    particlesBurst(barricadeX, barricadeY, '#8b4513', 15, 150);
    sounds.pickup();
    addMessage('Placed Barricade');
    
    // Player speech bubble
    const barricadePhrases = ['Barricade up!', 'This will block them!', 'Defense ready!', 'Good cover!'];
    const phrase = barricadePhrases[Math.floor(Math.random() * barricadePhrases.length)];
    state.speechBubbles.push({
      x: player.x,
      y: player.y - 40,
      text: phrase,
      time: 0,
      life: 2.0,
      owner: null
    });
  }

  function placeVines() {
    if (player.spikes <= 0) return;
    
    // Place vines at player position
    const vineX = player.x;
    const vineY = player.y;
    
    spikes.push({
      x: vineX,
      y: vineY,
      r: 25,
      damage: 15,
      slowDuration: 2.0, // Reduced from 2.0 to 1.0
      slowFactor: 0.5,
      health: 150,
      maxHealth: 150
    });
    
    player.spikes--;
    particlesBurst(vineX, vineY, '#00aa00', 12, 150);
    sounds.pickup();
    addMessage('Placed Vines');
    
    // Player speech bubble
    const vinePhrases = ['Vines ready!', 'This will slow them!', 'Nature defense!', 'Green power!'];
    const phrase = vinePhrases[Math.floor(Math.random() * vinePhrases.length)];
    state.speechBubbles.push({
      x: player.x,
      y: player.y - 40,
      text: phrase,
      time: 0,
      life: 2.0,
      owner: null
    });
  }

  function placeMine() {
    if (player.mines <= 0) return;
    
    // Place mine at player position
    const mineX = player.x;
    const mineY = player.y;
    
    mines.push({
      x: mineX,
      y: mineY,
      r: 20,
      damage: 80,
      explosionRadius: 120,
      triggered: false,
      triggerRadius: 30
    });
    
    player.mines--;
    particlesBurst(mineX, mineY, '#ffaa00', 10, 150);
    sounds.pickup();
    addMessage('Placed Mine');
    
    // Player speech bubble
    const minePhrases = ['Mine set!', 'Boom time!', 'Explosive defense!', 'Trap ready!'];
    const phrase = minePhrases[Math.floor(Math.random() * minePhrases.length)];
    state.speechBubbles.push({
      x: player.x,
      y: player.y - 40,
      text: phrase,
      time: 0,
      life: 2.0,
      owner: null
    });
  }

  function placeHealingPlatform() {
    if (player.healingPlatformCooldown > 0) return;
    
    // Place healing platform at player position
    const platformX = player.x;
    const platformY = player.y;
    
    healingPlatforms.push({
      x: platformX,
      y: platformY,
      r: 60, // Healing radius
      healRate: 8, // Healing per second
      duration: 45, // Duration in seconds (increased from 20)
      time: 0,
      active: true
    });
    
    player.healingPlatformCooldown = 30; // 30 second cooldown
    particlesBurst(platformX, platformY, '#00ff88', 15, 200);
    sounds.pickup();
    addMessage('Placed Healing Platform');
    
    console.log(`Placed healing platform at (${platformX}, ${platformY}), total platforms: ${healingPlatforms.length}`);
    
    // Player speech bubble
    const platformPhrases = ['Healing zone active!', 'Safe haven created!', 'Rest area ready!', 'Healing field deployed!'];
    const phrase = platformPhrases[Math.floor(Math.random() * platformPhrases.length)];
    state.speechBubbles.push({
      x: player.x,
      y: player.y - 40,
      text: phrase,
      time: 0,
      life: 2.0,
      owner: null
    });
  }

  function activateSpecialAbility() {
    // Random special ability
    const abilities = ['timeSlow', 'explosion', 'heal', 'turretBoost'];
    const ability = abilities[Math.floor(Math.random() * abilities.length)];
    
    switch (ability) {
      case 'timeSlow':
        // Slow down all enemies
        for (const e of enemies) {
          e.speed *= 0.5;
          e.stun = 2;
        }
        addMessage('Time Slow Activated!');
        particlesBurst(player.x, player.y, '#00ffff', 20, 200);
        break;
        
      case 'explosion':
        // Massive explosion
        explosion(player.x, player.y, 200, 100, '#ffaa00', 0.8);
        addMessage('Mega Explosion!');
        break;
        
      case 'heal':
        // Heal player and allies
        player.hp = player.hpMax;
        for (const a of allies) {
          a.hp = a.maxHp;
        }
        addMessage('Full Heal!');
        particlesBurst(player.x, player.y, '#27d07e', 15, 150);
        break;
        
      case 'turretBoost':
        // Boost all turrets
        for (const t of turrets) {
          t.fireDelay *= 0.3;
          t.damage *= 2;
        }
        addMessage('Turret Boost!');
        particlesBurst(player.x, player.y, '#4a90e2', 15, 150);
        break;
    }
    
    player.specialCooldown = 15; // 15 second cooldown
    
    // Special ability speech bubble
    const specialPhrases = ['Special move!', 'Power up!', 'Ultimate!', 'Amazing!'];
    const phrase = specialPhrases[Math.floor(Math.random() * specialPhrases.length)];
    state.speechBubbles.push({
      x: player.x,
      y: player.y - 40,
      text: phrase,
      time: 0,
      life: 2.5,
      owner: null
    });
  }

  function addMessage(text, category = 'default') {
    state.messages.push({
      text: text,
      time: 0,
      life: 4.0, // Message stays for 4 seconds
      y: 0,
      category: category
    });
  }

  // Achievement system
  function unlockAchievement(id, name, description) {
    if (!state.achievements.has(id)) {
      state.achievements.add(id);
      addMessage(`üèÜ ACHIEVEMENT: ${name}`);
      state.skillPoints += 1; // Award skill point for achievement
      cameraFlash(0.3);
      sounds.explosion(0.2);
    }
  }

  function checkAchievements() {
    // Kill-based achievements
    if (state.kills >= 100 && !state.achievements.has('killer_100')) {
      unlockAchievement('killer_100', 'Century Slayer', 'Kill 100 enemies');
    }
    if (state.kills >= 500 && !state.achievements.has('killer_500')) {
      unlockAchievement('killer_500', 'Mass Murderer', 'Kill 500 enemies');
    }
    if (state.kills >= 1000 && !state.achievements.has('killer_1000')) {
      unlockAchievement('killer_1000', 'Genocidal Maniac', 'Kill 1000 enemies');
    }
    
    // Wave-based achievements
    if (state.wave >= 10 && !state.achievements.has('wave_10')) {
      unlockAchievement('wave_10', 'Survivor', 'Reach wave 10');
    }
    if (state.wave >= 20 && !state.achievements.has('wave_20')) {
      unlockAchievement('wave_20', 'Veteran', 'Reach wave 20');
    }
    if (state.wave >= 30 && !state.achievements.has('wave_30')) {
      unlockAchievement('wave_30', 'Legend', 'Reach wave 30');
    }
    
    // Combo achievements
    if (state.maxCombo >= 50 && !state.achievements.has('combo_50')) {
      unlockAchievement('combo_50', 'Combo Master', 'Achieve 50-kill combo');
    }
    if (state.maxCombo >= 100 && !state.achievements.has('combo_100')) {
      unlockAchievement('combo_100', 'Combo God', 'Achieve 100-kill combo');
    }
    
    // Score achievements
    if (state.score >= 10000 && !state.achievements.has('score_10k')) {
      unlockAchievement('score_10k', 'High Scorer', 'Reach 10,000 points');
    }
    if (state.score >= 50000 && !state.achievements.has('score_50k')) {
      unlockAchievement('score_50k', 'Point Collector', 'Reach 50,000 points');
    }
  }

  // Skill Tree Functions
  function openSkillTree() {
    state.paused = true;
    $screenSkillTree.classList.remove('hide');
    updateSkillTreeUI();
  }

  function closeSkillTree() {
    state.paused = false;
    $screenSkillTree.classList.add('hide');
  }

  function updateSkillTreeUI() {
    $skillPoints.textContent = state.skillPoints;
    document.getElementById('healthLevel').textContent = state.skillTree.health;
    document.getElementById('speedLevel').textContent = state.skillTree.speed;
    document.getElementById('damageLevel').textContent = state.skillTree.damage;
    document.getElementById('reloadLevel').textContent = state.skillTree.reload;
    document.getElementById('staminaLevel').textContent = state.skillTree.stamina;
    document.getElementById('pickupRangeLevel').textContent = state.skillTree.pickupRange;
    
    // Update button states
    const buttons = document.querySelectorAll('.skill-btn');
    buttons.forEach(btn => {
      const skill = btn.dataset.skill;
      const level = state.skillTree[skill];
      const canUpgrade = state.skillPoints > 0 && level < 5;
      btn.disabled = !canUpgrade;
      btn.textContent = canUpgrade ? `Upgrade (1 point)` : level >= 5 ? 'Max Level' : 'Not enough points';
    });
  }

  function upgradeSkill(skill) {
    if (state.skillPoints > 0 && state.skillTree[skill] < 5) {
      state.skillPoints--;
      state.skillTree[skill]++;
      
      // Apply the upgrade
      applySkillUpgrade(skill);
      updateSkillTreeUI();
      
      // Visual feedback
      addMessage(`üîß ${skill.charAt(0).toUpperCase() + skill.slice(1)} upgraded!`);
      cameraFlash(0.2);
      sounds.explosion(0.1);
    }
  }

  function applySkillUpgrade(skill) {
    switch(skill) {
      case 'health':
        player.hpMax = 100 + (state.skillTree.health * 20);
        player.hp = Math.min(player.hp, player.hpMax);
        break;
      case 'speed':
        player.speed = 230 + (state.skillTree.speed * 23);
        break;
      case 'damage':
        // Damage boost is applied in weapon damage calculation
        break;
      case 'reload':
        // Reload speed is applied in weapon reload calculation
        break;
      case 'stamina':
        player.stamMax = 100 + (state.skillTree.stamina * 25);
        player.stam = Math.min(player.stam, player.stamMax);
        break;
    }
  }

  // Environmental Hazards System
  function spawnHazard() {
    const types = ['lava', 'ice', 'wind'];
    const type = types[Math.floor(Math.random() * types.length)];
    const x = rand(100, state.w - 100);
    const y = rand(100, state.h - 100);
    
    const hazard = {
      x, y,
      type,
      r: 80,
      time: 0,
      life: 15, // 15 seconds duration
      damage: type === 'lava' ? 5 : type === 'ice' ? 0 : 0,
      slowEffect: type === 'ice' ? 0.5 : 1,
      pushForce: type === 'wind' ? 200 : 0
    };
    
    hazards.push(hazard);
    
    // Visual effect
    const color = type === 'lava' ? '#ff4400' : type === 'ice' ? '#00aaff' : '#ffffff';
    particlesBurst(x, y, color, 20, 300);
    addMessage(`${type.toUpperCase()} HAZARD APPEARS!`);
  }

  function updateHazards(dt) {
    for (let i = hazards.length - 1; i >= 0; i--) {
      const h = hazards[i];
      h.time += dt;
      
      // Remove expired hazards
      if (h.time >= h.life) {
        hazards.splice(i, 1);
        continue;
      }
      
      // Apply hazard effects
      const playerDist = Math.hypot(player.x - h.x, player.y - h.y);
      if (playerDist < h.r) {
        // Player in hazard
        if (h.damage > 0) {
          damagePlayer(h.damage * dt);
        }
        if (h.slowEffect < 1) {
          player.speed *= h.slowEffect;
        }
        if (h.pushForce > 0) {
          const angle = Math.atan2(player.y - h.y, player.x - h.x);
          player.x += Math.cos(angle) * h.pushForce * dt;
          player.y += Math.sin(angle) * h.pushForce * dt;
        }
      }
      
      // Affect enemies
      for (const e of enemies) {
        const enemyDist = Math.hypot(e.x - h.x, e.y - h.y);
        if (enemyDist < h.r) {
          if (h.damage > 0) {
            hitEnemy(e, h.damage * dt, 0, 0);
          }
          if (h.slowEffect < 1) {
            e.speed *= h.slowEffect;
          }
          if (h.pushForce > 0) {
            const angle = Math.atan2(e.y - h.y, e.x - h.x);
            e.x += Math.cos(angle) * h.pushForce * dt;
            e.y += Math.sin(angle) * h.pushForce * dt;
          }
        }
      }
    }
  }

  function drawHazards() {
    for (const h of hazards) {
      const alpha = 0.3 + Math.sin(state.time * 3) * 0.1;
      
      if (h.type === 'lava') {
        // Lava pool
        ctx.fillStyle = `rgba(255, 68, 0, ${alpha})`;
        ctx.beginPath();
        ctx.arc(h.x, h.y, h.r, 0, TAU);
        ctx.fill();
        
        // Lava bubbles
        ctx.fillStyle = `rgba(255, 100, 0, ${alpha * 0.8})`;
        for (let i = 0; i < 8; i++) {
          const angle = (i / 8) * TAU + state.time * 2;
          const x = h.x + Math.cos(angle) * h.r * 0.6;
          const y = h.y + Math.sin(angle) * h.r * 0.6;
          ctx.beginPath();
          ctx.arc(x, y, 3 + Math.sin(state.time * 4 + i) * 2, 0, TAU);
          ctx.fill();
        }
      } else if (h.type === 'ice') {
        // Ice field
        ctx.fillStyle = `rgba(0, 170, 255, ${alpha})`;
        ctx.beginPath();
        ctx.arc(h.x, h.y, h.r, 0, TAU);
        ctx.fill();
        
        // Ice crystals
        ctx.strokeStyle = `rgba(255, 255, 255, ${alpha * 0.8})`;
        ctx.lineWidth = 2;
        for (let i = 0; i < 6; i++) {
          const angle = (i / 6) * TAU;
          const x = h.x + Math.cos(angle) * h.r * 0.7;
          const y = h.y + Math.sin(angle) * h.r * 0.7;
          ctx.beginPath();
          ctx.moveTo(x, y);
          ctx.lineTo(x + Math.cos(angle) * 10, y + Math.sin(angle) * 10);
          ctx.stroke();
        }
      } else if (h.type === 'wind') {
        // Wind field
        ctx.fillStyle = `rgba(255, 255, 255, ${alpha * 0.5})`;
        ctx.beginPath();
        ctx.arc(h.x, h.y, h.r, 0, TAU);
        ctx.fill();
        
        // Wind particles
        ctx.fillStyle = `rgba(255, 255, 255, ${alpha * 0.8})`;
        for (let i = 0; i < 12; i++) {
          const angle = (i / 12) * TAU + state.time * 4;
          const x = h.x + Math.cos(angle) * h.r * 0.8;
          const y = h.y + Math.sin(angle) * h.r * 0.8;
          ctx.beginPath();
          ctx.arc(x, y, 2, 0, TAU);
          ctx.fill();
        }
      }
      
      // Duration indicator
      const progress = h.time / h.life;
      ctx.fillStyle = `rgba(255, 255, 255, ${alpha})`;
      ctx.fillRect(h.x - h.r, h.y - h.r - 10, h.r * 2 * (1 - progress), 4);
    }
  }

  function spawnBoss() {
    // Choose boss type based on wave
    let bossType = 'boss';
    let bossName = 'BOSS ZOMBIE';
    let bossColor = '#ff0000';
    
    if (state.wave === 10) {
      bossType = 'necromancer';
      bossName = 'NECROMANCER BOSS';
      bossColor = '#8b00ff';
    } else if (state.wave === 15) {
      bossType = 'titan';
      bossName = 'TITAN BOSS';
      bossColor = '#ff8800';
    }
    
    const boss = {
      x: state.w * 0.2,
      y: state.h * 0.2,
      r: bossType === 'titan' ? 50 : 40,
      speed: bossType === 'titan' ? 30 : 50,
      hpMax: bossType === 'titan' ? 2000 : bossType === 'necromancer' ? 1500 : 1200,
      hp: 0,
      dmg: bossType === 'titan' ? 80 : bossType === 'necromancer' ? 60 : 50,
      cd: 0,
      type: bossType,
      wob: Math.random() * TAU,
      stun: 0,
      special: bossType === 'necromancer' ? 'summon_undead' : bossType === 'titan' ? 'earthquake' : 'summon',
      lastSpecial: 0,
      phase: 0,
      phaseTimer: 0,
      regen: 0,
      bossType: bossType
    };
    boss.hp = boss.hpMax;
    enemies.push(boss);
    
    // Boss spawn effect
    particlesBurst(boss.x, boss.y, bossColor, 40, 400);
    cameraFlash(0.5);
    sounds.explosion(0.7);
    
    // Boss dialogue based on type
    let bossDialogue = '';
    if (bossType === 'boss') {
      const phrases = [
        "I WILL CRUSH YOU!",
        "YOUR END IS NEAR!",
        "PREPARE TO DIE!",
        "I AM UNSTOPPABLE!",
        "YOU CANNOT ESCAPE!"
      ];
      bossDialogue = phrases[Math.floor(Math.random() * phrases.length)];
    } else if (bossType === 'necromancer') {
      const phrases = [
        "THE DEAD RISE FOR ME!",
        "I COMMAND THE SHADOWS!",
        "YOUR SOUL WILL BE MINE!",
        "DARKNESS CONSUMES ALL!",
        "I AM THE NECROMANCER!"
      ];
      bossDialogue = phrases[Math.floor(Math.random() * phrases.length)];
    } else if (bossType === 'titan') {
      const phrases = [
        "I AM THE TITAN!",
        "EARTH TREMBLES BEFORE ME!",
        "YOUR PUNY WEAPONS MEAN NOTHING!",
        "I WILL SMASH YOU TO DUST!",
        "THE GROUND ITSELF FEARS ME!"
      ];
      bossDialogue = phrases[Math.floor(Math.random() * phrases.length)];
    }
    
    // Add boss speech bubble
    state.speechBubbles.push({
      x: boss.x,
      y: boss.y - 80,
      text: bossDialogue,
      time: 0,
      life: 4.0,
      owner: boss,
      color: '#ff0000',
      scale: 1.5
    });
    
    // Announce boss
    addMessage(`${bossName} APPEARS!`);
  }

  function spawnEnemy() {
    // Focus on one direction at a time, but allow some variety
    const waveDirection = Math.floor((state.wave - 1) / 3) % 4; // Changes every 3 waves
    const currentDirection = waveDirection;
    
    // 70% chance to spawn from the focused direction, 30% from others
    let spawnDirection;
    if (Math.random() < 0.7) {
      spawnDirection = currentDirection;
    } else {
      spawnDirection = Math.floor(Math.random() * 4);
    }
    
    const margin = 40;
    let x = 0, y = 0;
    
    if (spawnDirection === 0) { // Top
      x = rand(-margin, state.w + margin);
      y = -margin;
    } else if (spawnDirection === 1) { // Right
      x = state.w + margin;
      y = rand(-margin, state.h + margin);
    } else if (spawnDirection === 2) { // Bottom
      x = rand(-margin, state.w + margin);
      y = state.h + margin;
    } else { // Left
      x = -margin;
      y = rand(-margin, state.h + margin);
    }
    
    const enemyTypes = ['zombie', 'brute', 'spitter', 'charger'];
    const type = enemyTypes[Math.floor(Math.random() * enemyTypes.length)];
    
    const e = {
      x, y,
      r: type === 'brute' ? 18 + rand(0, 4) : type === 'spitter' ? 12 + rand(0, 3) : 14 + rand(0, 6),
              speed: type === 'charger' ? 80 + rand(0, 20) : type === 'spitter' ? 30 + rand(0, 10) : 40 + rand(0, 15) + state.wave * 0.3,
      hpMax: type === 'brute' ? 120 + state.wave * 12 : type === 'spitter' ? 40 + state.wave * 6 : 50 + state.wave * 8 + rand(0, 12),
      hp: 0,
      dmg: type === 'brute' ? 20 + state.wave * 3 : type === 'spitter' ? 8 + state.wave : 12 + state.wave * 2,
      cd: 0,
      type,
      wob: Math.random() * TAU,
      stun: 0,
      special: type === 'spitter' ? 'ranged' : type === 'charger' ? 'dash' : 'melee',
      lastSpecial: 0,
    };
    e.hp = e.hpMax;
    enemies.push(e);
  }

  // Soldier names and personalities
  const soldierNames = [
    'Joe', 'Sarah', 'Mike', 'Emma', 'Alex', 'Zoe', 'Tom', 'Luna', 'Sam', 'Maya',
    'Jake', 'Nova', 'Rex', 'Iris', 'Max', 'Sky', 'Leo', 'Ruby', 'Finn', 'Aria'
  ];

  const animalCompanions = [
    { name: 'Dog', color: '#8b7355', accent: '#6b5a4a', type: 'dog', personality: 'loyal', 
      arrival: ['*Woof* Master, I\'m here!', '*Bark* Ready to protect!', '*Woof* Your faithful companion!', '*Bark* I\'ll guard you!', '*Woof* Loyal to the end!'],
      motivational: ['*Woof* I\'ll protect you!', '*Bark* Stay safe, master!', '*Woof* I\'m watching your back!', '*Bark* Nothing will harm you!', '*Woof* I\'m your shield!', '*Bark* I\'ll defend you!', '*Woof* You\'re safe with me!', '*Bark* I\'ll never leave you!'] },
    { name: 'Wolf', color: '#6a5a4a', accent: '#4a3a2a', type: 'wolf', personality: 'aggressive', 
      arrival: ['*Howl* Ready to hunt!', '*Growl* Let\'s track them down!', '*Bark* Wolf reporting!', '*Howl* The pack is here!', '*Growl* Time to hunt!'],
      motivational: ['*Growl* We\'re the pack!', '*Howl* Keep fighting!', '*Bark* Stay strong!', '*Growl* We\'re unstoppable!', '*Howl* The hunt continues!', '*Bark* We\'re winning!', '*Growl* Nothing stops the pack!', '*Howl* Victory is ours!'] },
    { name: 'Eagle', color: '#8b4513', accent: '#6b3513', type: 'eagle', personality: 'precise', 
      arrival: ['*Screech* Eyes in the sky!', '*Cry* I see everything!', '*Screech* Eagle ready!', '*Cry* From the heavens!', '*Screech* Soaring in!'],
      motivational: ['*Screech* We\'re soaring!', '*Cry* Stay sharp!', '*Screech* Keep it up!', '*Cry* I see victory!', '*Screech* We\'re flying high!', '*Cry* Precision wins!', '*Screech* The sky is ours!', '*Cry* We\'re unstoppable!'] },
    { name: 'Bear', color: '#8b4513', accent: '#6b3513', type: 'bear', personality: 'steady', 
      arrival: ['*Roar* Heavy support here!', '*Growl* Time to get serious!', '*Roar* Bear ready!', '*Growl* I am strength!', '*Roar* Let\'s crush them!'],
      motivational: ['*Roar* We\'re unstoppable!', '*Growl* Stay focused!', '*Roar* Keep fighting!', '*Growl* We\'re the strongest!', '*Roar* Nothing can stop us!', '*Growl* We\'re unbreakable!', '*Roar* We\'re crushing it!', '*Growl* We\'re the best!'] },
    { name: 'Fennec', color: '#f4a460', accent: '#d49450', type: 'fennec', personality: 'alert', 
      arrival: ['*Yip* Big ears, big heart!', '*Bark* I can hear everything!', '*Yip* Fennec ready!', '*Bark* My ears are ready!', '*Yip* Cute and deadly!'],
      motivational: ['*Yip* My ears hear victory!', '*Bark* We\'re too cute to lose!', '*Yip* Big ears, big success!', '*Bark* I hear them coming!', '*Yip* We\'re adorable and deadly!', '*Bark* My ears never fail!', '*Yip* We\'re too cute for them!', '*Bark* Big ears, big wins!'] },
    { name: 'Fox', color: '#ff6b35', accent: '#d4552a', type: 'fox', personality: 'aggressive', 
      arrival: ['*Yip* Quick and ready!', '*Bark* Let\'s move fast!', '*Yip* Fox here!', '*Bark* Time to be clever!', '*Yip* Ready to outsmart them!'],
      motivational: ['*Yip* We\'re too clever!', '*Bark* Stay quick!', '*Yip* We\'re fast!', '*Bark* Keep moving!', '*Yip* We\'re outsmarting them!', '*Bark* We\'re too smart!', '*Yip* We\'ve got this!', '*Bark* We\'re the cleverest!'] },
    { name: 'Owl', color: '#4a4a6a', accent: '#2a2a4a', type: 'owl', personality: 'precise', 
      arrival: ['*Hoot* Wisdom and precision!', '*Hoot* I see in the dark!', '*Hoot* Owl ready!', '*Hoot* Knowledge is power!', '*Hoot* Wisdom guides us!'],
      motivational: ['*Hoot* We are wise!', '*Hoot* Stay sharp!', '*Hoot* We\'re watching!', '*Hoot* Knowledge wins!', '*Hoot* We\'re the wisest!', '*Hoot* Wisdom never fails!', '*Hoot* We see everything!', '*Hoot* We know the way!'] },
    { name: 'Dolphin', color: '#4a90e2', accent: '#357abd', type: 'dolphin', personality: 'medic',
      arrival: ['*Splash* Medic reporting for duty!', '*Click* I bring healing from the depths!', '*Whistle* Your health is my priority!', '*Click* Medic dolphin ready!', '*Whistle* I\'m here to heal!'],
      motivational: ['*Click* I\'m here to keep you alive!', '*Whistle* No one dies on my watch!', '*Click* Healing is my calling!', '*Whistle* Stay strong, I\'ve got you!', '*Click* We\'re all in this together!', '*Whistle* I\'ll patch you up!', '*Click* Your health comes first!', '*Whistle* I\'m your guardian angel!'] }
  ];

  function spawnAlly() {
    // Spawn friendly soldier occasionally
    if (allies.length < 3) { // Removed random check since it's handled in update loop
      // Spawn allies closer to the player and within screen bounds
      const margin = 50;
      let x, y;
      
      // In the first 30 seconds, spawn allies closer to player
      const isEarlyGame = state.waveTime < 30;
      
      if (isEarlyGame) {
        // Spawn allies near player for early game
        const distance = rand(80, 150);
        const angle = rand(0, TAU);
        x = player.x + Math.cos(angle) * distance;
        y = player.y + Math.sin(angle) * distance;
        
        // Keep within screen bounds
        x = Math.max(margin, Math.min(state.w - margin, x));
        y = Math.max(margin, Math.min(state.h - margin, y));
      } else {
        // Choose a side and ensure they spawn within screen bounds
        const side = Math.floor(Math.random() * 4);
        if (side === 0) { // Right
          x = Math.min(state.w - margin, state.w * 0.85);
          y = rand(margin, state.h - margin);
        } else if (side === 1) { // Bottom
          x = rand(margin, state.w - margin);
          y = Math.min(state.h - margin, state.h * 0.85);
        } else if (side === 2) { // Left
          x = Math.max(margin, state.w * 0.15);
          y = rand(margin, state.h - margin);
        } else { // Top
          x = rand(margin, state.w - margin);
          y = Math.max(margin, state.h * 0.15);
        }
      }
      
      // Get available animal types (not already spawned)
      const existingTypes = allies.map(a => a.animalType.type);
      const availableTypes = animalCompanions.filter(animal => !existingTypes.includes(animal.type));
      
      // If no unique types available, don't spawn
      if (availableTypes.length === 0) return;
      
      const animalType = availableTypes[Math.floor(Math.random() * availableTypes.length)];
      const animalName = animalType.name;
      
      const ally = {
        x, y,
        r: 16,
        speed: 80 + rand(0, 20),
        hp: animalType.type === 'dolphin' ? 200 : 80, // Much more health for dolphin
        maxHp: animalType.type === 'dolphin' ? 200 : 80,
        fireT: 0,
        fireDelay: 0.4,
        damage: 15,
        angle: 0,
        target: null,
        type: 'animal',
        name: animalName,
        animalType: animalType,
        personality: animalType.personality
      };
      
      allies.push(ally);
      
      // Add speech bubble for arrival
      const arrivalMessage = animalType.arrival[Math.floor(Math.random() * animalType.arrival.length)];
      state.speechBubbles.push({
        x: ally.x,
        y: ally.y - 40,
        text: arrivalMessage,
        time: 0,
        life: 3.0,
        owner: ally
      });
      
      // Announce arrival
      addMessage(`${animalName} the ${animalType.name} arrived!`);
      console.log(`Spawned ${animalName} at (${x}, ${y})`); // Debug log
    }
  }

  function dropPickup(x, y) {
    const roll = Math.random();
    let type;
    if (roll < 0.15) { // Reduced from 60% to 15% - drastic reduction
      type = 'ammo';
    } else if (roll < 0.60) { // Reduced from 0.75 to 0.60 - less health drops
      type = 'med';
    } else if (roll < 0.85) {
      type = 'stam';
    } else if (roll < 0.92) {
      // 7% chance for turret drop
      type = 'turret';
    } else if (roll < 0.97) {
      // 5% chance for barricade drop
      type = 'barricade';
    } else if (roll < 0.99) {
      // 2% chance for spike drop
      type = 'spike';
    } else if (roll < 0.997) {
      // 0.3% chance for healing platform drop (reduced from 0.5%)
      type = 'healingPlatform';
    } else {
      // 0.3% chance for weapon drop (reduced from 0.5%)
      const availableWeapons = arsenal.filter(w => !w.unlocked);
      if (availableWeapons.length > 0) {
        const weapon = availableWeapons[Math.floor(Math.random() * availableWeapons.length)];
        weapon.unlocked = true;
        renderWeaponHUD();
        pickups.push({
          x, y,
          r: 18,
          type: 'weapon',
          weaponName: weapon.name,
          spin: rand(0, TAU),
          t: 0,
        });
        return;
      } else {
        type = 'ammo'; // Fallback if all weapons unlocked
      }
    }
    
    pickups.push({
      x, y,
      r: 18,
      type,
      spin: rand(0, TAU),
      t: 0,
    });
  }

  // Performance tracking variables
  let last = performance.now();
  let frameCount = 0;
  let fps = 60;
  
  // Update loop with performance optimization
  
  function loop(now) {
    const rawDt = Math.min(0.033, (now - last) / 1000);
    last = now;
    
    // Calculate FPS for performance monitoring
    frameCount++;
    if (frameCount % 60 === 0) {
      fps = Math.round(1 / rawDt);
    }
    
    if (!state.paused) {
      state.dt = rawDt;
      state.time += rawDt;
      update(rawDt);
      draw();
    }
    requestAnimationFrame(loop);
  }

  function update(dt) {
    // Dynamic weather and background system
    updateWeather(dt);
    updateMusic(dt);
    
    // Night/day subtle shift
    if (state.night) state.vignette = lerp(state.vignette, 0.75, 0.02);
    else state.vignette = lerp(state.vignette, 0.6, 0.02);

    // Player movement
    const k = input.keys;
    let ax = 0, ay = 0;
    if (k.has('w')) ay -= 1;
    if (k.has('s')) ay += 1;
    if (k.has('a')) ax -= 1;
    if (k.has('d')) ax += 1;
    const len = Math.hypot(ax, ay) || 1;
    ax /= len; ay /= len;

    const sprint = k.has('shift') && player.stam > 0.4;
    const speed = player.speed * (sprint ? 1.45 : 1);
    player.vx = lerp(player.vx, ax * speed, 0.18);
    player.vy = lerp(player.vy, ay * speed, 0.18);
    player.x = clamp(player.x + player.vx * dt, 0, state.w);
    player.y = clamp(player.y + player.vy * dt, 0, state.h);
    
    // Player collision with barricades - only for enemies, not player
    // Player can approach barricades freely

    // Stamina
    const moveMag = Math.hypot(player.vx, player.vy) / player.speed;
    if (sprint && moveMag > 0.2) player.stam -= 35 * dt;
    else player.stam += 22 * dt;
    player.stam = clamp(player.stam, 0, player.stamMax);

    // Dash
    if (input.dash && player.dashCD <= 0 && player.stam >= 18) {
      input.dash = false;
      player.stam -= 18;
      player.dashCD = 0.7;
      const ang = Math.atan2(input.mouse.y - player.y, input.mouse.x - player.x);
      const pow = 460;
      player.x = clamp(player.x + Math.cos(ang) * 40, 0, state.w);
      player.y = clamp(player.y + Math.sin(ang) * 40, 0, state.h);
      particlesBurst(player.x, player.y, '#8ac5ff', 8, 150);
      cameraFlash(0.16);
      knockEnemies(player.x, player.y, 60, 220);
      sounds.dash();
      
      // Dash speech bubble
      const dashPhrases = ['Whoosh!', 'Fast!', 'Zoom!', 'Dash!'];
      const phrase = dashPhrases[Math.floor(Math.random() * dashPhrases.length)];
      state.speechBubbles.push({
        x: player.x,
        y: player.y - 40,
        text: phrase,
        time: 0,
        life: 1.5,
        owner: null
      });
    }
    player.dashCD -= dt;

    // Aim
    player.angle = Math.atan2(input.mouse.y - player.y, input.mouse.x - player.x);

    // Invulnerability blink timer
    if (player.inv > 0) player.inv -= dt;

    // Reload
    const curW = arsenal[player.weapon];
    if (player.reloadT > 0) {
      player.reloadT -= dt;
      if (player.reloadT <= 0) {
        const need = curW.magSize - curW.mag;
        const take = Math.min(need, curW.reserve);
        curW.mag += take;
        curW.reserve -= take;
        
        // Reload completion effect
        particlesBurst(player.x, player.y, '#ffbf00', 8, 120);
        addMessage('Reloaded!');
        sounds.reload();
      }
    } else {
          // Firing
    curW.fireT -= dt;
    if ((input.mouse.down || (curW.auto && input.keys.has(' '))) && curW.fireT <= 0) {
      tryFire(curW);
    }
    
    // Auto-reload when empty
    if (state.autoReload && curW.mag <= 0 && curW.reserve > 0 && player.reloadT <= 0) {
      startReload();
    }
    }

    // Enemies
    for (let i = enemies.length - 1; i >= 0; i--) {
      const e = enemies[i];
      e.wob += dt * 3;
      e.stun = Math.max(0, e.stun - dt);
      e.lastSpecial += dt;
      
      // Burn damage over time
      if (e.burnTimer > 0) {
        e.burnTimer -= dt;
        e.hp -= (e.burnDamage || 0) * dt;
        // Burn particles
        if (Math.random() < 0.3) {
          particles.push({
            x: e.x + rand(-10, 10),
            y: e.y + rand(-10, 10),
            vx: rand(-20, 20),
            vy: rand(-30, -10),
            r: rand(1, 3),
            color: '#ffaa00',
            t: 0,
            life: rand(0.5, 1.2),
          });
        }
      }
      
      const dx = player.x - e.x, dy = player.y - e.y;
      const dist = Math.hypot(dx, dy) || 1;
      const waveBoost = 1 + (state.wave - 1) * 0.008; // Increased from 0.005 to 0.008
      const speed = e.speed * waveBoost * 1.3; // 30% faster from the start!
      
      // Only move if not stunned
      if (e.stun <= 0) {
        let moveX = (dx / dist) * speed * dt;
        let moveY = (dy / dist) * speed * dt;
        
              // Special abilities
      if (e.type === 'boss') {
        // Boss special behavior
        e.phaseTimer += dt;
        e.regen += dt;
        
        // Health regeneration
        if (e.regen > 3 && e.hp < e.hpMax) {
          e.hp = Math.min(e.hpMax, e.hp + 5);
          e.regen = 0;
        }
        
        if (e.phaseTimer > 4) {
          e.phase = (e.phase + 1) % 4;
          e.phaseTimer = 0;
          
          if (e.phase === 0) {
            // Summon minions
            for (let i = 0; i < 4; i++) {
              const minion = {
                x: e.x + rand(-60, 60),
                y: e.y + rand(-60, 60),
                r: 12,
                speed: 70,
                hpMax: 40,
                hp: 40,
                dmg: 10,
                cd: 0,
                type: 'minion',
                wob: Math.random() * TAU,
                stun: 0
              };
              enemies.push(minion);
            }
            particlesBurst(e.x, e.y, '#ff0000', 20, 200);
            addMessage("Boss summons reinforcements!");
          } else if (e.phase === 1) {
            // Rage mode - faster and stronger
            e.speed = 90;
            e.dmg = 60;
            particlesBurst(e.x, e.y, '#ff4444', 15, 150);
            addMessage("Boss enters RAGE MODE!");
          } else if (e.phase === 2) {
            // Charge attack
            e.speed = 120;
            e.dmg = 80;
            particlesBurst(e.x, e.y, '#ff8800', 20, 250);
            addMessage("Boss charges forward!");
          } else {
            // Normal mode
            e.speed = 50;
            e.dmg = 50;
          }
        }
        
        // Boss movement - more aggressive
        moveX *= 0.8;
        moveY *= 0.8;
      } else if (e.type === 'charger') {
        // Charger dash attack with randomization
        if (e.lastSpecial > 2.0 && dist < 150) {
          moveX *= 2.5 + Math.random() * 1.0; // Random dash intensity
          moveY *= 2.5 + Math.random() * 1.0;
          e.lastSpecial = 0;
          particlesBurst(e.x, e.y, '#ff4444', 8, 100);
        } else {
          // Charger normal movement - straight lines with slight randomization
          const straightLineFactor = 0.8 + Math.random() * 0.4; // 80-120% straightness
          moveX *= straightLineFactor;
          moveY *= straightLineFactor;
          
          // Add slight perpendicular movement for unpredictability
          const perpX = -moveY * (Math.random() - 0.5) * 0.3;
          const perpY = moveX * (Math.random() - 0.5) * 0.3;
          moveX += perpX;
          moveY += perpY;
        }
      } else if (e.special === 'ranged' && e.lastSpecial > 1.5 && dist < 200) {
        // Spitter ranged attack
        const spitAngle = Math.atan2(dy, dx);
        bullets.push({
          x: e.x + Math.cos(spitAngle) * 15,
          y: e.y + Math.sin(spitAngle) * 15,
          vx: Math.cos(spitAngle) * 300,
          vy: Math.sin(spitAngle) * 300,
          width: 4,
          color: '#ff6666',
          tracer: 20,
          life: 0,
          maxLife: 1.5,
          damage: e.dmg * 0.5,
          pierce: 0,
          knock: 50,
          fromEnemy: true
        });
        e.lastSpecial = 0;
      } else {
        // ENHANCED EVASIVE MOVEMENT PATTERNS!
        const movementType = Math.floor(Math.random() * 6); // 6 different movement patterns
        
        if (movementType === 0) {
          // Straight line movement (16% chance) - still some direct approach
          const straightFactor = 0.9 + Math.random() * 0.2; // 90-110% straightness
          moveX *= straightFactor;
          moveY *= straightFactor;
        } else if (movementType === 1) {
          // Evasive sideways movement (16% chance) - move sideways for decent chunks
          const evasiveDirection = Math.sin(e.wob * 0.8) > 0 ? 1 : -1;
          const evasiveStrength = 0.6 + Math.random() * 0.4; // 60-100% sideways movement
          moveX += evasiveDirection * evasiveStrength * speed * dt;
          moveY *= 0.7; // Reduce forward movement while evading
        } else if (movementType === 2) {
          // Strafing movement (16% chance) - move perpendicular to player
          const strafeAngle = Math.atan2(dy, dx) + Math.PI/2; // Perpendicular to player
          const strafeStrength = 0.5 + Math.random() * 0.5; // 50-100% strafe strength
          moveX += Math.cos(strafeAngle) * strafeStrength * speed * dt;
          moveY += Math.sin(strafeAngle) * strafeStrength * speed * dt;
        } else if (movementType === 3) {
          // Zigzag evasion (16% chance) - alternating left/right
          const zigzagDirection = Math.sin(e.wob * 1.2) > 0 ? 1 : -1;
          const zigzagStrength = 0.4 + Math.random() * 0.3; // 40-70% zigzag strength
          moveX += zigzagDirection * zigzagStrength * speed * dt;
          moveY *= 0.8; // Slightly reduce forward movement
        } else if (movementType === 4) {
          // Circular evasion (16% chance) - circle around while approaching
          const circleRadius = 25 + Math.random() * 15;
          const circleSpeed = 0.8 + Math.random() * 0.4;
          const circleAngle = e.wob * circleSpeed;
          moveX += Math.cos(circleAngle) * circleRadius * dt;
          moveY += Math.sin(circleAngle) * circleRadius * dt;
        } else {
          // Enhanced sway movement (20% chance) - more pronounced swaying
          const sway = Math.sin(e.wob) * (e.type === 'brute' ? 1.2 : 2.0);
          const swayY = Math.cos(e.wob) * (e.type === 'brute' ? 0.5 : 1.0);
          moveX += sway;
          moveY += swayY;
        }
        
        // Add random speed variations
        const speedVariation = 0.8 + Math.random() * 0.4; // 80-120% speed
        moveX *= speedVariation;
        moveY *= speedVariation;
      }
        
        e.x += moveX;
        e.y += moveY;
      }

      // Attack
      e.cd -= dt;
      if (dist < e.r + player.r + 2 && e.cd <= 0) {
        e.cd = 0.6;
        damagePlayer(Math.round(e.dmg));
        knockback(player, Math.atan2(dy, dx) + Math.PI, 120);
      }

      // Attack turrets
      for (const t of turrets) {
        if (t.health <= 0) continue;
        const tdx = t.x - e.x, tdy = t.y - e.y;
        const tdist = Math.hypot(tdx, tdy);
        if (tdist < e.r + t.r + 2 && e.cd <= 0) {
          e.cd = 0.6;
          t.health -= Math.round(e.dmg * 0.5);
          if (t.health <= 0) {
            particlesBurst(t.x, t.y, '#ff4949', 20, 200);
            sounds.explosion(0.3);
          }
        }
      }

      // Attack animal companions
      for (const a of allies) {
        if (a.hp <= 0) continue;
        const adx = a.x - e.x, ady = a.y - e.y;
        const adist = Math.hypot(adx, ady);
        if (adist < e.r + a.r + 2 && e.cd <= 0) {
          e.cd = 0.6;
          a.hp -= Math.round(e.dmg * 0.7);
          
          // Distress call when attacked (but not spam)
          if (!a.lastDistressCall || state.time - a.lastDistressCall > 3.0) {
            a.lastDistressCall = state.time;
            const distressPhrases = [
              `*${a.animalType.type === 'wolf' ? 'Howl' : a.animalType.type === 'eagle' ? 'Screech' : a.animalType.type === 'bear' ? 'Roar' : a.animalType.type === 'fox' ? 'Yip' : a.animalType.type === 'fennec' ? 'Yip' : 'Hoot'}* Help!`,
              `*${a.animalType.type === 'wolf' ? 'Growl' : a.animalType.type === 'eagle' ? 'Cry' : a.animalType.type === 'bear' ? 'Roar' : a.animalType.type === 'fox' ? 'Yelp' : a.animalType.type === 'fennec' ? 'Yelp' : 'Hoot'}* Under attack!`,
              `*${a.animalType.type === 'wolf' ? 'Whine' : a.animalType.type === 'eagle' ? 'Cry' : a.animalType.type === 'bear' ? 'Roar' : a.animalType.type === 'fox' ? 'Yip' : a.animalType.type === 'fennec' ? 'Yip' : 'Hoot'}* Need backup!`
            ];
            const phrase = distressPhrases[Math.floor(Math.random() * distressPhrases.length)];
            state.speechBubbles.push({
              x: a.x,
              y: a.y - 40,
              text: phrase,
              time: 0,
              life: 2.5,
              owner: a,
              color: '#ff4444'
            });
            addMessage(`${a.name} is under attack!`);
            
            // Visual feedback for companion being attacked
            particlesBurst(a.x, a.y, '#ff4444', 8, 120);
            cameraFlash(0.1);
            screenShake(0.1, 0.1);
          }
          
          if (a.hp <= 0) {
            // DRAMATIC ALLY DEATH EFFECT
            // Intense visual effects
            particlesBurst(a.x, a.y, '#ff0000', 50, 400); // Massive red burst
            particlesBurst(a.x, a.y, '#ff4444', 30, 300); // Secondary burst
            particlesBurst(a.x, a.y, '#ff8888', 20, 200); // Tertiary burst
            
            // Screen effects
            cameraFlash(0.8); // Intense flash
            screenShake(0.8, 0.6); // Heavy screen shake
            
            // Emotional message
            const deathMessages = [
              `NO! ${a.name} was killed!`,
              `${a.name} has fallen...`,
              `We lost ${a.name}!`,
              `${a.name} is gone...`,
              `Farewell, ${a.name}...`
            ];
            const deathMessage = deathMessages[Math.floor(Math.random() * deathMessages.length)];
            addMessage(deathMessage, 'death');
            
            // Dramatic sound effect
            sounds.explosion(0.8); // Loud explosion sound
            
            // Emotional speech bubble
            const emotionalMessages = [
              'NOOO!',
              'I failed...',
              'Goodbye...',
              'It hurts...',
              'Why...'
            ];
            const emotionalMessage = emotionalMessages[Math.floor(Math.random() * emotionalMessages.length)];
            state.speechBubbles.push({
              x: a.x,
              y: a.y - 40,
              text: emotionalMessage,
              time: 0,
              life: 4.0, // Longer lasting
              owner: a,
              color: '#ff0000',
              scale: 1.3
            });
            
            // Add grave to graveyard
            state.graveyard.push({
              x: a.x,
              y: a.y,
              name: a.name,
              animalType: a.animalType.type,
              time: state.time,
              color: a.animalType.color
            });
            
            // EMOTIONAL REACTIONS FROM SURVIVING ALLIES
            for (const survivor of allies) {
              if (survivor === a) continue; // Skip the dying ally
              
              // Different reactions based on animal type
              let reactionMessage = '';
              let reactionColor = '#ff0000';
              let reactionScale = 1.0;
              
              if (survivor.animalType.type === 'wolf') {
                const wolfReactions = [
                  `*Howl* ${a.name}, no!`,
                  `*Growl* We will avenge you, ${a.name}!`,
                  `*Bark* This is not over!`,
                  `*Howl* The pack mourns you!`
                ];
                reactionMessage = wolfReactions[Math.floor(Math.random() * wolfReactions.length)];
                reactionColor = '#ff4444';
              } else if (survivor.animalType.type === 'eagle') {
                const eagleReactions = [
                  `*Screech* ${a.name} has fallen!`,
                  `*Cry* We will honor your sacrifice!`,
                  `*Screech* The sky weeps for you!`,
                  `*Cry* Your spirit soars with us!`
                ];
                reactionMessage = eagleReactions[Math.floor(Math.random() * eagleReactions.length)];
                reactionColor = '#ffaa00';
              } else if (survivor.animalType.type === 'bear') {
                const bearReactions = [
                  `*Roar* NO! ${a.name}!`,
                  `*Growl* We will crush them for you!`,
                  `*Roar* Your strength lives in us!`,
                  `*Growl* They will pay for this!`
                ];
                reactionMessage = bearReactions[Math.floor(Math.random() * bearReactions.length)];
                reactionColor = '#ff6600';
              } else if (survivor.animalType.type === 'fennec') {
                const fennecReactions = [
                  `*Yip* ${a.name}, don't leave us!`,
                  `*Bark* We'll make them pay!`,
                  `*Yip* Your memory gives us strength!`,
                  `*Bark* We'll fight harder for you!`
                ];
                reactionMessage = fennecReactions[Math.floor(Math.random() * fennecReactions.length)];
                reactionColor = '#ffaa44';
              } else if (survivor.animalType.type === 'fox') {
                const foxReactions = [
                  `*Yip* ${a.name}, stay with us!`,
                  `*Bark* We'll outsmart them for you!`,
                  `*Yip* Your cunning inspires us!`,
                  `*Bark* We'll make them regret this!`
                ];
                reactionMessage = foxReactions[Math.floor(Math.random() * foxReactions.length)];
                reactionColor = '#ff8844';
              } else if (survivor.animalType.type === 'owl') {
                const owlReactions = [
                  `*Hoot* ${a.name}, rest in wisdom!`,
                  `*Hoot* We will remember your knowledge!`,
                  `*Hoot* Your wisdom guides us still!`,
                  `*Hoot* We'll fight with your insight!`
                ];
                reactionMessage = owlReactions[Math.floor(Math.random() * owlReactions.length)];
                reactionColor = '#ffaa88';
              } else if (survivor.animalType.type === 'dog') {
                const dogReactions = [
                  `*Woof* ${a.name}, my loyal friend!`,
                  `*Bark* I'll protect them for you!`,
                  `*Woof* Your loyalty inspires us!`,
                  `*Bark* I'll guard them in your memory!`
                ];
                reactionMessage = dogReactions[Math.floor(Math.random() * dogReactions.length)];
                reactionColor = '#8b7355';
              } else if (survivor.animalType.type === 'dolphin') {
                const dolphinReactions = [
                  `*Click* ${a.name}, I couldn't save you!`,
                  `*Whistle* I'll heal the others in your memory!`,
                  `*Click* Your sacrifice won't be in vain!`,
                  `*Whistle* I'll protect them for you!`
                ];
                reactionMessage = dolphinReactions[Math.floor(Math.random() * dolphinReactions.length)];
                reactionColor = '#00aaff';
              }
              
              // Add emotional reaction speech bubble
              state.speechBubbles.push({
                x: survivor.x,
                y: survivor.y - 40,
                text: reactionMessage,
                time: 0,
                life: 4.0, // Longer lasting for emotional impact
                owner: survivor,
                color: reactionColor,
                scale: reactionScale
              });
              
              // Visual effect for emotional reaction
              particlesBurst(survivor.x, survivor.y, reactionColor, 6, 120);
            }
            
            // Remove the ally
            allies.splice(allies.indexOf(a), 1);
          }
        }
      }

      // Check barricade collision and attack
      for (let j = barricades.length - 1; j >= 0; j--) {
        const b = barricades[j];
        
        // Simple distance-based collision for barricades
        const bdx = b.x - e.x, bdy = b.y - e.y;
        const bdist = Math.hypot(bdx, bdy);
        const collisionRadius = Math.max(b.width/2, b.height/2) + e.r;
        
        if (bdist < collisionRadius) {
          // Calculate the direction the enemy was approaching from
          const approachAngle = Math.atan2(e.y - b.y, e.x - b.x);
          
          // Push them back in the direction they came from
          const pushDistance = collisionRadius - bdist + 25; // Slightly more push
          e.x += Math.cos(approachAngle) * pushDistance;
          e.y += Math.sin(approachAngle) * pushDistance;
          
          // Immobilize for shorter time but push back further
          e.stun = Math.max(e.stun, 0.3); // Reduced from 0.6
          
          // Add much stronger knockback in the approach direction
          const knockbackPower = 300; // Reduced knockback
          e.x += Math.cos(approachAngle) * knockbackPower * 0.15; // Reduced from 0.3
          e.y += Math.sin(approachAngle) * knockbackPower * 0.15; // Reduced from 0.3
          
          // Enhanced visual effects
          particlesBurst(e.x, e.y, '#8b4513', 8, 120);
          particlesBurst(b.x, b.y, '#ffaa00', 4, 80); // Barricade impact particles
          
          // Attack barricade with damage based on enemy type
          if (e.cd <= 0) {
            e.cd = 0.6;
            const damage = e.type === 'boss' ? 25 : e.type === 'brute' ? 4 : 2; // Bosses do massive damage to barricades
            b.health -= damage;
            if (b.health <= 0) {
              particlesBurst(b.x, b.y, '#8b4513', 15, 200);
              sounds.explosion(0.3);
              barricades.splice(j, 1);
            }
          }
        }
      }

      // Check spike collision
      for (let j = spikes.length - 1; j >= 0; j--) {
        const s = spikes[j];
        if (s.health <= 0) continue;
        
        const sdx = s.x - e.x, sdy = s.y - e.y;
        const sdist = Math.hypot(sdx, sdy);
        
        if (sdist < s.r + e.r) {
          // Damage and slow enemy
          e.hp -= s.damage;
          e.speed *= s.slowFactor;
          e.stun = s.slowDuration;
          
          // Push enemy back from vine
          const pushAngle = Math.atan2(e.y - s.y, e.x - s.x);
          const pushDistance = 30;
          e.x += Math.cos(pushAngle) * pushDistance;
          e.y += Math.sin(pushAngle) * pushDistance;
          
          // Damage vine with cooldown
          if (!s.lastHit || state.time - s.lastHit > 0.5) {
            s.health -= 8;
            s.lastHit = state.time;
          }
          
          if (s.health <= 0) {
            particlesBurst(s.x, s.y, '#00aa00', 15, 180);
            sounds.hit(0.2);
            spikes.splice(j, 1);
          }
          
          // Enhanced hit effect
          particlesHit(e.x, e.y, '#00aa00');
          particlesBurst(e.x, e.y, '#00ff00', 6, 100);
          sounds.hit(0.3);
          
          // Check if enemy died
          if (e.hp <= 0) {
            // Use hitEnemy to properly handle player vs non-player kills
            hitEnemy(e, 0, 0, 0, 0, 0, false); // false = not from player
            break;
          }
        }
      }

      // Check mine collision
      for (let j = mines.length - 1; j >= 0; j--) {
        const m = mines[j];
        if (m.triggered) continue;
        
        const mdx = m.x - e.x, mdy = m.y - e.y;
        const mdist = Math.hypot(mdx, mdy);
        
        if (mdist < m.triggerRadius + e.r) {
          // Trigger mine explosion with enhanced effects
          explosion(m.x, m.y, m.explosionRadius, m.damage, '#ffaa00', 0.7);
          cameraFlash(0.2);
          sounds.explosion(0.5);
          
          // Knockback all nearby enemies (except bosses)
          for (const otherEnemy of enemies) {
            if (otherEnemy.type === 'boss') continue; // Bosses are immune to knockback
            
            const dx = otherEnemy.x - m.x, dy = otherEnemy.y - m.y;
            const dist = Math.hypot(dx, dy);
            if (dist < m.explosionRadius) {
              const knockback = 400 * (1 - dist / m.explosionRadius);
              const angle = Math.atan2(dy, dx);
              otherEnemy.x += Math.cos(angle) * knockback * 0.15; // Reduced from 0.3
              otherEnemy.y += Math.sin(angle) * knockback * 0.15; // Reduced from 0.3
              otherEnemy.stun = Math.max(otherEnemy.stun, 0.3); // Reduced from 0.5
            }
          }
          
          mines.splice(j, 1);
        }
      }

      // Healing platforms
      for (let j = healingPlatforms.length - 1; j >= 0; j--) {
        const h = healingPlatforms[j];
        
        // Update platform time and check if expired
        h.time += dt;
        if (h.time >= h.duration) {
          particlesBurst(h.x, h.y, '#00ff88', 20, 300);
          sounds.pickup();
          healingPlatforms.splice(j, 1);
          continue;
        }
        
        // Heal companions in range and attract them
        for (const a of allies) {
          const hdx = h.x - a.x, hdy = h.y - a.y;
          const hdist = Math.hypot(hdx, hdy);
          
          if (hdist < h.r) {
            // Heal companion if not at full health
            if (a.hp < a.maxHp) {
              const healAmount = Math.min(h.healRate * dt, a.maxHp - a.hp);
              a.hp += healAmount;
              
              // Visual healing effect
              if (Math.random() < 0.3) { // 30% chance per frame
                particlesBurst(a.x, a.y, '#00ff88', 3, 80);
              }
              
              // Healing speech bubble occasionally
              if (Math.random() < 0.01) { // 1% chance per frame
                const healingPhrases = ['*Purr* So healing!', '*Sigh* This feels good!', '*Relax* Much better!', '*Content* Ah, relief!'];
                const phrase = healingPhrases[Math.floor(Math.random() * healingPhrases.length)];
                state.speechBubbles.push({
                  x: a.x,
                  y: a.y - 40,
                  text: phrase,
                  time: 0,
                  life: 2.0,
                  owner: a,
                  color: '#00ff88'
                });
              }
            }
            
            // Healing platform attraction is now handled in companion movement logic
          }
        }
      }

      // Remove if far outside (failsafe)
      if (e.x < -200 || e.x > state.w + 200 || e.y < -200 || e.y > state.h + 200) {
        enemies.splice(i, 1);
      }
    }

    // Turrets
    for (const t of turrets) {
      if (t.health <= 0) continue;
      
      // Find closest enemy
      let closest = null;
      let closestDist = t.range;
      
      for (const e of enemies) {
        const dx = e.x - t.x, dy = e.y - t.y;
        const dist = Math.hypot(dx, dy);
        if (dist < closestDist) {
          closest = e;
          closestDist = dist;
        }
      }
      
      t.target = closest;
      
      if (closest) {
        // Aim at target
        t.angle = Math.atan2(closest.y - t.y, closest.x - t.x);
        
        // Fire
        t.fireT -= dt;
        if (t.fireT <= 0) {
          t.fireT = t.fireDelay;
          
          // Create turret bullet
          const ang = t.angle;
          const vx = Math.cos(ang) * t.speed;
          const vy = Math.sin(ang) * t.speed;
          
          // Handle different turret types
          if (t.type === 3) { // Shotgun turret
            // Fire multiple pellets
            for (let pellet = 0; pellet < (t.pellets || 5); pellet++) {
              const spread = rand(-0.3, 0.3);
              const pelletAng = ang + spread;
              const pelletVx = Math.cos(pelletAng) * t.speed;
              const pelletVy = Math.sin(pelletAng) * t.speed;
              
              bullets.push({
                x: t.x + Math.cos(pelletAng) * 25,
                y: t.y + Math.sin(pelletAng) * 25,
                vx: pelletVx, vy: pelletVy,
                width: 2,
                color: t.color,
                tracer: 25,
                life: 0,
                maxLife: 1.2,
                damage: t.damage * 0.6,
                pierce: 0,
                knock: 60,
                fromTurret: true
              });
            }
          } else if (t.type === 4) { // Flamethrower turret
            bullets.push({
              x: t.x + Math.cos(ang) * 25,
              y: t.y + Math.sin(ang) * 25,
              vx, vy,
              width: 4,
              color: t.color,
              tracer: 20,
              life: 0,
              maxLife: 1.0,
              damage: t.damage,
              pierce: 0,
              knock: 40,
              fromTurret: true,
              flamethrower: true,
              burnDamage: t.burnDamage || 8,
              burnDuration: t.burnDuration || 3
            });
          } else { // Regular turret
            bullets.push({
              x: t.x + Math.cos(ang) * 25,
              y: t.y + Math.sin(ang) * 25,
              vx, vy,
              width: 3,
              color: t.color,
              tracer: 35,
              life: 0,
              maxLife: 1.5,
              damage: t.damage,
              pierce: 0,
              knock: 80,
              fromTurret: true
            });
          }
          
          // Turret firing effects
          particlesBurst(t.x + Math.cos(ang) * 25, t.y + Math.sin(ang) * 25, t.color, 6, 120);
          sounds.gunshot(0.2);
        }
      }
    }

    // Allies
    for (const a of allies) {
      if (a.hp <= 0) continue;
      
      // Find closest enemy
      let closest = null;
      let closestDist = 200;
      
      for (const e of enemies) {
        const dx = e.x - a.x, dy = e.y - a.y;
        const dist = Math.hypot(dx, dy);
        if (dist < closestDist) {
          closest = e;
          closestDist = dist;
        }
      }
      
      a.target = closest;
      
      if (closest) {
        // Aim at target
        a.angle = Math.atan2(closest.y - a.y, closest.x - a.x);
        
        // Health regeneration for allies
        if (a.hp < a.maxHp && Math.random() < 0.01) {
          a.hp = Math.min(a.maxHp, a.hp + 1);
        }
        
        // Personality-based behavior with improved AI
        let moveSpeed = a.speed;
        let fireDelay = a.fireDelay;
        
        if (a.personality === 'aggressive') {
          moveSpeed *= 1.3;
          fireDelay *= 0.7;
          // Aggressive allies charge towards enemies
          if (closest) {
            const dx = closest.x - a.x, dy = closest.y - a.y;
            const dist = Math.hypot(dx, dy);
            if (dist > 50) {
              a.x += (dx / dist) * moveSpeed * dt;
              a.y += (dy / dist) * moveSpeed * dt;
            }
          }
        } else if (a.personality === 'steady') {
          moveSpeed *= 0.9;
          fireDelay *= 1.1;
          // Steady allies maintain medium distance
          if (closest) {
            const dx = closest.x - a.x, dy = closest.y - a.y;
            const dist = Math.hypot(dx, dy);
            if (dist < 80) {
              a.x -= (dx / dist) * moveSpeed * dt * 0.5;
              a.y -= (dy / dist) * moveSpeed * dt * 0.5;
            } else if (dist > 120) {
              a.x += (dx / dist) * moveSpeed * dt * 0.5;
              a.y += (dy / dist) * moveSpeed * dt * 0.5;
            }
          }
        } else if (a.personality === 'precise') {
          fireDelay *= 1.4;
          // Sniper stays back more and takes careful shots
          if (closest) {
            const dx = closest.x - a.x, dy = closest.y - a.y;
            const dist = Math.hypot(dx, dy);
            if (dist < 120) {
              a.x -= (dx / dist) * moveSpeed * dt;
              a.y -= (dy / dist) * moveSpeed * dt;
            }
          }
        } else if (a.personality === 'supportive') {
          // Medic stays closer to player and heals player occasionally
          const dx = player.x - a.x, dy = player.y - a.y;
          const dist = Math.hypot(dx, dy);
          if (dist > 80) {
            a.x += (dx / dist) * moveSpeed * dt;
            a.y += (dy / dist) * moveSpeed * dt;
          }
          
          // Heal player occasionally
          if (dist < 100 && player.hp < player.hpMax && Math.random() < 0.005) {
            player.hp = Math.min(player.hpMax, player.hp + 5);
            particlesBurst(player.x, player.y, '#27d07e', 6, 100);
            addMessage(`${a.name} healed you!`);
            
            // Add healing speech bubble with personality-specific messages
            let healingMessage = '';
            if (a.animalType.type === 'wolf') {
              const wolfHealing = ['*Growl* You\'re healed, pack leader!', '*Howl* Feel the pack\'s strength!', '*Bark* Restored by the pack!'];
              healingMessage = wolfHealing[Math.floor(Math.random() * wolfHealing.length)];
            } else if (a.animalType.type === 'eagle') {
              const eagleHealing = ['*Screech* Healed from above!', '*Cry* The sky restores you!', '*Screech* Soaring health!'];
              healingMessage = eagleHealing[Math.floor(Math.random() * eagleHealing.length)];
            } else if (a.animalType.type === 'bear') {
              const bearHealing = ['*Roar* My strength heals you!', '*Growl* Bear medicine!', '*Roar* Unbreakable health!'];
              healingMessage = bearHealing[Math.floor(Math.random() * bearHealing.length)];
            } else if (a.animalType.type === 'fennec') {
              const fennecHealing = ['*Yip* My ears sense your healing!', '*Bark* Big ears, big healing!', '*Yip* Cute and restorative!'];
              healingMessage = fennecHealing[Math.floor(Math.random() * fennecHealing.length)];
            } else if (a.animalType.type === 'fox') {
              const foxHealing = ['*Yip* Clever healing!', '*Bark* Smart medicine!', '*Yip* Wits restore health!'];
              healingMessage = foxHealing[Math.floor(Math.random() * foxHealing.length)];
            } else if (a.animalType.type === 'owl') {
              const owlHealing = ['*Hoot* Wisdom heals!', '*Hoot* Knowledge restores!', '*Hoot* Wise medicine!'];
              healingMessage = owlHealing[Math.floor(Math.random() * owlHealing.length)];
            } else if (a.animalType.type === 'dolphin') {
              const dolphinHealing = ['*Click* Medic on the way!', '*Whistle* I\'ll patch you up!', '*Click* Healing touch!'];
              healingMessage = dolphinHealing[Math.floor(Math.random() * dolphinHealing.length)];
            }
            
            state.speechBubbles.push({
              x: a.x,
              y: a.y - 40,
              text: healingMessage,
              time: 0,
              life: 2.5,
              owner: a
            });
          }
          
          // Random motivational speech and personality comments
          if (Math.random() < 0.002) {
            const motivationalMessage = a.animalType.motivational[Math.floor(Math.random() * a.animalType.motivational.length)];
            state.speechBubbles.push({
              x: a.x,
              y: a.y - 40,
              text: motivationalMessage,
              time: 0,
              life: 2.5,
              owner: a
            });
          }
          
          // Personality-specific random comments
          if (Math.random() < 0.001) {
            let personalityComment = '';
            if (a.animalType.type === 'wolf') {
              const wolfComments = ['*Sniff* I smell victory!', '*Growl* The pack grows stronger!', '*Howl* We hunt as one!'];
              personalityComment = wolfComments[Math.floor(Math.random() * wolfComments.length)];
            } else if (a.animalType.type === 'eagle') {
              const eagleComments = ['*Screech* I see them all!', '*Cry* The sky is clear!', '*Screech* My vision is perfect!'];
              personalityComment = eagleComments[Math.floor(Math.random() * eagleComments.length)];
            } else if (a.animalType.type === 'bear') {
              const bearComments = ['*Growl* I am unbreakable!', '*Roar* My strength is unmatched!', '*Growl* Nothing can stop me!'];
              personalityComment = bearComments[Math.floor(Math.random() * bearComments.length)];
            } else if (a.animalType.type === 'fennec') {
              const fennecComments = ['*Yip* My ears are tingling!', '*Bark* I hear everything!', '*Yip* My big ears never lie!'];
              personalityComment = fennecComments[Math.floor(Math.random() * fennecComments.length)];
            } else if (a.animalType.type === 'fox') {
              const foxComments = ['*Yip* I\'m too clever for them!', '*Bark* They can\'t catch me!', '*Yip* My wits are sharp!'];
              personalityComment = foxComments[Math.floor(Math.random() * foxComments.length)];
            } else if (a.animalType.type === 'owl') {
              const owlComments = ['*Hoot* My wisdom guides us!', '*Hoot* I see through deception!', '*Hoot* Knowledge is my weapon!'];
              personalityComment = owlComments[Math.floor(Math.random() * owlComments.length)];
            } else if (a.animalType.type === 'dog') {
              const dogComments = ['*Woof* I\'ll protect you, master!', '*Bark* I\'m watching your back!', '*Woof* You\'re safe with me!', '*Bark* I\'ll defend you!'];
              personalityComment = dogComments[Math.floor(Math.random() * dogComments.length)];
            } else if (a.animalType.type === 'dolphin') {
              const dolphinComments = ['*Click* I sense injuries nearby!', '*Whistle* My healing instincts are strong!', '*Click* I\'m here to help!'];
              personalityComment = dolphinComments[Math.floor(Math.random() * dolphinComments.length)];
            }
            
            if (personalityComment) {
              state.speechBubbles.push({
                x: a.x,
                y: a.y - 40,
                text: personalityComment,
                time: 0,
                life: 2.5,
                owner: a
              });
            }
          }
          
          // Combat comments
          if (Math.random() < 0.001) {
            const combatPhrases = [
              'Take that!', 'Gotcha!', 'Nice shot!', 'Keep it up!', 'We\'re winning!',
              'Boom!', 'Perfect!', 'Excellent!', 'Amazing!', 'Fantastic!',
              'That\'s the way!', 'Keep going!', 'We\'ve got this!', 'Unstoppable!', 'Incredible!',
              'Outstanding!', 'Brilliant!', 'Superb!', 'Magnificent!', 'Spectacular!'
            ];
            const phrase = combatPhrases[Math.floor(Math.random() * combatPhrases.length)];
            state.speechBubbles.push({
              x: a.x,
              y: a.y - 40,
              text: phrase,
              time: 0,
              life: 2.0,
              owner: a
            });
          }
        }
        
                // COMPLETE REWRITE: Priority-based movement system
        let targetX = closest.x, targetY = closest.y;
        let isHealing = false;
        
        // DOG LOYAL PROTECTOR LOGIC - Follows and protects the player
        if (a.animalType.type === 'dog') {
          // Dog follows player at a close distance and protects them
          const followDistance = 40; // Close following distance
          const protectDistance = 80; // Protection range
          
          // Find closest enemy to player
          let closestEnemyToPlayer = null;
          let closestEnemyDist = protectDistance;
          
          for (const e of enemies) {
            const dx = e.x - player.x, dy = e.y - player.y;
            const dist = Math.hypot(dx, dy);
            if (dist < closestEnemyDist) {
              closestEnemyToPlayer = e;
              closestEnemyDist = dist;
            }
          }
          
          // Dog behavior: follow player closely, attack enemies near player
          if (closestEnemyToPlayer && closestEnemyDist < protectDistance) {
            // Protect player by attacking nearby enemies
            targetX = closestEnemyToPlayer.x;
            targetY = closestEnemyToPlayer.y;
            
            // Dog combat comments
            if (Math.random() < 0.002) {
              const protectPhrases = ['*Growl* Get away from my master!', '*Bark* I\'ll protect you!', '*Woof* Back off!', '*Growl* You won\'t touch him!'];
              const phrase = protectPhrases[Math.floor(Math.random() * protectPhrases.length)];
              state.speechBubbles.push({
                x: a.x,
                y: a.y - 40,
                text: phrase,
                time: 0,
                life: 2.5,
                owner: a
              });
            }
          } else {
            // Follow player at close distance
            const dx = player.x - a.x, dy = player.y - a.y;
            const distToPlayer = Math.hypot(dx, dy);
            
            if (distToPlayer > followDistance) {
              // Move towards player
              targetX = player.x + Math.cos(a.angle) * followDistance;
              targetY = player.y + Math.sin(a.angle) * followDistance;
            } else {
              // Stay close to player, circle around them
              const angle = a.angle + dt * 0.5; // Slow circling
              targetX = player.x + Math.cos(angle) * followDistance;
              targetY = player.y + Math.sin(angle) * followDistance;
            }
            
            // Dog following comments
            if (Math.random() < 0.001) {
              const followPhrases = ['*Woof* Right behind you!', '*Bark* I\'m here, master!', '*Woof* Watching your back!', '*Bark* Ready to protect!'];
              const phrase = followPhrases[Math.floor(Math.random() * followPhrases.length)];
              state.speechBubbles.push({
                x: a.x,
                y: a.y - 40,
                text: phrase,
                time: 0,
                life: 2.0,
                owner: a
              });
            }
          }
        }
        // DOLPHIN MEDIC LOGIC - Enhanced healing behavior with avoidance
        else if (a.animalType.type === 'dolphin') {
          let needsHealing = false;
          let healingTarget = null;
          let revivalTarget = null; // Initialize revivalTarget variable
          
          // Look for injured companions (including self)
          for (const otherAlly of allies) {
            if (otherAlly.hp < otherAlly.maxHp * 0.7) { // 70% health threshold
              const allyDist = Math.hypot(otherAlly.x - a.x, otherAlly.y - a.y);
              if (allyDist < 150) { // Increased healing range
                needsHealing = true;
                healingTarget = otherAlly;
                
                // Move to injured companion
                targetX = otherAlly.x;
                targetY = otherAlly.y;
                isHealing = true;
                
                // Visual feedback for medic dolphin
                if (Math.random() < 0.3) { // 30% chance per frame
                  particlesBurst(a.x, a.y, '#00aaff', 6, 120);
                }
                
                // Heal the companion when close enough
                if (allyDist < 25 && !a.healCooldown) {
                  const healAmount = otherAlly === a ? 40 : 50; // Self-heal less, others more
                  otherAlly.hp = Math.min(otherAlly.maxHp, otherAlly.hp + healAmount);
                  a.healCooldown = 8; // 8 second cooldown
                  
                  // Enhanced healing effect
                  particlesBurst(otherAlly.x, otherAlly.y, '#00ff88', 20, 250);
                  cameraFlash(0.15);
                  
                  // Medic speech bubble
                  const healMessages = ['Healing!', 'Medic!', 'Restored!', 'Fixed!'];
                  const healMessage = healMessages[Math.floor(Math.random() * healMessages.length)];
                  state.speechBubbles.push({
                    x: a.x,
                    y: a.y - 30,
                    text: healMessage,
                    time: 0,
                    life: 2.0,
                    owner: a,
                    color: '#00ff88',
                    scale: 1.0
                  });
                  
                  // Healed companion speech bubble (if not self-healing)
                  if (otherAlly !== a) {
                    const thanksMessages = ['Thanks!', 'Better!', 'Healed!', 'Thanks medic!'];
                    const thanksMessage = thanksMessages[Math.floor(Math.random() * thanksMessages.length)];
                    state.speechBubbles.push({
                      x: otherAlly.x,
                      y: otherAlly.y - 30,
                      text: thanksMessage,
                      time: 0,
                      life: 2.0,
                      owner: otherAlly,
                      color: '#00ff88',
                      scale: 0.8
                    });
                  }
                }
                break; // Found injured companion, stop searching
              }
            }
          }
          
          // DOLPHIN REVIVAL LOGIC - Check for graves to revive fallen allies
          if (!needsHealing && allies.length < 3) { // Only revive if under max allies
            let revivalTarget = null;
            let closestGrave = Infinity;
            
            // Look for graves to revive fallen allies
            for (const grave of state.graveyard) {
              const graveDist = Math.hypot(grave.x - a.x, grave.y - a.y);
              if (graveDist < 120 && graveDist < closestGrave) { // Revival range
                revivalTarget = grave;
                closestGrave = graveDist;
              }
            }
            
            if (revivalTarget) {
              // Move to grave for revival
              targetX = revivalTarget.x;
              targetY = revivalTarget.y;
              
              // Visual feedback for revival attempt
              if (Math.random() < 0.4) { // 40% chance per frame
                particlesBurst(a.x, a.y, '#00ffff', 8, 150);
              }
              
              // Revive the ally when close enough
              if (closestGrave < 30 && !a.reviveCooldown) {
                // Find the animal type for revival
                const animalType = animalCompanions.find(animal => animal.type === revivalTarget.animalType);
                if (animalType) {
                  // Create the revived ally
                  const revivedAlly = {
                    x: revivalTarget.x,
                    y: revivalTarget.y,
                    r: 16,
                    speed: 80 + rand(0, 20),
                    hp: animalType.type === 'dolphin' ? 200 : 80,
                    maxHp: animalType.type === 'dolphin' ? 200 : 80,
                    fireT: 0,
                    fireDelay: 0.4,
                    damage: 15,
                    angle: 0,
                    target: null,
                    type: 'animal',
                    name: revivalTarget.name,
                    animalType: animalType,
                    personality: animalType.personality
                  };
                  
                  allies.push(revivedAlly);
                  
                  // Remove the grave
                  const graveIndex = state.graveyard.indexOf(revivalTarget);
                  if (graveIndex > -1) {
                    state.graveyard.splice(graveIndex, 1);
                  }
                  
                  // Dramatic revival effects
                  particlesBurst(revivalTarget.x, revivalTarget.y, '#00ffff', 40, 300);
                  particlesBurst(revivalTarget.x, revivalTarget.y, '#ffffff', 20, 200);
                  cameraFlash(0.6);
                  screenShake(0.4, 0.3);
                  
                  // Revival speech bubbles
                  const revivalMessages = ['REVIVED!', 'BACK TO LIFE!', 'RESURRECTED!', 'RETURNED!'];
                  const revivalMessage = revivalMessages[Math.floor(Math.random() * revivalMessages.length)];
                  state.speechBubbles.push({
                    x: a.x,
                    y: a.y - 40,
                    text: revivalMessage,
                    time: 0,
                    life: 3.0,
                    owner: a,
                    color: '#00ffff',
                    scale: 1.4
                  });
                  
                  // Revived ally speech bubble
                  const returnMessages = ['I\'m back!', 'Thank you!', 'Alive again!', 'Reunited!'];
                  const returnMessage = returnMessages[Math.floor(Math.random() * returnMessages.length)];
                  state.speechBubbles.push({
                    x: revivedAlly.x,
                    y: revivedAlly.y - 40,
                    text: returnMessage,
                    time: 0,
                    life: 3.0,
                    owner: revivedAlly,
                    color: '#00ffff',
                    scale: 1.2
                  });
                  
                  // Revival message
                  addMessage(`${revivalTarget.name} has been revived!`, 'heal');
                  sounds.explosion(0.6);
                  
                  // Set cooldown for revival
                  a.reviveCooldown = 15; // 15 second cooldown
                }
              }
            }
          }
          
          // TACTICAL RETREAT - Allies fall back to player when low health
          if (a.hp < a.maxHp * 0.3) { // 30% health threshold
            const playerDist = Math.hypot(player.x - a.x, player.y - a.y);
            if (playerDist > 50) {
              // Move towards player for safety
              targetX = player.x;
              targetY = player.y;
              
              // Retreat speech bubble
              if (Math.random() < 0.01) {
                const retreatMessages = ['Need backup!', 'Falling back!', 'Help!', 'Retreating!'];
                const retreatMessage = retreatMessages[Math.floor(Math.random() * retreatMessages.length)];
                state.speechBubbles.push({
                  x: a.x,
                  y: a.y - 30,
                  text: retreatMessage,
                  time: 0,
                  life: 2.0,
                  owner: a,
                  color: '#ff4444',
                  scale: 0.9
                });
              }
            }
          } else if (!needsHealing && !revivalTarget && closest) {
            const enemyDist = Math.hypot(closest.x - a.x, closest.y - a.y);
            if (enemyDist < 120) { // Keep distance from enemies
              // Move away from enemies
              const awayX = a.x - (closest.x - a.x);
              const awayY = a.y - (closest.y - a.y);
              const awayDist = Math.hypot(awayX - a.x, awayY - a.y);
              if (awayDist > 0) {
                a.x += ((awayX - a.x) / awayDist) * moveSpeed * dt * 1.5; // Faster retreat
                a.y += ((awayY - a.y) / awayDist) * moveSpeed * dt * 1.5;
              }
              
              // Avoidance speech bubble
              if (Math.random() < 0.01) {
                const avoidMessages = ['*Click* Staying safe!', '*Whistle* Avoiding danger!', '*Click* Medic staying back!'];
                const avoidMessage = avoidMessages[Math.floor(Math.random() * avoidMessages.length)];
                state.speechBubbles.push({
                  x: a.x,
                  y: a.y - 30,
                  text: avoidMessage,
                  time: 0,
                  life: 2.0,
                  owner: a,
                  color: '#ffaa00',
                  scale: 0.8
                });
              }
            }
          }
        }
        
        // GLOBAL HEALING ATTRACTION: All companions are attracted to healing platforms
        for (const h of healingPlatforms) {
          // PRIORITY OVERRIDE: Move to healing platform instead of enemy
          targetX = h.x;
          targetY = h.y;
          isHealing = true;
          
          // Visual feedback for healing attraction
          if (Math.random() < 0.15) { // 15% chance per frame
            particlesBurst(a.x, a.y, '#00ff88', 3, 80);
          }
          
          // Debug: Add speech bubble when attracted to healing
          if (Math.random() < 0.02) { // 2% chance per frame
            state.speechBubbles.push({
              x: a.x,
              y: a.y - 30,
              text: "Healing beacon!",
              time: 0,
              life: 1.5,
              owner: a,
              color: '#00ff88',
              scale: 0.8
            });
          }
          
          // Debug logging
          console.log(`Companion ${a.name} attracted to healing platform at (${h.x}, ${h.y})`);
          break; // Found healing platform, stop searching
        }
        
        // Move towards target (either enemy or healing platform)
        const dx = targetX - a.x, dy = targetY - a.y;
        const dist = Math.hypot(dx, dy);
        if (dist > (isHealing ? 15 : 50)) { // Closer to healing platform
          a.x += (dx / dist) * moveSpeed * dt;
          a.y += (dy / dist) * moveSpeed * dt;
        }
        

        
        // Update heal cooldown for medic dolphin
        if (a.healCooldown > 0) {
          a.healCooldown -= dt;
        }
        
        // Update revive cooldown for medic dolphin
        if (a.reviveCooldown > 0) {
          a.reviveCooldown -= dt;
        }
        
        // Fire
        a.fireT -= dt;
        if (a.fireT <= 0) {
          // Dolphin fires less frequently when not healing
          const dolphinFireDelay = a.animalType.type === 'dolphin' ? fireDelay * 2.5 : fireDelay;
          a.fireT = dolphinFireDelay;
          
          // Create ally bullet with type-specific properties
          const ang = a.angle;
          let bulletSpeed = 600;
          let bulletDamage = a.damage;
          let bulletColor = a.animalType.color;
          
          if (a.animalType.type === 'eagle') {
            bulletSpeed = 1000;
            bulletDamage = 25;
          } else if (a.animalType.type === 'bear') {
            bulletSpeed = 500;
            bulletDamage = 20;
          } else if (a.animalType.type === 'dolphin') {
            // Dolphin has weaker attacks but can still defend itself
            bulletSpeed = 400;
            bulletDamage = 8;
            bulletColor = '#4a90e2';
          }
          
          bullets.push({
            x: a.x + Math.cos(ang) * 20,
            y: a.y + Math.sin(ang) * 20,
            vx: Math.cos(ang) * bulletSpeed,
            vy: Math.sin(ang) * bulletSpeed,
            width: 2,
            color: bulletColor,
            tracer: 25,
            life: 0,
            maxLife: 1.2,
            damage: bulletDamage,
            pierce: 0,
            knock: 60,
            fromAlly: true
          });
          
          // Ally firing effects
          particlesBurst(a.x + Math.cos(ang) * 20, a.y + Math.sin(ang) * 20, bulletColor, 4, 80);
          sounds.gunshot(0.15);
        }
      }
    }

    // Bullets
    for (let i = bullets.length - 1; i >= 0; i--) {
      const b = bullets[i];
      
      if (b.grenade) {
        // Grenade moves towards target
        const dx = b.targetX - b.x;
        const dy = b.targetY - b.y;
        const dist = Math.hypot(dx, dy);
        if (dist > 5) {
          b.x += (dx / dist) * b.speed * dt;
          b.y += (dy / dist) * b.speed * dt;
        }
      } else {
        b.x += b.vx * dt;
        b.y += b.vy * dt;
      }
      b.life += dt;

      // Rockets: leave smoke
      if (b.splash) {
        if (Math.random() < 0.6) particles.push({ x: b.x, y: b.y, r: 2 + Math.random()*2, color: 'rgba(255,220,180,0.35)', t: 0, life: 0.4, vx: -b.vx*0.02 + rand(-10,10), vy: -b.vy*0.02 + rand(-10,10) });
      }

      // Hit enemies
      for (let j = enemies.length - 1; j >= 0; j--) {
        const e = enemies[j];
        const dx = e.x - b.x, dy = e.y - b.y;
        if (dx*dx + dy*dy <= (e.r + Math.max(2, b.width))**2) {
          // Splash
          if (b.splash) {
            explosion(b.x, b.y, b.splash, b.damage, b.color, b.splashFall);
            sounds.explosion();
          } else {
            // Check if this is a flamethrower bullet
            const isFlamethrower = b.flamethrower || b.burnDamage;
            const isPlayerBullet = !b.fromTurret;
            hitEnemy(e, b.damage, b.knock, Math.atan2(dy, dx), 
                    isFlamethrower ? (b.burnDamage || 5) : 0, 
                    isFlamethrower ? (b.burnDuration || 2) : 0,
                    isPlayerBullet);
            particlesHit(b.x, b.y, b.color);
            sounds.hit();
            b.pierce--;
          }
          if (b.pierce < 0) { bullets.splice(i,1); break; }
        }
      }

      // Hit allies (enemy bullets)
      if (b.fromEnemy) {
        for (let j = allies.length - 1; j >= 0; j--) {
          const a = allies[j];
          const dx = a.x - b.x, dy = a.y - b.y;
          if (dx*dx + dy*dy <= (a.r + Math.max(2, b.width))**2) {
            a.hp -= b.damage;
            particlesHit(b.x, b.y, b.color);
            sounds.hit();
            if (a.hp <= 0) {
              // DRAMATIC ALLY DEATH EFFECT
              // Intense visual effects
              particlesBurst(a.x, a.y, '#ff0000', 50, 400); // Massive red burst
              particlesBurst(a.x, a.y, '#ff4444', 30, 300); // Secondary burst
              particlesBurst(a.x, a.y, '#ff8888', 20, 200); // Tertiary burst
              
              // Screen effects
              cameraFlash(0.8); // Intense flash
              screenShake(0.8, 0.6); // Heavy screen shake
              
              // Emotional message
              const deathMessages = [
                `NO! ${a.name} was killed!`,
                `${a.name} has fallen...`,
                `We lost ${a.name}!`,
                `${a.name} is gone...`,
                `Farewell, ${a.name}...`
              ];
              const deathMessage = deathMessages[Math.floor(Math.random() * deathMessages.length)];
              addMessage(deathMessage, 'death');
              
              // Dramatic sound effect
              sounds.explosion(0.8); // Loud explosion sound
              
              // Emotional speech bubble
              const emotionalMessages = [
                'NOOO!',
                'I failed...',
                'Goodbye...',
                'It hurts...',
                'Why...'
              ];
              const emotionalMessage = emotionalMessages[Math.floor(Math.random() * emotionalMessages.length)];
              state.speechBubbles.push({
                x: a.x,
                y: a.y - 40,
                text: emotionalMessage,
                time: 0,
                life: 4.0, // Longer lasting
                owner: a,
                color: '#ff0000',
                scale: 1.3
              });
              
              // Add grave to graveyard
              state.graveyard.push({
                x: a.x,
                y: a.y,
                name: a.name,
                animalType: a.animalType.type,
                time: state.time,
                color: a.animalType.color
              });
              
              // Remove the ally
              allies.splice(j, 1);
            }
            bullets.splice(i, 1);
            break;
          }
        }
      }

      // Grenade explosion at target location
      if (b.grenade && b.life > 0.8) {
        explosion(b.targetX, b.targetY, b.splash, b.damage, b.color, b.splashFall);
        sounds.explosion();
        bullets.splice(i, 1);
      }

      // Lifetime or out of bounds
      if (b.life > b.maxLife || b.x < -50 || b.x > state.w + 50 || b.y < -50 || b.y > state.h + 50) {
        bullets.splice(i, 1);
      }
    }

    // Ally pickup collection
    for (const a of allies) {
      if (a.hp <= 0) continue;
      
      for (let i = pickups.length - 1; i >= 0; i--) {
        const p = pickups[i];
        const dx = p.x - a.x, dy = p.y - a.y;
        const d = Math.hypot(dx, dy);
        
        // Allies can pick up health drops when close
        if (d < a.r + 16 && p.type === 'med') {
          // Heal the ally
          a.hp = Math.min(a.maxHp, a.hp + 20);
          
          // Visual feedback
          particlesBurst(p.x, p.y, '#27d07e', 8, 140);
          cameraFlash(0.08);
          sounds.pickup();
          
          // Speech bubble for ally healing
          const healMessages = ['Healed!', 'Better!', 'Restored!', 'Thanks!'];
          const healMessage = healMessages[Math.floor(Math.random() * healMessages.length)];
          state.speechBubbles.push({
            x: a.x,
            y: a.y - 30,
            text: healMessage,
            time: 0,
            life: 2.0,
            owner: a,
            color: '#27d07e',
            scale: 0.9
          });
          
          // Remove the pickup
          pickups.splice(i, 1);
          break; // Only pick up one health drop per frame
        }
      }
    }

    // Pickups
    for (let i = pickups.length - 1; i >= 0; i--) {
      const p = pickups[i];
      p.t += dt;
      p.spin += dt * 1.4;
      // Attraction if close (improved pickup magnet)
      const dx = p.x - player.x, dy = p.y - player.y;
      const d = Math.hypot(dx, dy);
      const pickupRange = 200 + (state.skillTree.pickupRange * 50); // Base 200 + 50 per skill level
      if (d < pickupRange) { // Dynamic range based on skill tree
        const magnetStrength = d < pickupRange * 0.5 ? 120 : 60; // Stronger magnet when closer
        p.x -= dx / (d || 1) * magnetStrength * dt;
        p.y -= dy / (d || 1) * magnetStrength * dt;
      }
      if (d < player.r + 16) {
        if (p.type === 'med') {
          healPlayer(24);
          addMessage('Health restored!', 'heal');
        } else if (p.type === 'stam') {
          player.stam = Math.min(player.stamMax, player.stam + 40);
          addMessage('Stamina restored!', 'heal');
        } else if (p.type === 'ammo') {
          // Smart ammo distribution - prioritize low ammo weapons
          const lowAmmoWeapons = arsenal.filter(w => w.reserve < w.magSize);
          if (lowAmmoWeapons.length > 0) {
            // Give more ammo to weapons that need it
            for (const w of lowAmmoWeapons) {
              w.reserve += Math.ceil(w.magSize * 0.8);
            }
            addMessage('Smart ammo distribution!', 'ammo');
          } else {
            // Normal distribution if all weapons have good ammo
            for (const w of arsenal) {
              w.reserve += Math.ceil(w.magSize * 0.6);
            }
            addMessage('Ammo restocked!', 'ammo');
          }
        } else if (p.type === 'turret') {
          player.turrets++;
          addMessage('Turret acquired!', 'turret');
        } else if (p.type === 'barricade') {
          player.barricades++;
          addMessage('Barricade acquired!', 'turret');
        } else if (p.type === 'spike') {
          player.spikes++;
          addMessage('Vines acquired!', 'turret');
        } else if (p.type === 'weapon') {
          // Weapon already unlocked in dropPickup function
        }
        cameraFlash(0.1);
        particlesBurst(p.x, p.y, p.type === 'med' ? '#27d07e' : p.type === 'stam' ? '#3a86ff' : p.type === 'weapon' ? '#ff6b6b' : p.type === 'turret' ? '#4a90e2' : p.type === 'barricade' ? '#8b4513' : p.type === 'spike' ? '#ff4444' : '#ffbf00', 10, 160);
        sounds.pickup();
        pickups.splice(i,1);
      }
    }

    // Particles
    for (let i = particles.length - 1; i >= 0; i--) {
      const p = particles[i];
      p.t += dt;
      p.x += (p.vx || 0) * dt;
      p.y += (p.vy || 0) * dt;
      if (p.t > (p.life || 0.8)) particles.splice(i,1);
    }

    // Waves and spawns
    state.waveTime += dt;
    const wantCount = 8 + state.wave * 3;
    // Don't spawn enemies for first 20 seconds
    if (state.waveTime > 20 && enemies.length < wantCount && Math.random() < 0.02 + state.wave*0.002) spawnEnemy();
    
    // Spawn allies only at wave start (not continuously)
    // Removed continuous spawning - allies only spawn at wave start now
    
    if (state.waveTime > 35 + state.wave * 3) {
      state.wave++;
      state.waveTime = 0;
      // wave rewards
      dropPickup(player.x + rand(-40,40), player.y + rand(-40,40));
      state.night = (Math.random() < 0.5) ? !state.night : state.night;
      cameraFlash(0.2);
      
      // Announce new wave
      addMessage(`Wave ${state.wave}`);
      
      // Spawn companions at wave start (1-3 companions per wave)
      const companionCount = Math.min(1 + Math.floor(state.wave / 3), 3);
      for (let i = 0; i < companionCount; i++) {
        spawnAlly();
      }
      
      // Spawn bosses at specific waves
      if (state.wave === 5 || state.wave === 10 || state.wave === 15) {
        spawnBoss();
      }
    }

    // Combo decay (faster for harder power mode)
    if (state.combo > 0) {
      state.combo = Math.max(0, state.combo - dt * 1.2); // Faster decay
    }
    
    // Auto-pickup nearby items when not moving
    const playerMoveMag = Math.hypot(player.vx, player.vy) / player.speed;
    if (playerMoveMag < 0.1) {
      for (let i = pickups.length - 1; i >= 0; i--) {
        const p = pickups[i];
        const dx = p.x - player.x, dy = p.y - player.y;
        const d = Math.hypot(dx, dy);
        if (d < 60) { // Increased auto-pickup radius from 50 to 60
          // Process pickup immediately
          if (p.type === 'med') {
            healPlayer(24);
          } else if (p.type === 'stam') {
            player.stam = Math.min(player.stamMax, player.stam + 40);
          } else if (p.type === 'ammo') {
            for (const w of arsenal) {
              w.reserve += Math.ceil(w.magSize * 0.4); // Reduced from 0.6 to 0.4
            }
          } else if (p.type === 'turret') {
            player.turrets++;
          } else if (p.type === 'barricade') {
            player.barricades++;
          } else if (p.type === 'spike') {
            player.spikes++;
          } else if (p.type === 'healingPlatform') {
            player.healingPlatforms++;
          }
          cameraFlash(0.05);
          particlesBurst(p.x, p.y, p.type === 'med' ? '#27d07e' : p.type === 'stam' ? '#3a86ff' : p.type === 'weapon' ? '#ff6b6b' : p.type === 'turret' ? '#4a90e2' : p.type === 'barricade' ? '#8b4513' : p.type === 'spike' ? '#ff4444' : '#ffbf00', 8, 120);
          sounds.pickup();
          pickups.splice(i, 1);
        }
      }
    }
    
    // Update damage numbers
    for (let i = state.damageNumbers.length - 1; i >= 0; i--) {
      const dn = state.damageNumbers[i];
      dn.time += dt;
      dn.x += dn.vx * dt;
      dn.y += dn.vy * dt;
      dn.vy += 20 * dt; // Gravity
      
      if (dn.time > dn.life) {
        state.damageNumbers.splice(i, 1);
      }
    }
    
    // Power mode timer
    if (state.powerMode) {
      state.powerModeTimer -= dt;
      if (state.powerModeTimer <= 0) {
        state.powerMode = false;
        addMessage('Power mode ended');
      }
    }
    
    // Special ability cooldown
    if (player.specialCooldown > 0) {
      player.specialCooldown -= dt;
    }
    
    // Healing platform cooldown
    if (player.healingPlatformCooldown > 0) {
      player.healingPlatformCooldown -= dt;
    }
    
    // Check achievements
    checkAchievements();
    
    // Spawn environmental hazards occasionally
    if (state.wave >= 5 && Math.random() < 0.001) { // 0.1% chance per frame after wave 5
      spawnHazard();
    }
    
    // Update hazards
    updateHazards(dt);
    
    // Flash decay
    state.flash = Math.max(0, state.flash - dt * 1.5);

    // Death
    if (player.hp <= 0) {
      gameOver();
    }

    updateHUD();
  }

  // Combat helpers
  function tryFire(w) {
    if (player.reloadT > 0) return;
    if (w.mag <= 0) { startReload(); return; }

    // Power mode effects
    let fireDelay = w.fireDelay;
    let damage = w.damage;
    let pellets = w.pellets;
    
    if (state.powerMode) {
      fireDelay *= 0.5; // Faster firing
      damage *= 1.5; // More damage
      pellets = Math.max(pellets, 2); // At least 2 pellets
    }
    
    w.fireT = fireDelay;
    w.mag--;
    const ang = player.angle;

    // Special handling for grenade launcher
    if (w.grenade) {
      // Grenade explodes in front of player after a short distance
      const distance = 80; // Distance in front of player
      const targetX = player.x + Math.cos(ang) * distance;
      const targetY = player.y + Math.sin(ang) * distance;
      
      bullets.push({
        x: player.x + Math.cos(ang)*18,
        y: player.y + Math.sin(ang)*18,
        targetX, targetY,
        width: w.width,
        color: w.color,
        tracer: w.tracer,
        life: 0,
        maxLife: 1.0, // Shorter flight time
        damage: w.damage,
        pierce: w.pierce || 0,
        knock: w.knock || 0,
        splash: w.splash || 0,
        splashFall: w.splashFall || 0,
        grenade: true,
        speed: w.speed,
      });
    } else {
      for (let i = 0; i < w.pellets; i++) {
        const a = ang + rand(-w.spread, w.spread);
        const spd = w.speed * (w.pellets > 1 ? rand(0.92, 1) : 1);
        const vx = Math.cos(a) * spd;
        const vy = Math.sin(a) * spd;
        bullets.push({
          x: player.x + Math.cos(ang)*18,
          y: player.y + Math.sin(ang)*18,
          vx, vy,
          width: w.width,
          color: w.color,
          tracer: w.tracer,
          life: 0,
          maxLife: 1.2,
          damage: damage,
          pierce: w.pierce || 0,
          knock: w.knock || 0,
          splash: w.splash || 0,
          splashFall: w.splashFall || 0,
          flamethrower: w.flamethrower || false,
          burnDamage: w.burnDamage || 0,
          burnDuration: w.burnDuration || 0,
          // Enhanced flamethrower properties
          flameSize: w.flamethrower ? rand(8, 15) : 0,
          flameIntensity: w.flamethrower ? rand(0.7, 1.3) : 1,
        });
      }
    }
    recoilPlayer(w);
    muzzleFlash(player.x, player.y, ang, w);
    cameraFlash(0.08 + (w.splash ? 0.12 : 0));
    sounds.gunshot();
  }

  function startReload() {
    const w = arsenal[player.weapon];
    if (player.reloadT > 0) return;
    const need = w.magSize - w.mag;
    if (need <= 0 || w.reserve <= 0) return;
    player.reloadT = w.reload;
    sounds.reload();
    addMessage(`Reloading ${w.name}`);
    
    // Reload speech bubble
    const reloadPhrases = ['Reloading!', 'Fresh mag!', 'Loading up!', 'Reload time!', 'New ammo!'];
    const phrase = reloadPhrases[Math.floor(Math.random() * reloadPhrases.length)];
    state.speechBubbles.push({
      x: player.x,
      y: player.y - 40,
      text: phrase,
      time: 0,
      life: 1.5,
      owner: null
    });
  }

  function recoilPlayer(w) {
    const f = 70 + (w.knock || 0) * 0.3;
    player.x -= Math.cos(player.angle) * (f / 160);
    player.y -= Math.sin(player.angle) * (f / 160);
    particlesMuzzle(player.x, player.y, player.angle, w.color);
  }

  function damagePlayer(n) {
    if (player.inv > 0) return;
    player.hp -= n;
    player.inv = 0.25;
    particlesBurst(player.x, player.y, '#ff6a6a', 12, 140);
    cameraFlash(0.25);
    screenShake(0.2, 0.15);
    
    // Blood splatter effect
    state.bloodSplatter = 0.5; // Duration
    state.bloodSplatterX = player.x;
    state.bloodSplatterY = player.y;
  }

  function healPlayer(n) {
    player.hp = Math.min(player.hpMax, player.hp + n);
  }

  function hitEnemy(e, dmg, knock, ang, burnDamage = 0, burnDuration = 0, fromPlayer = false) {
    e.hp -= dmg;
    e.stun = 0.1; // Stun enemy briefly to prevent weird movement
    
    // Bosses are immune to knockback
    if (e.type !== 'boss') {
      e.x -= Math.cos(ang) * (knock / (e.type === 'brute' ? 10 : 6));
      e.y -= Math.sin(ang) * (knock / (e.type === 'brute' ? 10 : 6));
    }
    
    // Apply burn damage if specified
    if (burnDamage > 0 && burnDuration > 0) {
      e.burnTimer = burnDuration;
      e.burnDamage = burnDamage;
    }
    
    // Add damage number
    if (state.showDamage) {
      state.damageNumbers.push({
        x: e.x,
        y: e.y,
        damage: dmg,
        time: 0,
        life: 1.5,
        vx: rand(-30, 30),
        vy: -50,
        color: dmg > 50 ? '#ff4444' : dmg > 25 ? '#ffaa00' : '#ffffff'
      });
    }
    // Boss dialogue when taking damage
    if (e.bossType && e.hp > 0 && dmg > 10) {
      let bossDialogue = '';
      if (e.bossType === 'boss') {
        const phrases = [
          "ARRGH!",
          "YOU DARE!",
          "I'LL KILL YOU!",
          "PAIN ONLY MAKES ME STRONGER!",
          "IS THAT ALL YOU'VE GOT?"
        ];
        bossDialogue = phrases[Math.floor(Math.random() * phrases.length)];
      } else if (e.bossType === 'necromancer') {
        const phrases = [
          "THE SHADOWS PROTECT ME!",
          "YOUR ATTACKS ARE FUTILE!",
          "I FEEL NO PAIN!",
          "DARKNESS HEALS MY WOUNDS!",
          "YOU MERELY SCRATCH ME!"
        ];
        bossDialogue = phrases[Math.floor(Math.random() * phrases.length)];
      } else if (e.bossType === 'titan') {
        const phrases = [
          "I AM UNBREAKABLE!",
          "YOUR PUNY ATTACKS!",
          "I LAUGH AT YOUR DAMAGE!",
          "ROCK DOESN'T FEEL PAIN!",
          "YOU CANNOT HURT ME!"
        ];
        bossDialogue = phrases[Math.floor(Math.random() * phrases.length)];
      }
      
      if (bossDialogue && Math.random() < 0.3) { // 30% chance
        state.speechBubbles.push({
          x: e.x,
          y: e.y - 60,
          text: bossDialogue,
          time: 0,
          life: 2.0,
          owner: e,
          color: '#ff0000',
          scale: 1.2
        });
      }
    }
    
    if (e.hp <= 0) {
      // Only count player kills for combo (not turret kills)
      const isPlayerKill = fromPlayer;
      
      if (isPlayerKill) {
        // Enhanced combo system with streak bonuses
        state.combo++;
        state.maxCombo = Math.max(state.maxCombo, state.combo);
        
        // Streak bonuses every 10 kills
        if (state.combo % 10 === 0) {
          addMessage(`Kill Streak: ${state.combo}!`, 'combo');
          particlesBurst(e.x, e.y, '#ffaa00', 15, 200);
        }
        
        // Power mode activation (exceedingly rare)
        if (state.combo >= 100 && !state.powerMode) {
          state.powerMode = true;
          state.powerModeTimer = 12; // Longer duration for such an achievement
          addMessage('LEGENDARY POWER MODE ACTIVATED!');
          cameraFlash(0.5);
        }
      }
      
      // Score with combo multiplier (only for player kills)
      const comboMultiplier = isPlayerKill ? (1 + (state.combo * 0.2)) : 1;
      const baseScore = 10 + Math.round(e.hpMax / 6);
      state.score += Math.round(baseScore * comboMultiplier);
      state.kills++;
      
      // Boss death dialogue
      if (e.bossType) {
        let deathDialogue = '';
        if (e.bossType === 'boss') {
          const phrases = [
            "NO... IMPOSSIBLE...",
            "I... CANNOT... DIE...",
            "YOU... WIN...",
            "CURSE... YOU...",
            "THE END... FOR ME..."
          ];
          deathDialogue = phrases[Math.floor(Math.random() * phrases.length)];
        } else if (e.bossType === 'necromancer') {
          const phrases = [
            "THE SHADOWS... FADE...",
            "DARKNESS... LEAVES ME...",
            "MY POWER... GONE...",
            "I RETURN... TO THE VOID...",
            "THE DEAD... NO LONGER... OBEY..."
          ];
          deathDialogue = phrases[Math.floor(Math.random() * phrases.length)];
        } else if (e.bossType === 'titan') {
          const phrases = [
            "THE MOUNTAIN... FALLS...",
            "ROCK... CRUMBLES...",
            "EARTH... SHAKES... NO MORE...",
            "I AM... BROKEN...",
            "THE TITAN... DIES..."
          ];
          deathDialogue = phrases[Math.floor(Math.random() * phrases.length)];
        }
        
        if (deathDialogue) {
          state.speechBubbles.push({
            x: e.x,
            y: e.y - 80,
            text: deathDialogue,
            time: 0,
            life: 3.0,
            owner: e,
            color: '#ff0000',
            scale: 1.3
          });
        }
      }
      
      dropPickup(e.x + rand(-10,10), e.y + rand(-10,10));
      
      // Enhanced death particles
      particlesBurst(e.x, e.y, '#ff4949', 20, 250);
      
      // Add blood/gore particles for larger enemies
      if (e.r > 15 || e.bossType) {
        for (let i = 0; i < 12; i++) {
          const a = rand(0, TAU);
          const s = rand(100, 300);
          particles.push({
            x: e.x,
            y: e.y,
            vx: Math.cos(a) * s,
            vy: Math.sin(a) * s,
            r: rand(2, 5),
            color: '#8b0000', // Dark red
            t: 0,
            life: rand(0.8, 1.5),
          });
        }
      }
      
      // Add smoke particles for all deaths
      for (let i = 0; i < 8; i++) {
        const a = rand(0, TAU);
        const s = rand(80, 200);
        particles.push({
          x: e.x,
          y: e.y,
          vx: Math.cos(a) * s,
          vy: Math.sin(a) * s,
          r: rand(1, 3),
          color: 'rgba(60, 60, 60, 0.6)',
          t: 0,
          life: rand(0.6, 1.2),
        });
      }
      
      // Add spark particles for mechanical enemies or bosses
      if (e.type === 'boss' || e.bossType) {
        for (let i = 0; i < 10; i++) {
          const a = rand(0, TAU);
          const s = rand(150, 400);
          particles.push({
            x: e.x,
            y: e.y,
            vx: Math.cos(a) * s,
            vy: Math.sin(a) * s,
            r: rand(1, 2),
            color: '#ffffaa',
            t: 0,
            life: rand(0.3, 0.8),
          });
        }
      }
      
      sounds.hit(0.4);
      enemies.splice(enemies.indexOf(e), 1);
    }
  }

  function knockEnemies(x, y, radius, power) {
    for (const e of enemies) {
      // Bosses are immune to knockback
      if (e.type === 'boss') continue;
      
      const dx = e.x - x, dy = e.y - y;
      const d = Math.hypot(dx, dy);
      if (d < radius) {
        const a = Math.atan2(dy, dx);
        e.x += Math.cos(a) * (power * (1 - d / radius) * 0.15); // Reduced from 0.3
        e.y += Math.sin(a) * (power * (1 - d / radius) * 0.15); // Reduced from 0.3
      }
    }
  }

  function explosion(x, y, radius, baseDmg, color, falloff) {
    // Enhanced explosion with multiple particle types
    particlesBurst(x, y, color, 30, 300);
    
    // Add smoke particles
    for (let i = 0; i < 15; i++) {
      const a = rand(0, TAU);
      const s = rand(100, 250);
      particles.push({
        x, y,
        vx: Math.cos(a) * s,
        vy: Math.sin(a) * s,
        r: rand(2, 5),
        color: 'rgba(80, 80, 80, 0.7)',
        t: 0,
        life: rand(0.8, 1.5),
      });
    }
    
    // Add fire particles for explosive weapons
    if (color.includes('ff') || color.includes('aa')) {
      for (let i = 0; i < 12; i++) {
        const a = rand(0, TAU);
        const s = rand(150, 350);
        particles.push({
          x, y,
          vx: Math.cos(a) * s,
          vy: Math.sin(a) * s,
          r: rand(3, 7),
          color: `hsl(${rand(20, 40)}, 100%, ${rand(50, 70)}%)`,
          t: 0,
          life: rand(0.6, 1.2),
        });
      }
    }
    
    // Add spark particles
    for (let i = 0; i < 8; i++) {
      const a = rand(0, TAU);
      const s = rand(200, 400);
      particles.push({
        x, y,
        vx: Math.cos(a) * s,
        vy: Math.sin(a) * s,
        r: rand(1, 2),
        color: '#ffffaa',
        t: 0,
        life: rand(0.3, 0.6),
      });
    }
    
    cameraFlash(0.35);
    screenShake(0.3, 0.2);
    
    for (const e of enemies) {
      const dx = e.x - x, dy = e.y - y;
      const d = Math.hypot(dx, dy);
      if (d <= radius) {
        const scale = 1 - (d / radius) ** (falloff || 0.6);
        hitEnemy(e, Math.round(baseDmg * scale), 520 * scale, Math.atan2(dy, dx));
      }
    }
  }

  // Particles and flashes
  function particlesBurst(x, y, color, count, power) {
    for (let i = 0; i < count; i++) {
      const a = rand(0, TAU);
      const s = rand(power * 0.3, power);
      particles.push({
        x, y,
        vx: Math.cos(a) * s,
        vy: Math.sin(a) * s,
        r: rand(1.5, 3.5),
        color,
        t: 0,
        life: rand(0.25, 0.8),
      });
    }
  }

  function particlesHit(x, y, color) {
    // Enhanced hit particles with more variety
    for (let i = 0; i < 12; i++) {
      const a = rand(0, TAU);
      const s = rand(80, 250);
      particles.push({ 
        x, y, 
        vx: Math.cos(a)*s, 
        vy: Math.sin(a)*s, 
        r: rand(1, 3), 
        color, 
        t: 0, 
        life: rand(0.2, 0.6) 
      });
    }
    
    // Add spark particles for impact
    for (let i = 0; i < 6; i++) {
      const a = rand(0, TAU);
      const s = rand(100, 300);
      particles.push({ 
        x, y, 
        vx: Math.cos(a)*s, 
        vy: Math.sin(a)*s, 
        r: rand(0.5, 1.5), 
        color: '#ffffaa', 
        t: 0, 
        life: rand(0.1, 0.4) 
      });
    }
  }

  function particlesMuzzle(x, y, ang, color) {
    const len = 18;
    const mx = x + Math.cos(ang) * (len + 6);
    const my = y + Math.sin(ang) * (len + 6);
    for (let i = 0; i < 5; i++) {
      const a = ang + rand(-0.5, 0.5);
      const s = rand(120, 260);
      particles.push({ x: mx, y: my, vx: Math.cos(a)*s, vy: Math.sin(a)*s, r: rand(1.2,2.4), color, t: 0, life: 0.25 });
    }
  }

  function muzzleFlash(x, y, ang, w) {
    ctx.save();
    ctx.translate(x, y);
    ctx.rotate(ang);
    ctx.globalCompositeOperation = 'lighter';
    
    // Enhanced muzzle flash with multiple layers
    const flashSize = w.flamethrower ? 40 : 28;
    const flashColor = w.flamethrower ? '#ffaa00' : w.color;
    
    // Outer glow
    const outerGrad = ctx.createRadialGradient(16, 0, 0, 16, 0, flashSize * 1.5);
    outerGrad.addColorStop(0, flashColor);
    outerGrad.addColorStop(0.7, 'rgba(255,255,255,0.3)');
    outerGrad.addColorStop(1, 'rgba(0,0,0,0)');
    ctx.fillStyle = outerGrad;
    ctx.beginPath(); 
    ctx.arc(16, 0, flashSize * 1.5, 0, TAU); 
    ctx.fill();
    
    // Inner flash
    const innerGrad = ctx.createRadialGradient(16, 0, 0, 16, 0, flashSize);
    innerGrad.addColorStop(0, '#ffffff');
    innerGrad.addColorStop(0.5, flashColor);
    innerGrad.addColorStop(1, 'rgba(0,0,0,0)');
    ctx.fillStyle = innerGrad;
    ctx.beginPath(); 
    ctx.arc(16, 0, flashSize, 0, TAU); 
    ctx.fill();
    
    ctx.restore();
    
    // Add muzzle particles
    const particleCount = w.flamethrower ? 8 : 4;
    for (let i = 0; i < particleCount; i++) {
      const angle = ang + rand(-0.3, 0.3);
      const speed = rand(50, 120);
      particles.push({
        x: x + Math.cos(ang) * 20,
        y: y + Math.sin(ang) * 20,
        vx: Math.cos(angle) * speed,
        vy: Math.sin(angle) * speed,
        r: rand(1, 3),
        color: w.flamethrower ? `hsl(${rand(20, 40)}, 100%, ${rand(60, 80)}%)` : flashColor,
        t: 0,
        life: rand(0.2, 0.6),
      });
    }
  }

  function cameraFlash(n) { state.flash = Math.min(0.3, state.flash + n * 0.3); } // Reduced intensity
  
  function screenShake(intensity, duration) {
    state.screenShake = Math.max(state.screenShake, intensity);
    state.screenShakeX = rand(-intensity * 10, intensity * 10);
    state.screenShakeY = rand(-intensity * 10, intensity * 10);
  }

  // Draw
  function draw() {
    // Apply screen shake
    if (state.screenShake > 0) {
      ctx.save();
      ctx.translate(state.screenShakeX, state.screenShakeY);
      state.screenShake -= state.dt;
      if (state.screenShake <= 0) {
        state.screenShake = 0;
        state.screenShakeX = 0;
        state.screenShakeY = 0;
      }
    }
    
    // Background map
    drawMap();

    // Pickups
    for (const p of pickups) drawPickup(p);

    // Bullets
    for (const b of bullets) {
      if (b.flamethrower) {
        // Enhanced flamethrower bullets with bigger, more dynamic effects
        const flameSize = b.flameSize || 8;
        const intensity = b.flameIntensity || 1;
        
        // Outer flame glow
        const gradient = ctx.createRadialGradient(b.x, b.y, 0, b.x, b.y, flameSize * 2);
        gradient.addColorStop(0, `rgba(255, 100, 50, ${0.8 * intensity})`);
        gradient.addColorStop(0.3, `rgba(255, 150, 50, ${0.6 * intensity})`);
        gradient.addColorStop(0.7, `rgba(255, 200, 50, ${0.3 * intensity})`);
        gradient.addColorStop(1, 'rgba(255, 200, 50, 0)');
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(b.x, b.y, flameSize * 2, 0, TAU);
        ctx.fill();
        
        // Inner flame core
        ctx.fillStyle = `rgba(255, 255, 200, ${0.9 * intensity})`;
        ctx.beginPath();
        ctx.arc(b.x, b.y, flameSize * 0.6, 0, TAU);
        ctx.fill();
        
        // Flame particles
        if (Math.random() < 0.4) {
          particles.push({
            x: b.x + rand(-flameSize, flameSize),
            y: b.y + rand(-flameSize, flameSize),
            vx: rand(-30, 30),
            vy: rand(-40, -10),
            r: rand(2, 6),
            color: `hsl(${rand(20, 40)}, 100%, ${rand(60, 80)}%)`,
            t: 0,
            life: rand(0.3, 0.8),
          });
        }
        
        // Smoke particles
        if (Math.random() < 0.2) {
          particles.push({
            x: b.x + rand(-flameSize * 0.5, flameSize * 0.5),
            y: b.y + rand(-flameSize * 0.5, flameSize * 0.5),
            vx: rand(-15, 15),
            vy: rand(-20, -5),
            r: rand(1, 3),
            color: 'rgba(100, 100, 100, 0.6)',
            t: 0,
            life: rand(0.5, 1.2),
          });
        }
      } else {
        // Regular bullet tracer
        drawTracer(b.x - Math.cos(Math.atan2(b.vy, b.vx))*b.tracer, b.y - Math.sin(Math.atan2(b.vy, b.vx))*b.tracer, Math.atan2(b.vy, b.vx), b.color, b.tracer, b.width);
      }
      
      // projectile core
      ctx.fillStyle = b.color;
      ctx.beginPath();
      ctx.arc(b.x, b.y, Math.max(1.5, b.width*0.6), 0, TAU);
      ctx.fill();
    }

    // Barricades
    for (const b of barricades) drawBarricade(b);

    // Spikes
    for (const s of spikes) drawSpike(s);

    // Mines
    for (const m of mines) drawMine(m);

    // Turrets
    for (const t of turrets) drawTurret(t);

    // Healing platforms
    for (const h of healingPlatforms) drawHealingPlatform(h);
    
    // Environmental hazards
    drawHazards();

    // Graveyard (fallen allies)
    drawGraveyard();
    
    // Allies
    for (const a of allies) drawAlly(a);

    // Enemies
    for (const e of enemies) drawEnemy(e);

    // Player
    drawPlayer();

    // Particles
    for (const p of particles) drawParticle(p);

    // Messages
    drawMessages();
    
    // Speech bubbles
    drawSpeechBubbles();
    
    // Damage numbers
    drawDamageNumbers();
    
    // Power mode effects
    if (state.powerMode) {
      drawPowerModeEffects();
    }
    
    // Minimap/Radar
    drawMinimap();
    
    // Blood splatter effect
    if (state.bloodSplatter > 0) {
      drawBloodSplatter();
    }
    
    // PostFX
    postFX();
    
    // Restore screen shake
    if (state.screenShake > 0) {
      ctx.restore();
    }
  }

  function updateMinimap() {
    // Clear minimap
    minimapCtx.fillStyle = '#0a0f14';
    minimapCtx.fillRect(0, 0, 200, 150);
    
    // Draw zone ring
    minimapCtx.strokeStyle = '#f04747';
    minimapCtx.lineWidth = 2;
    minimapCtx.globalAlpha = 0.3;
    minimapCtx.beginPath();
    minimapCtx.arc(100, 75, 60, 0, TAU);
    minimapCtx.stroke();
    minimapCtx.globalAlpha = 1;
    
    // Draw player
    const playerX = (player.x / state.w) * 200;
    const playerY = (player.y / state.h) * 150;
    minimapCtx.fillStyle = '#27d07e';
    minimapCtx.beginPath();
    minimapCtx.arc(playerX, playerY, 3, 0, TAU);
    minimapCtx.fill();
    
    // Draw enemies
    minimapCtx.fillStyle = '#ff4444';
    for (const e of enemies) {
      const ex = (e.x / state.w) * 200;
      const ey = (e.y / state.h) * 150;
      minimapCtx.beginPath();
      minimapCtx.arc(ex, ey, 2, 0, TAU);
      minimapCtx.fill();
    }
    
    // Draw turrets
    minimapCtx.fillStyle = '#4a90e2';
    for (const t of turrets) {
      const tx = (t.x / state.w) * 200;
      const ty = (t.y / state.h) * 150;
      minimapCtx.beginPath();
      minimapCtx.arc(tx, ty, 2, 0, TAU);
      minimapCtx.fill();
    }
    
    // Draw healing platforms
    minimapCtx.fillStyle = '#00ff88';
    for (const h of healingPlatforms) {
      const hx = (h.x / state.w) * 200;
      const hy = (h.y / state.h) * 150;
      minimapCtx.beginPath();
      minimapCtx.arc(hx, hy, 4, 0, TAU);
      minimapCtx.fill();
    }
    
    // Draw allies
    minimapCtx.fillStyle = '#ffaa00';
    for (const a of allies) {
      const ax = (a.x / state.w) * 200;
      const ay = (a.y / state.h) * 150;
      minimapCtx.beginPath();
      minimapCtx.arc(ax, ay, 2, 0, TAU);
      minimapCtx.fill();
    }
  }

  function drawMap() {
    // EPIC atmospheric background with multiple dramatic layers
    
    // Base gradient - darker and more dramatic
    const baseGradient = ctx.createRadialGradient(state.w/2, state.h/2, 0, state.w/2, state.h/2, Math.max(state.w, state.h) * 1.2);
    baseGradient.addColorStop(0, '#0a0f14');
    baseGradient.addColorStop(0.1, '#0d1419');
    baseGradient.addColorStop(0.3, '#0a0f14');
    baseGradient.addColorStop(0.6, '#050a0f');
    baseGradient.addColorStop(0.8, '#030508');
    baseGradient.addColorStop(1, '#000000');
    ctx.fillStyle = baseGradient;
    ctx.fillRect(0, 0, state.w, state.h);
    
    // Update minimap
    updateMinimap();

    // EPIC atmospheric dust and debris - multiple layers (slower movement)
    ctx.save();
    ctx.globalAlpha = 0.12;
    ctx.fillStyle = '#ffffff';
    for (let i = 0; i < 120; i++) {
      const x = (i * 137.5 + state.time * 1.2) % state.w; // Slower movement
      const y = (i * 73.3 + state.time * 0.8) % state.h; // Slower movement
      const size = Math.max(0.8, Math.sin(state.time * 0.6 + i) * 2 + 1.5); // Slower pulsing
      ctx.beginPath();
      ctx.arc(x, y, size, 0, TAU);
      ctx.fill();
    }
    ctx.restore();

    // Red Zone corruption particles - more intense (slower)
    ctx.save();
    ctx.globalAlpha = 0.1;
    ctx.fillStyle = '#ff4444';
    for (let i = 0; i < 60; i++) {
      const x = (i * 97.3 + state.time * 0.8) % state.w; // Slower movement
      const y = (i * 113.7 + state.time * 0.6) % state.h; // Slower movement
      const size = Math.max(0.5, Math.sin(state.time * 0.4 + i) * 1.2 + 0.8); // Slower pulsing
      ctx.beginPath();
      ctx.arc(x, y, size, 0, TAU);
      ctx.fill();
    }
    ctx.restore();

    // Purple corruption particles (slower)
    ctx.save();
    ctx.globalAlpha = 0.08;
    ctx.fillStyle = '#8b00ff';
    for (let i = 0; i < 40; i++) {
      const x = (i * 127.3 + state.time * 0.5) % state.w; // Slower movement
      const y = (i * 93.7 + state.time * 0.7) % state.h; // Slower movement
      const size = Math.max(0.4, Math.sin(state.time * 0.3 + i) * 0.8 + 0.6); // Slower pulsing
      ctx.beginPath();
      ctx.arc(x, y, size, 0, TAU);
      ctx.fill();
    }
    ctx.restore();

    // RED ZONE corruption particles (RED ONLY!)
    ctx.save();
    ctx.globalAlpha = 0.15;
    ctx.fillStyle = '#ff0000';
    for (let i = 0; i < 30; i++) {
      const x = (i * 157.3 + state.time * 0.3) % state.w; // Very slow movement
      const y = (i * 103.7 + state.time * 0.4) % state.h; // Very slow movement
      const size = Math.max(0.6, Math.sin(state.time * 0.2 + i) * 1.5 + 1.0); // Very slow pulsing
      ctx.beginPath();
      ctx.arc(x, y, size, 0, TAU);
      ctx.fill();
    }
    ctx.restore();

    // RED ZONE dark red particles (RED ONLY!)
    ctx.save();
    ctx.globalAlpha = 0.12;
    ctx.fillStyle = '#8b0000';
    for (let i = 0; i < 25; i++) {
      const x = (i * 167.3 + state.time * 0.2) % state.w; // Extremely slow movement
      const y = (i * 113.7 + state.time * 0.3) % state.h; // Extremely slow movement
      const size = Math.max(0.5, Math.sin(state.time * 0.15 + i) * 1.2 + 0.8); // Extremely slow pulsing
      ctx.beginPath();
      ctx.arc(x, y, size, 0, TAU);
      ctx.fill();
    }
    ctx.restore();

    // EPIC GRID SYSTEM - Multiple layers for depth!
    ctx.save();
    ctx.globalAlpha = 0.15 + Math.sin(state.time * 0.2) * 0.05;
    ctx.strokeStyle = '#1a2330';
    ctx.lineWidth = 2;
    const step = 40;
    for (let x = (state.time * 2) % step; x < state.w; x += step) {
      ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, state.h); ctx.stroke();
    }
    for (let y = (state.time * 2) % step; y < state.h; y += step) {
      ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(state.w, y); ctx.stroke();
    }
    ctx.restore();

    // Secondary grid layer
    ctx.save();
    ctx.globalAlpha = 0.08 + Math.sin(state.time * 0.3) * 0.02;
    ctx.strokeStyle = '#2a3340';
    ctx.lineWidth = 1;
    const step2 = 80;
    for (let x = (state.time * 1) % step2; x < state.w; x += step2) {
      ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, state.h); ctx.stroke();
    }
    for (let y = (state.time * 1) % step2; y < state.h; y += step2) {
      ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(state.w, y); ctx.stroke();
    }
    ctx.restore();

    // SUBTLE BACKGROUND BUILDINGS - RANDOMLY SCATTERED!
    ctx.save();
    ctx.globalAlpha = 0.15; // MUCH MORE SUBTLE!
    ctx.fillStyle = '#1a0a0a';
    
    // RANDOMLY SCATTERED buildings throughout the area!
    for (let i = 0; i < 12; i++) {
      const x = Math.random() * state.w;
      const y = Math.random() * state.h;
      const width = 15 + Math.random() * 20;
      const height = 25 + Math.random() * 30;
      
      // Subtle building - RANDOM POSITIONS!
      ctx.fillRect(x, y, width, height);
      
      // Building details - SUBTLE WINDOWS!
      ctx.fillStyle = '#2a1a1a';
      for (let j = 0; j < 3; j++) {
        ctx.fillRect(x + 2, y + 3 + j * 6, width - 4, 2);
      }
      ctx.fillStyle = '#1a0a0a';
    }
    ctx.restore();

    // SUBTLE RED ZONE CORRUPTION - RANDOMLY SCATTERED!
    ctx.save();
    ctx.globalAlpha = 0.12; // VERY SUBTLE!
    ctx.fillStyle = '#2a0a0a';
    
    // RANDOMLY SCATTERED RED ZONE buildings!
    for (let i = 0; i < 8; i++) {
      const x = Math.random() * state.w;
      const y = Math.random() * state.h;
      const width = 18 + Math.random() * 15;
      const height = 28 + Math.random() * 20;
      
      // Subtle RED ZONE building - RANDOM POSITIONS!
      ctx.fillRect(x, y, width, height);
      
      // RED ZONE details - SUBTLE CORRUPTION!
      ctx.fillStyle = '#3a1a1a';
      for (let j = 0; j < 2; j++) {
        ctx.fillRect(x + 3, y + 5 + j * 8, width - 6, 3);
      }
      ctx.fillStyle = '#2a0a0a';
    }
    ctx.restore();

    // SUBTLE INDUSTRIAL STRUCTURES - RANDOMLY SCATTERED!
    ctx.save();
    ctx.globalAlpha = 0.10; // VERY SUBTLE!
    ctx.fillStyle = '#2a1a1a';
    
    // RANDOMLY SCATTERED industrial structures!
    for (let i = 0; i < 10; i++) {
      const x = Math.random() * state.w;
      const y = Math.random() * state.h;
      const width = 12 + Math.random() * 12;
      const height = 20 + Math.random() * 15;
      
      // Subtle industrial building - RANDOM POSITIONS!
      ctx.fillRect(x, y, width, height);
      
      // Industrial details - SUBTLE PIPES!
      ctx.fillStyle = '#3a2a1a';
      ctx.fillRect(x + 1, y + 3, width - 2, 3); // Vent
      ctx.fillStyle = '#2a1a1a';
    }
    ctx.restore();

    // EPIC zone ring with multiple dramatic layers (slower pulsing)
    ctx.save();
    const pulseIntensity = 0.25 + Math.sin(state.time * 0.5) * 0.15; // Slower pulsing
    ctx.globalAlpha = pulseIntensity;
    ctx.strokeStyle = '#f04747';
    ctx.lineWidth = 8;
    ctx.shadowColor = '#ff4444';
    ctx.shadowBlur = 20;
    ctx.beginPath();
    const r = Math.min(state.w, state.h) * 0.42 + Math.sin(state.time*0.4)*10; // Slower breathing
    ctx.arc(state.w/2, state.h/2, r, 0, TAU);
    ctx.stroke();
    ctx.shadowBlur = 0;
    
    // Multiple inner warning rings
    ctx.globalAlpha = 0.2;
    ctx.lineWidth = 4;
    ctx.beginPath();
    ctx.arc(state.w/2, state.h/2, r - 30, 0, TAU);
    ctx.stroke();
    
    ctx.globalAlpha = 0.15;
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.arc(state.w/2, state.h/2, r - 55, 0, TAU);
    ctx.stroke();
    
    ctx.globalAlpha = 0.1;
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(state.w/2, state.h/2, r - 80, 0, TAU);
    ctx.stroke();
    ctx.restore();

    // RED ZONE warning ring (RED ONLY!)
    ctx.save();
    ctx.globalAlpha = 0.12 + Math.sin(state.time * 0.3) * 0.05; // Slower pulsing
    ctx.strokeStyle = '#ff0000';
    ctx.lineWidth = 3;
    ctx.shadowColor = '#ff0000';
    ctx.shadowBlur = 15;
    ctx.beginPath();
    ctx.arc(state.w/2, state.h/2, r + 20, 0, TAU);
    ctx.stroke();
    ctx.shadowBlur = 0;
    ctx.restore();
    
    // EPIC atmospheric fog/haze effect
    ctx.save();
    ctx.globalAlpha = 0.12;
    const fogGradient = ctx.createRadialGradient(state.w/2, state.h/2, 0, state.w/2, state.h/2, Math.max(state.w, state.h) * 0.8);
    fogGradient.addColorStop(0, 'rgba(255, 255, 255, 0)');
    fogGradient.addColorStop(0.3, 'rgba(255, 255, 255, 0.2)');
    fogGradient.addColorStop(0.6, 'rgba(255, 255, 255, 0.3)');
    fogGradient.addColorStop(0.8, 'rgba(255, 255, 255, 0.4)');
    fogGradient.addColorStop(1, 'rgba(255, 255, 255, 0.5)');
    ctx.fillStyle = fogGradient;
    ctx.fillRect(0, 0, state.w, state.h);
    ctx.restore();

    // SPINNING WHEELS COMPLETELY REMOVED - NO MORE VERTIGO!



    // EPIC attack direction indicator with dramatic glow
    const waveDirection = Math.floor((state.wave - 1) / 3) % 4;
    ctx.save();
    ctx.globalAlpha = 0.7;
    ctx.fillStyle = '#ff4444';
    ctx.shadowColor = '#ff4444';
    ctx.shadowBlur = 25;
    const indicatorSize = 80;
    
    if (waveDirection === 0) { // Top
      ctx.fillRect(state.w/2 - indicatorSize/2, 10, indicatorSize, 30);
    } else if (waveDirection === 1) { // Right
      ctx.fillRect(state.w - 50, state.h/2 - indicatorSize/2, 30, indicatorSize);
    } else if (waveDirection === 2) { // Bottom
      ctx.fillRect(state.w/2 - indicatorSize/2, state.h - 40, indicatorSize, 30);
    } else { // Left
      ctx.fillRect(10, state.h/2 - indicatorSize/2, 30, indicatorSize);
    }
    
    // Additional glow layers
    ctx.globalAlpha = 0.4;
    ctx.shadowBlur = 35;
    if (waveDirection === 0) { // Top
      ctx.fillRect(state.w/2 - indicatorSize/2, 10, indicatorSize, 30);
    } else if (waveDirection === 1) { // Right
      ctx.fillRect(state.w - 50, state.h/2 - indicatorSize/2, 30, indicatorSize);
    } else if (waveDirection === 2) { // Bottom
      ctx.fillRect(state.w/2 - indicatorSize/2, state.h - 40, indicatorSize, 30);
    } else { // Left
      ctx.fillRect(10, state.h/2 - indicatorSize/2, 30, indicatorSize);
    }
    
    ctx.globalAlpha = 0.2;
    ctx.shadowBlur = 45;
    if (waveDirection === 0) { // Top
      ctx.fillRect(state.w/2 - indicatorSize/2, 10, indicatorSize, 30);
    } else if (waveDirection === 1) { // Right
      ctx.fillRect(state.w - 50, state.h/2 - indicatorSize/2, 30, indicatorSize);
    } else if (waveDirection === 2) { // Bottom
      ctx.fillRect(state.w/2 - indicatorSize/2, state.h - 40, indicatorSize, 30);
    } else { // Left
      ctx.fillRect(10, state.h/2 - indicatorSize/2, 30, indicatorSize);
    }
    ctx.restore();
    
    // CREATIVE BACKGROUND ELEMENTS - DETAILED ARCHITECTURAL STRUCTURES!
    ctx.save();
    ctx.globalAlpha = 0.25; // LIGHTER AND MORE SUBTLE!
    
    // Use pre-generated static positions instead of random every frame
    if (!state.backgroundStructures) {
      state.backgroundStructures = [];
      
      // Generate all structures once at game start with detailed building designs
      for (let i = 0; i < 8; i++) {
        state.backgroundStructures.push({
          x: Math.random() * state.w,
          y: Math.random() * state.h,
          width: 15 + Math.random() * 20,
          height: 20 + Math.random() * 25,
          color: '#ff4444',
          type: 'red_skyscraper',
          details: {
            windows: Math.floor(2 + Math.random() * 4),
            antenna: Math.random() > 0.5,
            lights: Math.random() > 0.3
          }
        });
      }
      
      for (let i = 0; i < 6; i++) {
        state.backgroundStructures.push({
          x: Math.random() * state.w,
          y: Math.random() * state.h,
          width: 12 + Math.random() * 15,
          height: 18 + Math.random() * 20,
          color: '#ffaa44',
          type: 'orange_factory',
          details: {
            smokestacks: Math.floor(1 + Math.random() * 3),
            pipes: Math.random() > 0.4,
            vents: Math.random() > 0.6
          }
        });
      }
      
      for (let i = 0; i < 5; i++) {
        state.backgroundStructures.push({
          x: Math.random() * state.w,
          y: Math.random() * state.h,
          width: 10 + Math.random() * 12,
          height: 16 + Math.random() * 18,
          color: '#4488ff',
          type: 'blue_tech',
          details: {
            panels: Math.floor(2 + Math.random() * 3),
            antenna: Math.random() > 0.5,
            lights: Math.random() > 0.4
          }
        });
      }
      
      for (let i = 0; i < 4; i++) {
        state.backgroundStructures.push({
          x: Math.random() * state.w,
          y: Math.random() * state.h,
          width: 8 + Math.random() * 10,
          height: 14 + Math.random() * 16,
          color: '#44ff44',
          type: 'green_lab',
          details: {
            windows: Math.floor(1 + Math.random() * 3),
            dome: Math.random() > 0.6,
            lights: Math.random() > 0.5
          }
        });
      }
      
      for (let i = 0; i < 3; i++) {
        state.backgroundStructures.push({
          x: Math.random() * state.w,
          y: Math.random() * state.h,
          width: 9 + Math.random() * 11,
          height: 15 + Math.random() * 17,
          color: '#aa44ff',
          type: 'purple_energy',
          details: {
            coils: Math.floor(1 + Math.random() * 2),
            core: Math.random() > 0.5,
            field: Math.random() > 0.4
          }
        });
      }
      
      for (let i = 0; i < 10; i++) {
        state.backgroundStructures.push({
          x: Math.random() * state.w,
          y: Math.random() * state.h,
          width: 6 + Math.random() * 8,
          height: 12 + Math.random() * 14,
          color: '#666666',
          type: 'grey_industrial',
          details: {
            pipes: Math.random() > 0.6,
            vents: Math.random() > 0.5,
            tanks: Math.random() > 0.4
          }
        });
      }
    }
    
          // Draw all pre-generated structures with DETAILED ARCHITECTURAL DESIGNS!
      for (const structure of state.backgroundStructures) {
        // Main building with shadow
        ctx.fillStyle = '#1a1a1a';
        ctx.fillRect(structure.x + 2, structure.y + 2, structure.width, structure.height);
        ctx.fillStyle = structure.color;
        ctx.fillRect(structure.x, structure.y, structure.width, structure.height);
        
        // Building details based on type
        if (structure.type === 'red_skyscraper') {
          // Multiple window rows with different lighting
          ctx.fillStyle = '#2a1a1a';
          for (let i = 0; i < structure.details.windows; i++) {
            ctx.fillRect(structure.x + 2, structure.y + 3 + i * 6, structure.width - 4, 3);
          }
          // Additional window columns
          for (let i = 0; i < 3; i++) {
            ctx.fillRect(structure.x + 4 + i * 4, structure.y + 2, 2, structure.height - 4);
          }
          // Rooftop details
          if (structure.details.antenna) {
            ctx.fillStyle = '#333333';
            ctx.fillRect(structure.x + structure.width/2 - 1, structure.y - 6, 2, 6);
            ctx.fillRect(structure.x + structure.width/2 - 2, structure.y - 8, 4, 2);
          }
          // Corner lights and entrance
          if (structure.details.lights) {
            ctx.fillStyle = '#ffff00';
            ctx.fillRect(structure.x + 1, structure.y + 1, 2, 2);
            ctx.fillRect(structure.x + structure.width - 3, structure.y + 1, 2, 2);
            ctx.fillRect(structure.x + 1, structure.y + structure.height - 3, 2, 2);
            ctx.fillRect(structure.x + structure.width - 3, structure.y + structure.height - 3, 2, 2);
          }
          // Entrance door
          ctx.fillStyle = '#1a0a0a';
          ctx.fillRect(structure.x + structure.width/2 - 2, structure.y + structure.height - 6, 4, 4);
        } else if (structure.type === 'orange_factory') {
          // Multiple smokestacks with smoke effect
          ctx.fillStyle = '#444444';
          for (let i = 0; i < structure.details.smokestacks; i++) {
            ctx.fillRect(structure.x + 2 + i * 4, structure.y - 4, 2, 4);
            ctx.fillRect(structure.x + 1 + i * 4, structure.y - 5, 4, 1);
          }
          // Side pipes with connections
          if (structure.details.pipes) {
            ctx.fillStyle = '#333333';
            ctx.fillRect(structure.x - 3, structure.y + 4, 3, structure.height - 8);
            ctx.fillRect(structure.x - 2, structure.y + 2, 1, 2);
            ctx.fillRect(structure.x - 2, structure.y + structure.height - 4, 1, 2);
          }
          // Multiple vents and machinery
          if (structure.details.vents) {
            ctx.fillStyle = '#555555';
            ctx.fillRect(structure.x + 2, structure.y + 2, structure.width - 4, 2);
            ctx.fillRect(structure.x + 4, structure.y + 6, structure.width - 8, 1);
            ctx.fillRect(structure.x + 4, structure.y + 10, structure.width - 8, 1);
          }
          // Industrial machinery details
          ctx.fillStyle = '#666666';
          ctx.fillRect(structure.x + 2, structure.y + structure.height - 6, structure.width - 4, 2);
        } else if (structure.type === 'blue_tech') {
          // Multiple tech panels with different colors
          ctx.fillStyle = '#2255aa';
          for (let i = 0; i < structure.details.panels; i++) {
            ctx.fillRect(structure.x + 2 + i * 4, structure.y + 2, 3, structure.height - 4);
          }
          // Additional tech details
          ctx.fillStyle = '#4488ff';
          for (let i = 0; i < 2; i++) {
            ctx.fillRect(structure.x + 1 + i * 6, structure.y + 4, 4, 2);
          }
          // Communication antenna with dish
          if (structure.details.antenna) {
            ctx.fillStyle = '#333333';
            ctx.fillRect(structure.x + structure.width/2 - 1, structure.y - 5, 2, 5);
            ctx.fillStyle = '#666666';
            ctx.fillRect(structure.x + structure.width/2 - 2, structure.y - 7, 4, 2);
          }
          // Tech lights and screens
          if (structure.details.lights) {
            ctx.fillStyle = '#00ffff';
            ctx.fillRect(structure.x + 1, structure.y + 1, 2, 2);
            ctx.fillRect(structure.x + structure.width - 3, structure.y + 1, 2, 2);
            ctx.fillStyle = '#0088ff';
            ctx.fillRect(structure.x + 2, structure.y + 6, structure.width - 4, 1);
          }
        } else if (structure.type === 'green_lab') {
          // Multiple window rows with scientific lighting
          ctx.fillStyle = '#2a4a2a';
          for (let i = 0; i < structure.details.windows; i++) {
            ctx.fillRect(structure.x + 2, structure.y + 3 + i * 5, structure.width - 4, 3);
          }
          // Scientific dome with details
          if (structure.details.dome) {
            ctx.fillStyle = '#22aa22';
            ctx.beginPath();
            ctx.arc(structure.x + structure.width/2, structure.y, structure.width/2, 0, Math.PI);
            ctx.fill();
            ctx.fillStyle = '#44ff44';
            ctx.beginPath();
            ctx.arc(structure.x + structure.width/2, structure.y, structure.width/2 - 2, 0, Math.PI);
            ctx.fill();
          }
          // Lab equipment details
          ctx.fillStyle = '#44aa44';
          ctx.fillRect(structure.x + 2, structure.y + structure.height - 4, structure.width - 4, 2);
          // Scientific lights
          if (structure.details.lights) {
            ctx.fillStyle = '#00ff00';
            ctx.fillRect(structure.x + 1, structure.y + 1, 2, 2);
            ctx.fillRect(structure.x + structure.width - 3, structure.y + 1, 2, 2);
            ctx.fillStyle = '#44ff44';
            ctx.fillRect(structure.x + 2, structure.y + 8, structure.width - 4, 1);
          }
        } else if (structure.type === 'purple_energy') {
          // Multiple energy coils with different intensities
          ctx.fillStyle = '#8844aa';
          for (let i = 0; i < structure.details.coils; i++) {
            ctx.fillRect(structure.x + 2 + i * 4, structure.y + 2, 3, structure.height - 4);
          }
          // Additional energy conduits
          ctx.fillStyle = '#aa44aa';
          for (let i = 0; i < 2; i++) {
            ctx.fillRect(structure.x + 1 + i * 6, structure.y + 4, 4, 2);
          }
          // Glowing energy core
          if (structure.details.core) {
            ctx.fillStyle = '#ff44ff';
            ctx.fillRect(structure.x + structure.width/2 - 3, structure.y + structure.height/2 - 3, 6, 6);
            ctx.fillStyle = '#ff88ff';
            ctx.fillRect(structure.x + structure.width/2 - 1, structure.y + structure.height/2 - 1, 2, 2);
          }
          // Energy field with multiple layers
          if (structure.details.field) {
            ctx.fillStyle = '#aa44ff';
            ctx.fillRect(structure.x - 2, structure.y - 2, structure.width + 4, structure.height + 4);
            ctx.fillStyle = '#8844aa';
            ctx.fillRect(structure.x - 1, structure.y - 1, structure.width + 2, structure.height + 2);
            ctx.fillStyle = structure.color;
            ctx.fillRect(structure.x, structure.y, structure.width, structure.height);
          }
        } else if (structure.type === 'grey_industrial') {
          // Multiple pipes with connections
          if (structure.details.pipes) {
            ctx.fillStyle = '#444444';
            ctx.fillRect(structure.x - 3, structure.y + 3, 3, structure.height - 6);
            ctx.fillRect(structure.x - 2, structure.y + 1, 1, 2);
            ctx.fillRect(structure.x - 2, structure.y + structure.height - 3, 1, 2);
          }
          // Multiple vents and machinery
          if (structure.details.vents) {
            ctx.fillStyle = '#555555';
            ctx.fillRect(structure.x + 1, structure.y + 1, structure.width - 2, 2);
            ctx.fillRect(structure.x + 3, structure.y + 5, structure.width - 6, 1);
            ctx.fillRect(structure.x + 3, structure.y + 9, structure.width - 6, 1);
          }
          // Storage tanks with details
          if (structure.details.tanks) {
            ctx.fillStyle = '#777777';
            ctx.fillRect(structure.x + structure.width - 4, structure.y + 2, 3, structure.height - 4);
            ctx.fillStyle = '#666666';
            ctx.fillRect(structure.x + structure.width - 5, structure.y + 1, 5, 1);
            ctx.fillRect(structure.x + structure.width - 5, structure.y + structure.height - 2, 5, 1);
          }
          // Industrial equipment
          ctx.fillStyle = '#666666';
          ctx.fillRect(structure.x + 2, structure.y + structure.height - 4, structure.width - 4, 2);
        }
      }
    
    ctx.restore();
  }

  function drawEnemy(e) {
    // Shadow
    ctx.fillStyle = 'rgba(0,0,0,0.35)';
    ctx.beginPath();
    ctx.ellipse(e.x, e.y+8, e.r*0.9, e.r*0.55, 0, 0, TAU);
    ctx.fill();

    ctx.save();
    ctx.translate(e.x, e.y);
    const a = Math.atan2(player.y - e.y, player.x - e.x);
    ctx.rotate(a);

    if (e.type === 'zombie') {
      // SCARY ZOMBIE - Completely redesigned from scratch
      
      // Main body - decayed and twisted
      const bodyGrad = ctx.createRadialGradient(0, 0, 0, 0, 0, e.r);
      bodyGrad.addColorStop(0, '#4a2a1a');
      bodyGrad.addColorStop(0.6, '#3a1a0a');
      bodyGrad.addColorStop(1, '#2a0a0a');
      ctx.fillStyle = bodyGrad;
      ctx.beginPath();
      ctx.ellipse(0, 0, e.r, e.r * 0.8, 0, 0, TAU);
      ctx.fill();
      
      // Decayed skin patches - irregular and gross
      ctx.fillStyle = '#3a2a1a';
      for (let i = 0; i < 12; i++) {
        const angle = (i / 12) * TAU + Math.sin(state.time * 2 + i) * 0.2;
        const x = Math.cos(angle) * e.r * 0.7;
        const y = Math.sin(angle) * e.r * 0.5;
        const size = e.r * 0.1 + Math.sin(state.time * 3 + i) * e.r * 0.05;
        ctx.beginPath();
        ctx.arc(x, y, size, 0, TAU);
        ctx.fill();
      }
      
      // Head - misshapen and decayed
      const headGrad = ctx.createRadialGradient(0, -e.r * 0.4, 0, 0, -e.r * 0.4, e.r * 0.5);
      headGrad.addColorStop(0, '#2a1a0a');
      headGrad.addColorStop(0.7, '#1a0a0a');
      headGrad.addColorStop(1, '#0a0a0a');
      ctx.fillStyle = headGrad;
      ctx.beginPath();
      ctx.ellipse(0, -e.r * 0.4, e.r * 0.4, e.r * 0.35, Math.sin(state.time) * 0.1, 0, TAU);
      ctx.fill();
      
      // Glowing demonic eyes
      const eyeGlow = ctx.createRadialGradient(-e.r * 0.15, -e.r * 0.5, 0, -e.r * 0.15, -e.r * 0.5, e.r * 0.12);
      eyeGlow.addColorStop(0, '#ff0000');
      eyeGlow.addColorStop(0.5, '#ff4444');
      eyeGlow.addColorStop(1, 'rgba(255,0,0,0.3)');
      ctx.fillStyle = eyeGlow;
      ctx.beginPath();
      ctx.arc(-e.r * 0.15, -e.r * 0.5, e.r * 0.12, 0, TAU);
      ctx.fill();
      ctx.beginPath();
      ctx.arc(e.r * 0.15, -e.r * 0.5, e.r * 0.12, 0, TAU);
      ctx.fill();
      
      // Eye pupils - black voids
      ctx.fillStyle = '#000000';
      ctx.beginPath();
      ctx.arc(-e.r * 0.15, -e.r * 0.5, e.r * 0.06, 0, TAU);
      ctx.fill();
      ctx.beginPath();
      ctx.arc(e.r * 0.15, -e.r * 0.5, e.r * 0.06, 0, TAU);
      ctx.fill();
      
      // Jagged mouth with sharp teeth
      ctx.fillStyle = '#000000';
      ctx.beginPath();
      ctx.moveTo(-e.r * 0.2, -e.r * 0.2);
      ctx.lineTo(-e.r * 0.1, -e.r * 0.1);
      ctx.lineTo(0, -e.r * 0.15);
      ctx.lineTo(e.r * 0.1, -e.r * 0.1);
      ctx.lineTo(e.r * 0.2, -e.r * 0.2);
      ctx.closePath();
      ctx.fill();
      
      // Sharp irregular teeth
      ctx.fillStyle = '#ffffff';
      for (let i = 0; i < 7; i++) {
        const x = (i - 3) * e.r * 0.06;
        const y = -e.r * 0.12 + Math.sin(i) * e.r * 0.02;
        const size = e.r * 0.02 + Math.sin(state.time * 4 + i) * e.r * 0.01;
        ctx.beginPath();
        ctx.arc(x, y, size, 0, TAU);
        ctx.fill();
      }
      
      // Twisted arms reaching out
      ctx.fillStyle = '#2a1a0a';
      ctx.beginPath();
      ctx.ellipse(-e.r * 0.8, -e.r * 0.2, e.r * 0.15, e.r * 0.1, Math.sin(state.time * 2) * 0.3, 0, TAU);
      ctx.fill();
      ctx.beginPath();
      ctx.ellipse(e.r * 0.8, -e.r * 0.2, e.r * 0.15, e.r * 0.1, Math.sin(state.time * 2 + 1) * 0.3, 0, TAU);
      ctx.fill();
      
      // Clawed hands
      ctx.fillStyle = '#1a0a0a';
      for (let i = 0; i < 4; i++) {
        const angle = (i - 1.5) * 0.4;
        const x = -e.r * 0.8 + Math.cos(angle) * e.r * 0.1;
        const y = -e.r * 0.2 + Math.sin(angle) * e.r * 0.1;
        ctx.beginPath();
        ctx.arc(x, y, e.r * 0.03, 0, TAU);
        ctx.fill();
        
        const x2 = e.r * 0.8 + Math.cos(angle) * e.r * 0.1;
        ctx.beginPath();
        ctx.arc(x2, y, e.r * 0.03, 0, TAU);
        ctx.fill();
      }
      
      // Decayed clothing remnants
      ctx.fillStyle = '#1a1a1a';
      ctx.fillRect(-e.r * 0.6, -e.r * 0.3, e.r * 1.2, e.r * 0.2);
      ctx.fillRect(-e.r * 0.4, -e.r * 0.1, e.r * 0.8, e.r * 0.1);
      
      // Blood drips
      ctx.fillStyle = '#8b0000';
      for (let i = 0; i < 3; i++) {
        const x = (i - 1) * e.r * 0.2;
        const y = -e.r * 0.3 + Math.sin(state.time * 3 + i) * e.r * 0.05;
        ctx.beginPath();
        ctx.arc(x, y, e.r * 0.02, 0, TAU);
        ctx.fill();
      }
      
    } else if (e.type === 'brute') {
      // Cute but intimidating brute - muscular with armor
      const bodyGrad = ctx.createRadialGradient(0, 0, 0, 0, 0, e.r);
      bodyGrad.addColorStop(0, '#6a4c4c');
      bodyGrad.addColorStop(1, '#4a2c2c');
      ctx.fillStyle = bodyGrad;
      roundRect(-e.r, -e.r*0.8, e.r*2, e.r*1.6, e.r*0.5); ctx.fill();
      
      // Muscular details
      ctx.fillStyle = '#5a3c3c';
      ctx.fillRect(-e.r*0.7, -e.r*0.5, e.r*1.4, e.r*1.0);
      
      // Spiked armor with cute but scary design
      const armorGrad = ctx.createLinearGradient(-e.r, -e.r*0.8, -e.r, e.r*0.8);
      armorGrad.addColorStop(0, '#4a3a3a');
      armorGrad.addColorStop(1, '#2a1a1a');
      ctx.fillStyle = armorGrad;
      for (let i = 0; i < 6; i++) {
        const x = -e.r + (e.r*2 * i / 5);
        ctx.fillRect(x, -e.r*0.8, 4, e.r*1.6);
      }
      
      // Armor plates
      ctx.fillStyle = '#2a1a1a';
      ctx.fillRect(-e.r*0.8, -e.r*0.6, e.r*1.6, e.r*0.4);
      ctx.fillRect(-e.r*0.8, e.r*0.2, e.r*1.6, e.r*0.4);
      
      // Cute but fierce head
      const headGrad = ctx.createRadialGradient(e.r*0.4, -e.r*0.3, 0, e.r*0.4, -e.r*0.3, e.r*0.5);
      headGrad.addColorStop(0, '#5a2a2a');
      headGrad.addColorStop(1, '#3a1a1a');
      ctx.fillStyle = headGrad;
      ctx.beginPath();
      ctx.arc(e.r*0.4, -e.r*0.3, e.r*0.5, 0, TAU);
      ctx.fill();
      
      // Cute horns
      const hornGrad = ctx.createLinearGradient(e.r*0.2, -e.r*0.6, e.r*0.2, -e.r*0.6 + 8);
      hornGrad.addColorStop(0, '#3a1a1a');
      hornGrad.addColorStop(1, '#1a0a0a');
      ctx.fillStyle = hornGrad;
      ctx.fillRect(e.r*0.2, -e.r*0.6, 4, 8);
      ctx.fillRect(e.r*0.6, -e.r*0.6, 4, 8);
      
      // Cute but scary red eyes
      const eyeGlow = ctx.createRadialGradient(e.r*0.6, -e.r*0.4, 0, e.r*0.6, -e.r*0.4, 7);
      eyeGlow.addColorStop(0, '#ff4444');
      eyeGlow.addColorStop(1, 'rgba(255,68,68,0)');
      ctx.fillStyle = eyeGlow;
      ctx.beginPath();
      ctx.arc(e.r*0.6, -e.r*0.4, 7, 0, TAU);
      ctx.fill();
      ctx.beginPath();
      ctx.arc(e.r*0.6, -e.r*0.2, 7, 0, TAU);
      ctx.fill();
      
      // Bright eye cores
      ctx.fillStyle = '#ffffff';
      ctx.beginPath();
      ctx.arc(e.r*0.6, -e.r*0.4, 2.5, 0, TAU);
      ctx.fill();
      ctx.beginPath();
      ctx.arc(e.r*0.6, -e.r*0.2, 2.5, 0, TAU);
      ctx.fill();
      
      // Cute armor spikes
      ctx.fillStyle = '#2a1a1a';
      for (let i = 0; i < 3; i++) {
        const x = -e.r*0.5 + i * e.r*0.5;
        ctx.fillRect(x, -e.r*0.9, 2, 4);
      }
      
    } else if (e.type === 'spitter') {
      // Cute but gross spitter - bloated with acid
      ctx.fillStyle = '#5a3c5a';
      roundRect(-e.r, -e.r*0.8, e.r*2, e.r*1.6, e.r*0.5); ctx.fill();
      
      // Bloated body with cute details
      ctx.fillStyle = '#4a2c4a';
      ctx.beginPath();
      ctx.arc(0, 0, e.r*0.8, 0, TAU);
      ctx.fill();
      
      // Cute multiple eyes
      ctx.fillStyle = '#ff88ff';
      for (let i = 0; i < 3; i++) {
        ctx.beginPath();
        ctx.arc(e.r*0.5 + i*4, -e.r*0.3, 3, 0, TAU);
        ctx.fill();
      }
      
      // Cute acid sacs
      ctx.fillStyle = '#88ff88';
      ctx.beginPath();
      ctx.arc(-e.r*0.3, 0, 6, 0, TAU);
      ctx.fill();
      ctx.beginPath();
      ctx.arc(e.r*0.3, 0, 6, 0, TAU);
      ctx.fill();
      
      // Cute mouth
      ctx.fillStyle = '#ff88ff';
      ctx.beginPath();
      ctx.arc(e.r*0.4, -e.r*0.1, 3, 0, TAU);
      ctx.fill();
      
    } else if (e.type === 'charger') {
      // Cute but fast charger - streamlined design
      ctx.fillStyle = '#3c5a3c';
      roundRect(-e.r, -e.r*0.8, e.r*2, e.r*1.6, e.r*0.5); ctx.fill();
      
      // Streamlined body
      ctx.fillStyle = '#2a4a2a';
      ctx.fillRect(-e.r*0.8, -e.r*0.6, e.r*1.6, e.r*1.2);
      
      // Cute charging horns
      ctx.fillStyle = '#2a2a2a';
      ctx.fillRect(e.r*0.3, -e.r*0.8, 6, 10);
      ctx.fillRect(e.r*0.5, -e.r*0.8, 6, 10);
      
      // Cute yellow eyes
      ctx.fillStyle = '#ffff88';
      ctx.beginPath();
      ctx.arc(e.r*0.6, -e.r*0.4, 4, 0, TAU);
      ctx.fill();
      ctx.beginPath();
      ctx.arc(e.r*0.6, -e.r*0.2, 4, 0, TAU);
      ctx.fill();
      
      // Cute mouth
      ctx.fillStyle = '#ffff44';
      ctx.beginPath();
      ctx.arc(e.r*0.4, -e.r*0.1, 2, 0, TAU);
      ctx.fill();
      
    } else if (e.type === 'boss') {
      // Enhanced boss design - massive armored zombie
      const bossGrad = ctx.createRadialGradient(0, 0, 0, 0, 0, e.r);
      bossGrad.addColorStop(0, '#2a0a0a');
      bossGrad.addColorStop(1, '#1a0a0a');
      ctx.fillStyle = bossGrad;
      roundRect(-e.r, -e.r*0.8, e.r*2, e.r*1.6, e.r*0.5); ctx.fill();
      
      // Enhanced armor plates with metallic finish
      const armorGrad = ctx.createLinearGradient(-e.r, -e.r*0.8, -e.r, e.r*0.8);
      armorGrad.addColorStop(0, '#3a2a2a');
      armorGrad.addColorStop(1, '#2a1a1a');
      ctx.fillStyle = armorGrad;
      for (let i = 0; i < 8; i++) {
        const x = -e.r + (e.r*2 * i / 7);
        ctx.fillRect(x, -e.r*0.8, 5, e.r*1.6);
      }
      
      // Armor spikes and details
      ctx.fillStyle = '#1a0a0a';
      for (let i = 0; i < 5; i++) {
        const x = -e.r*0.8 + i * e.r*0.4;
        ctx.fillRect(x, -e.r*0.9, 3, 8);
        ctx.fillRect(x, e.r*0.7, 3, 8);
      }
      
      // Enhanced massive head with crown
      const headGrad = ctx.createRadialGradient(e.r*0.4, -e.r*0.3, 0, e.r*0.4, -e.r*0.3, e.r*0.6);
      headGrad.addColorStop(0, '#1a0a0a');
      headGrad.addColorStop(1, '#0a0a0a');
      ctx.fillStyle = headGrad;
      ctx.beginPath();
      ctx.arc(e.r*0.4, -e.r*0.3, e.r*0.6, 0, TAU);
      ctx.fill();
      
      // Boss crown/helmet
      ctx.fillStyle = '#ffaa00';
      ctx.fillRect(e.r*0.1, -e.r*0.9, e.r*0.6, e.r*0.2);
      ctx.fillStyle = '#ff8800';
      ctx.fillRect(e.r*0.2, -e.r*1.0, e.r*0.4, e.r*0.1);
      
      // Enhanced multiple horns with metallic look
      const hornGrad = ctx.createLinearGradient(0, -e.r*0.3, 0, -e.r*0.3 + 12);
      hornGrad.addColorStop(0, '#2a1a1a');
      hornGrad.addColorStop(1, '#1a1a1a');
      ctx.fillStyle = hornGrad;
      for (let i = 0; i < 5; i++) {
        const angle = (i / 5) * TAU;
        const hornX = e.r*0.4 + Math.cos(angle) * e.r*0.8;
        const hornY = -e.r*0.3 + Math.sin(angle) * e.r*0.8;
        ctx.fillRect(hornX-3, hornY-6, 6, 15);
      }
      
      // Enhanced glowing red eyes with pulsing effect
      const pulse = Math.sin(state.time * 6) * 0.3 + 0.7;
      const eyeGlow = ctx.createRadialGradient(e.r*0.6, -e.r*0.4, 0, e.r*0.6, -e.r*0.4, 12);
      eyeGlow.addColorStop(0, `rgba(255,0,0,${pulse})`);
      eyeGlow.addColorStop(1, 'rgba(255,0,0,0)');
      ctx.fillStyle = eyeGlow;
      ctx.beginPath();
      ctx.arc(e.r*0.6, -e.r*0.4, 12, 0, TAU);
      ctx.fill();
      ctx.beginPath();
      ctx.arc(e.r*0.6, -e.r*0.2, 12, 0, TAU);
      ctx.fill();
      
      // Bright eye cores
      ctx.fillStyle = '#ffffff';
      ctx.beginPath();
      ctx.arc(e.r*0.6, -e.r*0.4, 4, 0, TAU);
      ctx.fill();
      ctx.beginPath();
      ctx.arc(e.r*0.6, -e.r*0.2, 4, 0, TAU);
      ctx.fill();
      
      // Enhanced phase indicator with pulsing
      if (e.phase === 1) {
        const phasePulse = Math.sin(state.time * 8) * 0.4 + 0.6;
        ctx.fillStyle = `rgba(255,0,0,${phasePulse * 0.4})`;
        ctx.beginPath();
        ctx.arc(0, 0, e.r*1.4, 0, TAU);
        ctx.fill();
      }
      
      // Boss aura
      ctx.globalAlpha = 0.2;
      ctx.fillStyle = '#ff0000';
      ctx.beginPath();
      ctx.arc(0, 0, e.r*1.2, 0, TAU);
      ctx.fill();
      ctx.globalAlpha = 1;
    } else if (e.type === 'necromancer') {
      // Necromancer boss - dark magic user
      const necroGrad = ctx.createRadialGradient(0, 0, 0, 0, 0, e.r);
      necroGrad.addColorStop(0, '#4a2a4a');
      necroGrad.addColorStop(1, '#2a1a2a');
      ctx.fillStyle = necroGrad;
      roundRect(-e.r, -e.r*0.8, e.r*2, e.r*1.6, e.r*0.5); ctx.fill();
      
      // Dark robes
      ctx.fillStyle = '#3a1a3a';
      ctx.fillRect(-e.r*0.8, -e.r*0.6, e.r*1.6, e.r*1.2);
      
      // Hooded head
      const headGrad = ctx.createRadialGradient(e.r*0.4, -e.r*0.3, 0, e.r*0.4, -e.r*0.3, e.r*0.5);
      headGrad.addColorStop(0, '#2a1a2a');
      headGrad.addColorStop(1, '#1a0a1a');
      ctx.fillStyle = headGrad;
      ctx.beginPath();
      ctx.arc(e.r*0.4, -e.r*0.3, e.r*0.5, 0, TAU);
      ctx.fill();
      
      // Hood
      ctx.fillStyle = '#1a0a1a';
      ctx.fillRect(e.r*0.1, -e.r*0.8, e.r*0.6, e.r*0.3);
      
      // Glowing purple eyes
      const eyeGlow = ctx.createRadialGradient(e.r*0.6, -e.r*0.4, 0, e.r*0.6, -e.r*0.4, 10);
      eyeGlow.addColorStop(0, '#8b00ff');
      eyeGlow.addColorStop(1, 'rgba(139,0,255,0)');
      ctx.fillStyle = eyeGlow;
      ctx.beginPath();
      ctx.arc(e.r*0.6, -e.r*0.4, 10, 0, TAU);
      ctx.fill();
      ctx.beginPath();
      ctx.arc(e.r*0.6, -e.r*0.2, 10, 0, TAU);
      ctx.fill();
      
      // Bright eye cores
      ctx.fillStyle = '#ffffff';
      ctx.beginPath();
      ctx.arc(e.r*0.6, -e.r*0.4, 3, 0, TAU);
      ctx.fill();
      ctx.beginPath();
      ctx.arc(e.r*0.6, -e.r*0.2, 3, 0, TAU);
      ctx.fill();
      
      // Staff
      ctx.fillStyle = '#2a1a2a';
      ctx.fillRect(e.r*0.8, -e.r*0.4, 20, 8);
      ctx.fillStyle = '#8b00ff';
      ctx.beginPath();
      ctx.arc(e.r*1.0, -e.r*0.4, 6, 0, TAU);
      ctx.fill();
      
      // Magic aura
      ctx.globalAlpha = 0.3;
      ctx.fillStyle = '#8b00ff';
      ctx.beginPath();
      ctx.arc(0, 0, e.r*1.3, 0, TAU);
      ctx.fill();
      ctx.globalAlpha = 1;
      
    } else if (e.type === 'titan') {
      // Titan boss - massive stone golem
      const titanGrad = ctx.createRadialGradient(0, 0, 0, 0, 0, e.r);
      titanGrad.addColorStop(0, '#6a5a4a');
      titanGrad.addColorStop(1, '#4a3a2a');
      ctx.fillStyle = titanGrad;
      roundRect(-e.r, -e.r*0.8, e.r*2, e.r*1.6, e.r*0.5); ctx.fill();
      
      // Stone armor plates
      const armorGrad = ctx.createLinearGradient(-e.r, -e.r*0.8, -e.r, e.r*0.8);
      armorGrad.addColorStop(0, '#5a4a3a');
      armorGrad.addColorStop(1, '#3a2a1a');
      ctx.fillStyle = armorGrad;
      for (let i = 0; i < 10; i++) {
        const x = -e.r + (e.r*2 * i / 9);
        ctx.fillRect(x, -e.r*0.8, 6, e.r*1.6);
      }
      
      // Massive stone head
      const headGrad = ctx.createRadialGradient(e.r*0.4, -e.r*0.3, 0, e.r*0.4, -e.r*0.3, e.r*0.7);
      headGrad.addColorStop(0, '#4a3a2a');
      headGrad.addColorStop(1, '#2a1a0a');
      ctx.fillStyle = headGrad;
      ctx.beginPath();
      ctx.arc(e.r*0.4, -e.r*0.3, e.r*0.7, 0, TAU);
      ctx.fill();
      
      // Stone crown
      ctx.fillStyle = '#ffaa00';
      ctx.fillRect(e.r*0.1, -e.r*1.0, e.r*0.6, e.r*0.3);
      ctx.fillStyle = '#ff8800';
      ctx.fillRect(e.r*0.2, -e.r*1.1, e.r*0.4, e.r*0.1);
      
      // Glowing orange eyes
      const eyeGlow = ctx.createRadialGradient(e.r*0.6, -e.r*0.4, 0, e.r*0.6, -e.r*0.4, 15);
      eyeGlow.addColorStop(0, '#ff8800');
      eyeGlow.addColorStop(1, 'rgba(255,136,0,0)');
      ctx.fillStyle = eyeGlow;
      ctx.beginPath();
      ctx.arc(e.r*0.6, -e.r*0.4, 15, 0, TAU);
      ctx.fill();
      ctx.beginPath();
      ctx.arc(e.r*0.6, -e.r*0.2, 15, 0, TAU);
      ctx.fill();
      
      // Bright eye cores
      ctx.fillStyle = '#ffffff';
      ctx.beginPath();
      ctx.arc(e.r*0.6, -e.r*0.4, 5, 0, TAU);
      ctx.fill();
      ctx.beginPath();
      ctx.arc(e.r*0.6, -e.r*0.2, 5, 0, TAU);
      ctx.fill();
      
      // Stone fists
      ctx.fillStyle = '#3a2a1a';
      ctx.fillRect(e.r*0.8, -e.r*0.6, 15, 12);
      ctx.fillRect(e.r*0.8, e.r*0.2, 15, 12);
      
      // Titan aura
      ctx.globalAlpha = 0.25;
      ctx.fillStyle = '#ff8800';
      ctx.beginPath();
      ctx.arc(0, 0, e.r*1.4, 0, TAU);
      ctx.fill();
      ctx.globalAlpha = 1;
    } else if (e.type === 'minion') {
      // Minion design - smaller zombie
      ctx.fillStyle = '#3a2a2a';
      roundRect(-e.r, -e.r*0.8, e.r*2, e.r*1.6, e.r*0.5); ctx.fill();
      
      // Small head
      ctx.fillStyle = '#2a1a1a';
      ctx.beginPath();
      ctx.arc(e.r*0.4, -e.r*0.3, e.r*0.3, 0, TAU);
      ctx.fill();
      
      // Red eyes
      ctx.fillStyle = '#ff0000';
      ctx.beginPath();
      ctx.arc(e.r*0.6, -e.r*0.4, 3, 0, TAU);
      ctx.fill();
      ctx.beginPath();
      ctx.arc(e.r*0.6, -e.r*0.2, 3, 0, TAU);
      ctx.fill();
    }

    // Stun effect
    if (e.stun > 0) {
      ctx.fillStyle = 'rgba(255,255,255,0.3)';
      ctx.beginPath();
      ctx.arc(0, 0, e.r*1.2, 0, TAU);
      ctx.fill();
    }

    // Health bar
    const hpw = e.r*2;
    ctx.fillStyle = '#0b1118';
    ctx.fillRect(-e.r, -e.r-10, hpw, 4);
    ctx.fillStyle = '#f04747';
    ctx.fillRect(-e.r, -e.r-10, hpw * (e.hp/e.hpMax), 4);

    ctx.restore();
  }

  function drawAlly(a) {
    // Shadow
    ctx.fillStyle = 'rgba(0,0,0,0.35)';
    ctx.beginPath();
    ctx.ellipse(a.x, a.y+8, a.r*0.9, a.r*0.55, 0, 0, TAU);
    ctx.fill();

    ctx.save();
    ctx.translate(a.x, a.y);
    ctx.rotate(a.angle);

    const at = a.animalType;
    
    // Animal body with gradient
    const bodyGrad = ctx.createRadialGradient(0, 0, 0, 0, 0, a.r);
    bodyGrad.addColorStop(0, at.color);
    bodyGrad.addColorStop(1, at.accent);
    ctx.fillStyle = bodyGrad;
    roundRect(-a.r, -a.r*0.8, a.r*2, a.r*1.6, a.r*0.5); ctx.fill();
    
    // Animal-specific details
    if (at.type === 'wolf') {
      // WOLF BODY - Detailed wolf design
      const wolfBodyGrad = ctx.createRadialGradient(0, 0, 0, 0, 0, a.r);
      wolfBodyGrad.addColorStop(0, '#6a5a4a');
      wolfBodyGrad.addColorStop(0.7, '#5a4a3a');
      wolfBodyGrad.addColorStop(1, '#4a3a2a');
      ctx.fillStyle = wolfBodyGrad;
      roundRect(-a.r*0.8, -a.r*0.6, a.r*1.6, a.r*1.2, a.r*0.3);
      ctx.fill();
      
      // Wolf fur texture
      ctx.fillStyle = '#5a4a3a';
      for (let i = 0; i < 8; i++) {
        const angle = (i / 8) * TAU;
        const x = Math.cos(angle) * a.r * 0.6;
        const y = Math.sin(angle) * a.r * 0.4;
        ctx.beginPath();
        ctx.arc(x, y, 2, 0, TAU);
        ctx.fill();
      }
      
      // WOLF HEAD with detailed features
      const wolfHeadGrad = ctx.createRadialGradient(a.r*0.4, -a.r*0.3, 0, a.r*0.4, -a.r*0.3, a.r*0.4);
      wolfHeadGrad.addColorStop(0, '#4a3a2a');
      wolfHeadGrad.addColorStop(1, '#3a2a1a');
      ctx.fillStyle = wolfHeadGrad;
      ctx.beginPath();
      ctx.arc(a.r*0.4, -a.r*0.3, a.r*0.4, 0, TAU);
      ctx.fill();
      
      // Wolf muzzle
      ctx.fillStyle = '#2a1a0a';
      ctx.beginPath();
      ctx.ellipse(a.r*0.6, -a.r*0.2, a.r*0.25, a.r*0.15, 0, 0, TAU);
      ctx.fill();
      
      // Wolf nose
      ctx.fillStyle = '#1a1a1a';
      ctx.beginPath();
      ctx.arc(a.r*0.7, -a.r*0.2, 2, 0, TAU);
      ctx.fill();
      
      // WOLF EARS - Pointed and detailed
      ctx.fillStyle = '#3a2a1a';
      ctx.beginPath();
      ctx.moveTo(a.r*0.2, -a.r*0.7);
      ctx.lineTo(a.r*0.1, -a.r*1.1);
      ctx.lineTo(a.r*0.3, -a.r*1.0);
      ctx.closePath();
      ctx.fill();
      
      ctx.beginPath();
      ctx.moveTo(a.r*0.6, -a.r*0.7);
      ctx.lineTo(a.r*0.5, -a.r*1.1);
      ctx.lineTo(a.r*0.7, -a.r*1.0);
      ctx.closePath();
      ctx.fill();
      
      // Ear highlights
      ctx.fillStyle = '#4a3a2a';
      ctx.beginPath();
      ctx.moveTo(a.r*0.15, -a.r*0.75);
      ctx.lineTo(a.r*0.1, -a.r*1.05);
      ctx.lineTo(a.r*0.25, -a.r*0.95);
      ctx.closePath();
      ctx.fill();
      
      ctx.beginPath();
      ctx.moveTo(a.r*0.55, -a.r*0.75);
      ctx.lineTo(a.r*0.5, -a.r*1.05);
      ctx.lineTo(a.r*0.65, -a.r*0.95);
      ctx.closePath();
      ctx.fill();
      
      // WOLF EYES - Fierce and detailed
      const wolfEyeGrad = ctx.createRadialGradient(a.r*0.2, -a.r*0.3, 0, a.r*0.2, -a.r*0.3, 3);
      wolfEyeGrad.addColorStop(0, '#ffaa00');
      wolfEyeGrad.addColorStop(1, '#ff8800');
      ctx.fillStyle = wolfEyeGrad;
      ctx.beginPath();
      ctx.arc(a.r*0.2, -a.r*0.3, 3, 0, TAU);
      ctx.fill();
      ctx.beginPath();
      ctx.arc(a.r*0.6, -a.r*0.3, 3, 0, TAU);
      ctx.fill();
      
      // Eye pupils
      ctx.fillStyle = '#000000';
      ctx.beginPath();
      ctx.arc(a.r*0.2, -a.r*0.3, 1.5, 0, TAU);
      ctx.fill();
      ctx.beginPath();
      ctx.arc(a.r*0.6, -a.r*0.3, 1.5, 0, TAU);
      ctx.fill();
      
      // Eye highlights
      ctx.fillStyle = '#ffffff';
      ctx.beginPath();
      ctx.arc(a.r*0.18, -a.r*0.32, 0.8, 0, TAU);
      ctx.fill();
      ctx.beginPath();
      ctx.arc(a.r*0.58, -a.r*0.32, 0.8, 0, TAU);
      ctx.fill();
      
      // Wolf teeth
      ctx.fillStyle = '#ffffff';
      ctx.fillRect(a.r*0.65, -a.r*0.15, 1, 2);
      ctx.fillRect(a.r*0.68, -a.r*0.15, 1, 2);
      
      // Wolf tail
      ctx.fillStyle = '#5a4a3a';
      ctx.beginPath();
      ctx.ellipse(-a.r*1.1, 0, a.r*0.3, a.r*0.15, 0, 0, TAU);
      ctx.fill();
      
    } else if (at.type === 'eagle') {
      // EAGLE BODY - Majestic eagle design
      const eagleBodyGrad = ctx.createRadialGradient(0, 0, 0, 0, 0, a.r);
      eagleBodyGrad.addColorStop(0, '#8b4513');
      eagleBodyGrad.addColorStop(0.7, '#7b3513');
      eagleBodyGrad.addColorStop(1, '#6b3513');
      ctx.fillStyle = eagleBodyGrad;
      roundRect(-a.r*0.8, -a.r*0.6, a.r*1.6, a.r*1.2, a.r*0.3);
      ctx.fill();
      
      // Eagle wing feathers
      ctx.fillStyle = '#7b3513';
      for (let i = 0; i < 6; i++) {
        const angle = (i / 6) * TAU;
        const x = Math.cos(angle) * a.r * 0.7;
        const y = Math.sin(angle) * a.r * 0.5;
        ctx.beginPath();
        ctx.arc(x, y, 3, 0, TAU);
        ctx.fill();
      }
      
      // EAGLE HEAD with noble features
      const eagleHeadGrad = ctx.createRadialGradient(a.r*0.4, -a.r*0.3, 0, a.r*0.4, -a.r*0.3, a.r*0.4);
      eagleHeadGrad.addColorStop(0, '#6b3513');
      eagleHeadGrad.addColorStop(1, '#5b2513');
      ctx.fillStyle = eagleHeadGrad;
      ctx.beginPath();
      ctx.arc(a.r*0.4, -a.r*0.3, a.r*0.4, 0, TAU);
      ctx.fill();
      
      // EAGLE BEAK - Sharp and detailed
      const beakGrad = ctx.createLinearGradient(a.r*0.6, -a.r*0.2, a.r*0.8, -a.r*0.2);
      beakGrad.addColorStop(0, '#ffaa00');
      beakGrad.addColorStop(1, '#ff8800');
      ctx.fillStyle = beakGrad;
      ctx.beginPath();
      ctx.moveTo(a.r*0.6, -a.r*0.25);
      ctx.lineTo(a.r*0.8, -a.r*0.2);
      ctx.lineTo(a.r*0.6, -a.r*0.15);
      ctx.closePath();
      ctx.fill();
      
      // Beak highlight
      ctx.fillStyle = '#ffcc44';
      ctx.beginPath();
      ctx.moveTo(a.r*0.62, -a.r*0.23);
      ctx.lineTo(a.r*0.75, -a.r*0.2);
      ctx.lineTo(a.r*0.62, -a.r*0.17);
      ctx.closePath();
      ctx.fill();
      
      // EAGLE EYES - Sharp and focused
      const eagleEyeGrad = ctx.createRadialGradient(a.r*0.2, -a.r*0.3, 0, a.r*0.2, -a.r*0.3, 3);
      eagleEyeGrad.addColorStop(0, '#ff4444');
      eagleEyeGrad.addColorStop(1, '#cc0000');
      ctx.fillStyle = eagleEyeGrad;
      ctx.beginPath();
      ctx.arc(a.r*0.2, -a.r*0.3, 3, 0, TAU);
      ctx.fill();
      ctx.beginPath();
      ctx.arc(a.r*0.6, -a.r*0.3, 3, 0, TAU);
      ctx.fill();
      
      // Eye pupils
      ctx.fillStyle = '#000000';
      ctx.beginPath();
      ctx.arc(a.r*0.2, -a.r*0.3, 1.5, 0, TAU);
      ctx.fill();
      ctx.beginPath();
      ctx.arc(a.r*0.6, -a.r*0.3, 1.5, 0, TAU);
      ctx.fill();
      
      // Eye highlights
      ctx.fillStyle = '#ffffff';
      ctx.beginPath();
      ctx.arc(a.r*0.18, -a.r*0.32, 0.8, 0, TAU);
      ctx.fill();
      ctx.beginPath();
      ctx.arc(a.r*0.58, -a.r*0.32, 0.8, 0, TAU);
      ctx.fill();
      
      // Eagle talons
      ctx.fillStyle = '#ffaa00';
      ctx.beginPath();
      ctx.moveTo(a.r*0.8, a.r*0.3);
      ctx.lineTo(a.r*0.9, a.r*0.4);
      ctx.lineTo(a.r*0.85, a.r*0.35);
      ctx.closePath();
      ctx.fill();
      
      ctx.beginPath();
      ctx.moveTo(a.r*0.8, a.r*0.2);
      ctx.lineTo(a.r*0.9, a.r*0.3);
      ctx.lineTo(a.r*0.85, a.r*0.25);
      ctx.closePath();
      ctx.fill();
      
      // Eagle tail feathers
      ctx.fillStyle = '#7b3513';
      for (let i = 0; i < 3; i++) {
        ctx.fillRect(-a.r*1.2, -a.r*0.1 + i*4, 8, 2);
      }
      
    } else if (at.type === 'bear') {
      // BEAR BODY - Massive and powerful
      const bearBodyGrad = ctx.createRadialGradient(0, 0, 0, 0, 0, a.r);
      bearBodyGrad.addColorStop(0, '#8b4513');
      bearBodyGrad.addColorStop(0.7, '#7b3513');
      bearBodyGrad.addColorStop(1, '#6b3513');
      ctx.fillStyle = bearBodyGrad;
      roundRect(-a.r*0.8, -a.r*0.6, a.r*1.6, a.r*1.2, a.r*0.3);
      ctx.fill();
      
      // Bear fur texture
      ctx.fillStyle = '#7b3513';
      for (let i = 0; i < 10; i++) {
        const angle = (i / 10) * TAU;
        const x = Math.cos(angle) * a.r * 0.6;
        const y = Math.sin(angle) * a.r * 0.4;
        ctx.beginPath();
        ctx.arc(x, y, 3, 0, TAU);
        ctx.fill();
      }
      
      // BEAR HEAD - Large and imposing
      const bearHeadGrad = ctx.createRadialGradient(a.r*0.4, -a.r*0.3, 0, a.r*0.4, -a.r*0.3, a.r*0.5);
      bearHeadGrad.addColorStop(0, '#6b3513');
      bearHeadGrad.addColorStop(1, '#5b2513');
      ctx.fillStyle = bearHeadGrad;
      ctx.beginPath();
      ctx.arc(a.r*0.4, -a.r*0.3, a.r*0.5, 0, TAU);
      ctx.fill();
      
      // BEAR MUZZLE - Wide and strong
      ctx.fillStyle = '#4a2a1a';
      ctx.beginPath();
      ctx.ellipse(a.r*0.5, -a.r*0.15, a.r*0.3, a.r*0.2, 0, 0, TAU);
      ctx.fill();
      
      // Bear nose
      ctx.fillStyle = '#1a1a1a';
      ctx.beginPath();
      ctx.arc(a.r*0.6, -a.r*0.15, 3, 0, TAU);
      ctx.fill();
      
      // BEAR EARS - Round and furry
      ctx.fillStyle = '#4a2a1a';
      ctx.beginPath();
      ctx.arc(a.r*0.1, -a.r*0.8, 4, 0, TAU);
      ctx.fill();
      ctx.beginPath();
      ctx.arc(a.r*0.7, -a.r*0.8, 4, 0, TAU);
      ctx.fill();
      
      // Ear highlights
      ctx.fillStyle = '#5b3513';
      ctx.beginPath();
      ctx.arc(a.r*0.1, -a.r*0.8, 2, 0, TAU);
      ctx.fill();
      ctx.beginPath();
      ctx.arc(a.r*0.7, -a.r*0.8, 2, 0, TAU);
      ctx.fill();
      
      // BEAR EYES - Deep and powerful
      const bearEyeGrad = ctx.createRadialGradient(a.r*0.2, -a.r*0.3, 0, a.r*0.2, -a.r*0.3, 3);
      bearEyeGrad.addColorStop(0, '#000000');
      bearEyeGrad.addColorStop(1, '#1a1a1a');
      ctx.fillStyle = bearEyeGrad;
      ctx.beginPath();
      ctx.arc(a.r*0.2, -a.r*0.3, 3, 0, TAU);
      ctx.fill();
      ctx.beginPath();
      ctx.arc(a.r*0.6, -a.r*0.3, 3, 0, TAU);
      ctx.fill();
      
      // Eye highlights
      ctx.fillStyle = '#ffffff';
      ctx.beginPath();
      ctx.arc(a.r*0.18, -a.r*0.32, 0.8, 0, TAU);
      ctx.fill();
      ctx.beginPath();
      ctx.arc(a.r*0.58, -a.r*0.32, 0.8, 0, TAU);
      ctx.fill();
      
      // Bear claws
      ctx.fillStyle = '#ffaa00';
      for (let i = 0; i < 3; i++) {
        ctx.beginPath();
        ctx.moveTo(a.r*0.8, a.r*0.2 + i*3);
        ctx.lineTo(a.r*0.9, a.r*0.3 + i*3);
        ctx.lineTo(a.r*0.85, a.r*0.25 + i*3);
        ctx.closePath();
        ctx.fill();
      }
      
      // Bear paws
      ctx.fillStyle = '#4a2a1a';
      ctx.beginPath();
      ctx.arc(a.r*0.8, a.r*0.4, 6, 0, TAU);
      ctx.fill();
      ctx.beginPath();
      ctx.arc(a.r*0.8, a.r*0.2, 6, 0, TAU);
      ctx.fill();
      
    } else if (at.type === 'fox') {
      // FOX BODY - Sleek and agile
      const foxBodyGrad = ctx.createRadialGradient(0, 0, 0, 0, 0, a.r);
      foxBodyGrad.addColorStop(0, '#ff6b35');
      foxBodyGrad.addColorStop(0.7, '#e6552a');
      foxBodyGrad.addColorStop(1, '#d4552a');
      ctx.fillStyle = foxBodyGrad;
      roundRect(-a.r*0.8, -a.r*0.6, a.r*1.6, a.r*1.2, a.r*0.3);
      ctx.fill();
      
      // Fox fur texture
      ctx.fillStyle = '#e6552a';
      for (let i = 0; i < 6; i++) {
        const angle = (i / 6) * TAU;
        const x = Math.cos(angle) * a.r * 0.6;
        const y = Math.sin(angle) * a.r * 0.4;
        ctx.beginPath();
        ctx.arc(x, y, 2, 0, TAU);
        ctx.fill();
      }
      
      // FOX HEAD with pointed features
      const foxHeadGrad = ctx.createRadialGradient(a.r*0.4, -a.r*0.3, 0, a.r*0.4, -a.r*0.3, a.r*0.4);
      foxHeadGrad.addColorStop(0, '#d4552a');
      foxHeadGrad.addColorStop(1, '#c4451a');
      ctx.fillStyle = foxHeadGrad;
      ctx.beginPath();
      ctx.arc(a.r*0.4, -a.r*0.3, a.r*0.4, 0, TAU);
      ctx.fill();
      
      // FOX MUZZLE - Pointed and clever
      ctx.fillStyle = '#b4351a';
      ctx.beginPath();
      ctx.ellipse(a.r*0.6, -a.r*0.2, a.r*0.2, a.r*0.1, 0, 0, TAU);
      ctx.fill();
      
      // Fox nose
      ctx.fillStyle = '#1a1a1a';
      ctx.beginPath();
      ctx.arc(a.r*0.7, -a.r*0.2, 1.5, 0, TAU);
      ctx.fill();
      
      // FOX EARS - Pointed and alert
      ctx.fillStyle = '#ff4444';
      ctx.beginPath();
      ctx.moveTo(a.r*0.2, -a.r*0.7);
      ctx.lineTo(a.r*0.15, -a.r*1.0);
      ctx.lineTo(a.r*0.25, -a.r*0.9);
      ctx.closePath();
      ctx.fill();
      
      ctx.beginPath();
      ctx.moveTo(a.r*0.6, -a.r*0.7);
      ctx.lineTo(a.r*0.55, -a.r*1.0);
      ctx.lineTo(a.r*0.65, -a.r*0.9);
      ctx.closePath();
      ctx.fill();
      
      // Ear highlights
      ctx.fillStyle = '#ff6666';
      ctx.beginPath();
      ctx.moveTo(a.r*0.18, -a.r*0.75);
      ctx.lineTo(a.r*0.15, -a.r*0.95);
      ctx.lineTo(a.r*0.22, -a.r*0.85);
      ctx.closePath();
      ctx.fill();
      
      ctx.beginPath();
      ctx.moveTo(a.r*0.58, -a.r*0.75);
      ctx.lineTo(a.r*0.55, -a.r*0.95);
      ctx.lineTo(a.r*0.62, -a.r*0.85);
      ctx.closePath();
      ctx.fill();
      
      // FOX EYES - Clever and bright
      const foxEyeGrad = ctx.createRadialGradient(a.r*0.2, -a.r*0.3, 0, a.r*0.2, -a.r*0.3, 3);
      foxEyeGrad.addColorStop(0, '#ffaa00');
      foxEyeGrad.addColorStop(1, '#ff8800');
      ctx.fillStyle = foxEyeGrad;
      ctx.beginPath();
      ctx.arc(a.r*0.2, -a.r*0.3, 3, 0, TAU);
      ctx.fill();
      ctx.beginPath();
      ctx.arc(a.r*0.6, -a.r*0.3, 3, 0, TAU);
      ctx.fill();
      
      // Eye pupils
      ctx.fillStyle = '#000000';
      ctx.beginPath();
      ctx.arc(a.r*0.2, -a.r*0.3, 1.5, 0, TAU);
      ctx.fill();
      ctx.beginPath();
      ctx.arc(a.r*0.6, -a.r*0.3, 1.5, 0, TAU);
      ctx.fill();
      
      // Eye highlights
      ctx.fillStyle = '#ffffff';
      ctx.beginPath();
      ctx.arc(a.r*0.18, -a.r*0.32, 0.8, 0, TAU);
      ctx.fill();
      ctx.beginPath();
      ctx.arc(a.r*0.58, -a.r*0.32, 0.8, 0, TAU);
      ctx.fill();
      
      // FOX TAIL - Bushy and detailed
      const tailGrad = ctx.createLinearGradient(-a.r*1.2, 0, -a.r*0.8, 0);
      tailGrad.addColorStop(0, '#ff4444');
      tailGrad.addColorStop(1, '#ff6666');
      ctx.fillStyle = tailGrad;
      ctx.beginPath();
      ctx.ellipse(-a.r*1.0, 0, a.r*0.4, a.r*0.2, 0, 0, TAU);
      ctx.fill();
      
      // Tail tip
      ctx.fillStyle = '#ff6666';
      ctx.beginPath();
      ctx.arc(-a.r*1.3, 0, 3, 0, TAU);
      ctx.fill();
      
    } else if (at.type === 'fennec') {
      // FENNEC BODY - Sandy and cute
      const fennecBodyGrad = ctx.createRadialGradient(0, 0, 0, 0, 0, a.r);
      fennecBodyGrad.addColorStop(0, '#f4a460');
      fennecBodyGrad.addColorStop(0.7, '#e6b380');
      fennecBodyGrad.addColorStop(1, '#d49450');
      ctx.fillStyle = fennecBodyGrad;
      roundRect(-a.r*0.8, -a.r*0.6, a.r*1.6, a.r*1.2, a.r*0.3);
      ctx.fill();
      
      // Fennec fur texture
      ctx.fillStyle = '#e6b380';
      for (let i = 0; i < 8; i++) {
        const angle = (i / 8) * TAU;
        const x = Math.cos(angle) * a.r * 0.6;
        const y = Math.sin(angle) * a.r * 0.4;
        ctx.beginPath();
        ctx.arc(x, y, 2, 0, TAU);
        ctx.fill();
      }
      
      // FENNEC HEAD - Small and adorable
      const fennecHeadGrad = ctx.createRadialGradient(a.r*0.4, -a.r*0.3, 0, a.r*0.4, -a.r*0.3, a.r*0.4);
      fennecHeadGrad.addColorStop(0, '#d49450');
      fennecHeadGrad.addColorStop(1, '#c48440');
      ctx.fillStyle = fennecHeadGrad;
      ctx.beginPath();
      ctx.arc(a.r*0.4, -a.r*0.3, a.r*0.4, 0, TAU);
      ctx.fill();
      
      // FENNEC MUZZLE - Tiny and cute
      ctx.fillStyle = '#b47430';
      ctx.beginPath();
      ctx.ellipse(a.r*0.6, -a.r*0.2, a.r*0.15, a.r*0.08, 0, 0, TAU);
      ctx.fill();
      
      // Fennec nose
      ctx.fillStyle = '#1a1a1a';
      ctx.beginPath();
      ctx.arc(a.r*0.65, -a.r*0.2, 1, 0, TAU);
      ctx.fill();
      
      // FENNEC BIG EARS - The main feature!
      const earGrad = ctx.createLinearGradient(0, -a.r*1.2, 0, -a.r*0.2);
      earGrad.addColorStop(0, '#f4a460');
      earGrad.addColorStop(1, '#e6b380');
      ctx.fillStyle = earGrad;
      
      // Left big ear
      ctx.beginPath();
      ctx.moveTo(a.r*0.1, -a.r*0.7);
      ctx.lineTo(a.r*0.05, -a.r*1.4);
      ctx.lineTo(a.r*0.2, -a.r*1.3);
      ctx.lineTo(a.r*0.25, -a.r*0.8);
      ctx.closePath();
      ctx.fill();
      
      // Right big ear
      ctx.beginPath();
      ctx.moveTo(a.r*0.7, -a.r*0.7);
      ctx.lineTo(a.r*0.65, -a.r*1.4);
      ctx.lineTo(a.r*0.8, -a.r*1.3);
      ctx.lineTo(a.r*0.85, -a.r*0.8);
      ctx.closePath();
      ctx.fill();
      
      // Ear highlights
      ctx.fillStyle = '#ffddaa';
      ctx.beginPath();
      ctx.moveTo(a.r*0.12, -a.r*0.75);
      ctx.lineTo(a.r*0.08, -a.r*1.25);
      ctx.lineTo(a.r*0.18, -a.r*1.2);
      ctx.lineTo(a.r*0.22, -a.r*0.75);
      ctx.closePath();
      ctx.fill();
      
      ctx.beginPath();
      ctx.moveTo(a.r*0.72, -a.r*0.75);
      ctx.lineTo(a.r*0.68, -a.r*1.25);
      ctx.lineTo(a.r*0.78, -a.r*1.2);
      ctx.lineTo(a.r*0.82, -a.r*0.75);
      ctx.closePath();
      ctx.fill();
      
      // FENNEC EYES - Big and adorable
      const fennecEyeGrad = ctx.createRadialGradient(a.r*0.2, -a.r*0.3, 0, a.r*0.2, -a.r*0.3, 3);
      fennecEyeGrad.addColorStop(0, '#000000');
      fennecEyeGrad.addColorStop(1, '#1a1a1a');
      ctx.fillStyle = fennecEyeGrad;
      ctx.beginPath();
      ctx.arc(a.r*0.2, -a.r*0.3, 3, 0, TAU);
      ctx.fill();
      ctx.beginPath();
      ctx.arc(a.r*0.6, -a.r*0.3, 3, 0, TAU);
      ctx.fill();
      
      // Eye highlights
      ctx.fillStyle = '#ffffff';
      ctx.beginPath();
      ctx.arc(a.r*0.18, -a.r*0.32, 1.2, 0, TAU);
      ctx.fill();
      ctx.beginPath();
      ctx.arc(a.r*0.58, -a.r*0.32, 1.2, 0, TAU);
      ctx.fill();
      
      // FENNEC TAIL - Bushy and sandy
      const tailGrad = ctx.createLinearGradient(-a.r*1.2, 0, -a.r*0.8, 0);
      tailGrad.addColorStop(0, '#d49450');
      tailGrad.addColorStop(1, '#e6b380');
      ctx.fillStyle = tailGrad;
      ctx.beginPath();
      ctx.ellipse(-a.r*1.0, 0, a.r*0.3, a.r*0.15, 0, 0, TAU);
      ctx.fill();
      
      // Tail tip
      ctx.fillStyle = '#e6b380';
      ctx.beginPath();
      ctx.arc(-a.r*1.25, 0, 2, 0, TAU);
      ctx.fill();
      
    } else if (at.type === 'owl') {
      // OWL BODY - Mysterious and wise
      const owlBodyGrad = ctx.createRadialGradient(0, 0, 0, 0, 0, a.r);
      owlBodyGrad.addColorStop(0, '#4a4a6a');
      owlBodyGrad.addColorStop(0.7, '#3a3a5a');
      owlBodyGrad.addColorStop(1, '#2a2a4a');
      ctx.fillStyle = owlBodyGrad;
      roundRect(-a.r*0.8, -a.r*0.6, a.r*1.6, a.r*1.2, a.r*0.3);
      ctx.fill();
      
      // Owl feather texture
      ctx.fillStyle = '#3a3a5a';
      for (let i = 0; i < 12; i++) {
        const angle = (i / 12) * TAU;
        const x = Math.cos(angle) * a.r * 0.6;
        const y = Math.sin(angle) * a.r * 0.4;
        ctx.beginPath();
        ctx.arc(x, y, 2, 0, TAU);
        ctx.fill();
      }
      
      // OWL HEAD - Large and round
      const owlHeadGrad = ctx.createRadialGradient(a.r*0.4, -a.r*0.3, 0, a.r*0.4, -a.r*0.3, a.r*0.5);
      owlHeadGrad.addColorStop(0, '#2a2a4a');
      owlHeadGrad.addColorStop(1, '#1a1a3a');
      ctx.fillStyle = owlHeadGrad;
      ctx.beginPath();
      ctx.arc(a.r*0.4, -a.r*0.3, a.r*0.5, 0, TAU);
      ctx.fill();
      
      // OWL FACE DISK - Characteristic owl feature
      ctx.fillStyle = '#3a3a5a';
      ctx.beginPath();
      ctx.ellipse(a.r*0.4, -a.r*0.3, a.r*0.4, a.r*0.3, 0, 0, TAU);
      ctx.fill();
      
      // OWL EYES - Large and mesmerizing
      const owlEyeGrad = ctx.createRadialGradient(a.r*0.2, -a.r*0.3, 0, a.r*0.2, -a.r*0.3, 4);
      owlEyeGrad.addColorStop(0, '#ffaa00');
      owlEyeGrad.addColorStop(1, '#ff8800');
      ctx.fillStyle = owlEyeGrad;
      ctx.beginPath();
      ctx.arc(a.r*0.2, -a.r*0.3, 4, 0, TAU);
      ctx.fill();
      ctx.beginPath();
      ctx.arc(a.r*0.6, -a.r*0.3, 4, 0, TAU);
      ctx.fill();
      
      // Eye pupils
      ctx.fillStyle = '#000000';
      ctx.beginPath();
      ctx.arc(a.r*0.2, -a.r*0.3, 2, 0, TAU);
      ctx.fill();
      ctx.beginPath();
      ctx.arc(a.r*0.6, -a.r*0.3, 2, 0, TAU);
      ctx.fill();
      
      // Eye highlights
      ctx.fillStyle = '#ffffff';
      ctx.beginPath();
      ctx.arc(a.r*0.18, -a.r*0.32, 1, 0, TAU);
      ctx.fill();
      ctx.beginPath();
      ctx.arc(a.r*0.58, -a.r*0.32, 1, 0, TAU);
      ctx.fill();
      
      // OWL BEAK - Sharp and curved
      const beakGrad = ctx.createLinearGradient(a.r*0.4, -a.r*0.1, a.r*0.5, -a.r*0.1);
      beakGrad.addColorStop(0, '#ffaa00');
      beakGrad.addColorStop(1, '#ff8800');
      ctx.fillStyle = beakGrad;
      ctx.beginPath();
      ctx.moveTo(a.r*0.4, -a.r*0.15);
      ctx.lineTo(a.r*0.5, -a.r*0.1);
      ctx.lineTo(a.r*0.4, -a.r*0.05);
      ctx.closePath();
      ctx.fill();
      
      // Beak highlight
      ctx.fillStyle = '#ffcc44';
      ctx.beginPath();
      ctx.moveTo(a.r*0.42, -a.r*0.13);
      ctx.lineTo(a.r*0.48, -a.r*0.1);
      ctx.lineTo(a.r*0.42, -a.r*0.07);
      ctx.closePath();
      ctx.fill();
      
      // OWL EARS - Small and hidden
      ctx.fillStyle = '#1a1a3a';
      ctx.beginPath();
      ctx.arc(a.r*0.2, -a.r*0.8, 2, 0, TAU);
      ctx.fill();
      ctx.beginPath();
      ctx.arc(a.r*0.6, -a.r*0.8, 2, 0, TAU);
      ctx.fill();
      
      // OWL WINGS - Detailed feathers
      ctx.fillStyle = '#3a3a5a';
      for (let i = 0; i < 4; i++) {
        ctx.fillRect(-a.r*0.6, -a.r*0.3 + i*3, 6, 2);
      }
      
      // OWL TAIL - Short and rounded
      ctx.fillStyle = '#2a2a4a';
      ctx.beginPath();
      ctx.ellipse(-a.r*1.0, 0, a.r*0.25, a.r*0.15, 0, 0, TAU);
      ctx.fill();
    } else if (at.type === 'dolphin') {
      // DOLPHIN BODY - Sleek and aquatic
      const dolphinBodyGrad = ctx.createRadialGradient(0, 0, 0, 0, 0, a.r);
      dolphinBodyGrad.addColorStop(0, '#4a90e2');
      dolphinBodyGrad.addColorStop(0.7, '#357abd');
      dolphinBodyGrad.addColorStop(1, '#2a6aad');
      ctx.fillStyle = dolphinBodyGrad;
      roundRect(-a.r*0.8, -a.r*0.6, a.r*1.6, a.r*1.2, a.r*0.3);
      ctx.fill();
      
      // Dolphin skin texture
      ctx.fillStyle = '#357abd';
      for (let i = 0; i < 6; i++) {
        const angle = (i / 6) * TAU;
        const x = Math.cos(angle) * a.r * 0.5;
        const y = Math.sin(angle) * a.r * 0.3;
        ctx.beginPath();
        ctx.arc(x, y, 1.5, 0, TAU);
        ctx.fill();
      }
      
      // DOLPHIN HEAD - Streamlined and intelligent
      const dolphinHeadGrad = ctx.createRadialGradient(a.r*0.3, -a.r*0.2, 0, a.r*0.3, -a.r*0.2, a.r*0.3);
      dolphinHeadGrad.addColorStop(0, '#4a90e2');
      dolphinHeadGrad.addColorStop(1, '#357abd');
      ctx.fillStyle = dolphinHeadGrad;
      ctx.beginPath();
      ctx.ellipse(a.r*0.3, -a.r*0.2, a.r*0.3, a.r*0.25, 0, 0, TAU);
      ctx.fill();
      
      // Dolphin beak
      ctx.fillStyle = '#ffffff';
      ctx.beginPath();
      ctx.ellipse(a.r*0.6, -a.r*0.2, a.r*0.15, a.r*0.08, 0, 0, TAU);
      ctx.fill();
      
      // Dolphin eyes - Intelligent and caring
      ctx.fillStyle = '#000000';
      ctx.beginPath();
      ctx.arc(a.r*0.4, -a.r*0.25, a.r*0.04, 0, TAU);
      ctx.fill();
      ctx.beginPath();
      ctx.arc(a.r*0.2, -a.r*0.25, a.r*0.04, 0, TAU);
      ctx.fill();
      
      // Eye highlights
      ctx.fillStyle = '#ffffff';
      ctx.beginPath();
      ctx.arc(a.r*0.38, -a.r*0.27, 1, 0, TAU);
      ctx.fill();
      ctx.beginPath();
      ctx.arc(a.r*0.18, -a.r*0.27, 1, 0, TAU);
      ctx.fill();
      
      // DOLPHIN FIN - Graceful dorsal fin
      ctx.fillStyle = '#2a6aad';
      ctx.beginPath();
      ctx.moveTo(0, -a.r*0.3);
      ctx.lineTo(-a.r*0.1, -a.r*0.5);
      ctx.lineTo(a.r*0.1, -a.r*0.5);
      ctx.closePath();
      ctx.fill();
      
      // DOLPHIN FLIPPERS - Smooth and hydrodynamic
      ctx.fillStyle = '#2a6aad';
      ctx.beginPath();
      ctx.ellipse(-a.r*0.4, a.r*0.2, a.r*0.15, a.r*0.08, Math.sin(state.time * 3) * 0.3, 0, TAU);
      ctx.fill();
      ctx.beginPath();
      ctx.ellipse(a.r*0.4, a.r*0.2, a.r*0.15, a.r*0.08, Math.sin(state.time * 3 + 1) * 0.3, 0, TAU);
      ctx.fill();
      
      // DOLPHIN TAIL - Powerful fluke
      ctx.fillStyle = '#2a6aad';
      ctx.beginPath();
      ctx.moveTo(-a.r*0.3, a.r*0.3);
      ctx.lineTo(-a.r*0.5, a.r*0.5);
      ctx.lineTo(-a.r*0.3, a.r*0.4);
      ctx.closePath();
      ctx.fill();
      ctx.beginPath();
      ctx.moveTo(a.r*0.3, a.r*0.3);
      ctx.lineTo(a.r*0.5, a.r*0.5);
      ctx.lineTo(a.r*0.3, a.r*0.4);
      ctx.closePath();
      ctx.fill();
      
      // Medic cross symbol
      ctx.fillStyle = '#ffffff';
      ctx.font = 'bold 12px Arial';
      ctx.textAlign = 'center';
      ctx.fillText('‚úö', 0, a.r * 0.1);
    } else if (at.type === 'dog') {
      // DOG BODY - Loyal and protective
      const dogBodyGrad = ctx.createRadialGradient(0, 0, 0, 0, 0, a.r);
      dogBodyGrad.addColorStop(0, '#8b7355');
      dogBodyGrad.addColorStop(0.7, '#7b6345');
      dogBodyGrad.addColorStop(1, '#6b5335');
      ctx.fillStyle = dogBodyGrad;
      roundRect(-a.r*0.8, -a.r*0.6, a.r*1.6, a.r*1.2, a.r*0.3);
      ctx.fill();
      
      // Dog fur texture
      ctx.fillStyle = '#7b6345';
      for (let i = 0; i < 10; i++) {
        const angle = (i / 10) * TAU;
        const x = Math.cos(angle) * a.r * 0.6;
        const y = Math.sin(angle) * a.r * 0.4;
        ctx.beginPath();
        ctx.arc(x, y, 2, 0, TAU);
        ctx.fill();
      }
      
      // DOG HEAD - Friendly and alert
      const dogHeadGrad = ctx.createRadialGradient(a.r*0.4, -a.r*0.3, 0, a.r*0.4, -a.r*0.3, a.r*0.4);
      dogHeadGrad.addColorStop(0, '#6b5335');
      dogHeadGrad.addColorStop(1, '#5b4325');
      ctx.fillStyle = dogHeadGrad;
      ctx.beginPath();
      ctx.arc(a.r*0.4, -a.r*0.3, a.r*0.4, 0, TAU);
      ctx.fill();
      
      // DOG MUZZLE - Friendly and rounded
      ctx.fillStyle = '#4a3a2a';
      ctx.beginPath();
      ctx.ellipse(a.r*0.6, -a.r*0.2, a.r*0.25, a.r*0.15, 0, 0, TAU);
      ctx.fill();
      
      // Dog nose
      ctx.fillStyle = '#1a1a1a';
      ctx.beginPath();
      ctx.arc(a.r*0.7, -a.r*0.2, 2, 0, TAU);
      ctx.fill();
      
      // DOG EARS - Floppy and friendly
      ctx.fillStyle = '#5b4325';
      ctx.beginPath();
      ctx.moveTo(a.r*0.2, -a.r*0.7);
      ctx.lineTo(a.r*0.1, -a.r*0.9);
      ctx.lineTo(a.r*0.3, -a.r*0.8);
      ctx.closePath();
      ctx.fill();
      
      ctx.beginPath();
      ctx.moveTo(a.r*0.6, -a.r*0.7);
      ctx.lineTo(a.r*0.5, -a.r*0.9);
      ctx.lineTo(a.r*0.7, -a.r*0.8);
      ctx.closePath();
      ctx.fill();
      
      // Ear highlights
      ctx.fillStyle = '#6b5335';
      ctx.beginPath();
      ctx.moveTo(a.r*0.15, -a.r*0.75);
      ctx.lineTo(a.r*0.1, -a.r*0.85);
      ctx.lineTo(a.r*0.25, -a.r*0.8);
      ctx.closePath();
      ctx.fill();
      
      ctx.beginPath();
      ctx.moveTo(a.r*0.55, -a.r*0.75);
      ctx.lineTo(a.r*0.5, -a.r*0.85);
      ctx.lineTo(a.r*0.65, -a.r*0.8);
      ctx.closePath();
      ctx.fill();
      
      // DOG EYES - Loyal and caring
      const dogEyeGrad = ctx.createRadialGradient(a.r*0.2, -a.r*0.3, 0, a.r*0.2, -a.r*0.3, 3);
      dogEyeGrad.addColorStop(0, '#4a90e2');
      dogEyeGrad.addColorStop(1, '#357abd');
      ctx.fillStyle = dogEyeGrad;
      ctx.beginPath();
      ctx.arc(a.r*0.2, -a.r*0.3, 3, 0, TAU);
      ctx.fill();
      ctx.beginPath();
      ctx.arc(a.r*0.6, -a.r*0.3, 3, 0, TAU);
      ctx.fill();
      
      // Eye pupils
      ctx.fillStyle = '#000000';
      ctx.beginPath();
      ctx.arc(a.r*0.2, -a.r*0.3, 1.5, 0, TAU);
      ctx.fill();
      ctx.beginPath();
      ctx.arc(a.r*0.6, -a.r*0.3, 1.5, 0, TAU);
      ctx.fill();
      
      // Eye highlights
      ctx.fillStyle = '#ffffff';
      ctx.beginPath();
      ctx.arc(a.r*0.18, -a.r*0.32, 0.8, 0, TAU);
      ctx.fill();
      ctx.beginPath();
      ctx.arc(a.r*0.58, -a.r*0.32, 0.8, 0, TAU);
      ctx.fill();
      
      // DOG COLLAR - Loyal companion marker
      const collarGrad = ctx.createLinearGradient(-a.r*0.3, a.r*0.1, a.r*0.3, a.r*0.1);
      collarGrad.addColorStop(0, '#ffaa00');
      collarGrad.addColorStop(0.5, '#ffcc44');
      collarGrad.addColorStop(1, '#ffaa00');
      ctx.fillStyle = collarGrad;
      ctx.fillRect(-a.r*0.3, a.r*0.1, a.r*0.6, 4);
      
      // Collar buckle
      ctx.fillStyle = '#ffcc44';
      ctx.fillRect(-2, a.r*0.1, 4, 4);
      
      // DOG PAWS - Ready to protect
      ctx.fillStyle = '#4a3a2a';
      ctx.beginPath();
      ctx.arc(a.r*0.8, a.r*0.3, 4, 0, TAU);
      ctx.fill();
      ctx.beginPath();
      ctx.arc(a.r*0.8, a.r*0.1, 4, 0, TAU);
      ctx.fill();
      
      // Paw pads
      ctx.fillStyle = '#2a1a0a';
      ctx.beginPath();
      ctx.arc(a.r*0.8, a.r*0.3, 2, 0, TAU);
      ctx.fill();
      ctx.beginPath();
      ctx.arc(a.r*0.8, a.r*0.1, 2, 0, TAU);
      ctx.fill();
      
      // DOG TAIL - Wagging with loyalty
      const tailGrad = ctx.createLinearGradient(-a.r*1.2, 0, -a.r*0.8, 0);
      tailGrad.addColorStop(0, '#6b5335');
      tailGrad.addColorStop(1, '#8b7355');
      ctx.fillStyle = tailGrad;
      ctx.beginPath();
      ctx.ellipse(-a.r*1.0, 0, a.r*0.3, a.r*0.15, Math.sin(state.time * 4) * 0.2, 0, TAU);
      ctx.fill();
      
      // Tail tip
      ctx.fillStyle = '#8b7355';
      ctx.beginPath();
      ctx.arc(-a.r*1.25, Math.sin(state.time * 4) * 2, 3, 0, TAU);
      ctx.fill();
      
      // Protection symbol
      ctx.fillStyle = '#ff4444';
      ctx.font = 'bold 10px Arial';
      ctx.textAlign = 'center';
      ctx.fillText('üõ°Ô∏è', 0, a.r * 0.1);
    }
    
    // Animal weapon (natural attacks)
    ctx.fillStyle = '#2a2a2a';
    if (at.type === 'wolf') {
      ctx.fillRect(a.r*0.8, -3, 12, 6); // Claws
    } else if (at.type === 'eagle') {
      ctx.fillRect(a.r*0.8, -4, 14, 8); // Talons
    } else if (at.type === 'bear') {
      ctx.fillRect(a.r*0.8, -5, 16, 10); // Massive paws
    } else if (at.type === 'fox') {
      ctx.fillRect(a.r*0.8, -2, 10, 4); // Quick strikes
    } else if (at.type === 'fennec') {
      ctx.fillRect(a.r*0.8, -2, 10, 4); // Quick strikes with big ears
    } else if (at.type === 'owl') {
      ctx.fillRect(a.r*0.8, -3, 12, 6); // Sharp talons
    } else if (at.type === 'dolphin') {
      ctx.fillRect(a.r*0.8, -2, 10, 4); // Healing touch (gentle)
    } else if (at.type === 'dog') {
      ctx.fillRect(a.r*0.8, -3, 12, 6); // Protective bite
    }
    
    // Animal name tag with paw print
    ctx.fillStyle = '#ffffff';
    ctx.font = 'bold 10px Arial';
    ctx.textAlign = 'center';
    ctx.fillText(a.name, 0, -a.r - 20);
    ctx.fillStyle = '#ffaa00';
    ctx.fillText('üêæ', 0, -a.r - 25);
    
    // Health bar with animal design
    const hpw = a.r*2;
    ctx.fillStyle = '#0b1118';
    ctx.fillRect(-a.r, -a.r-10, hpw, 4);
    
    // Health bar color based on health percentage
    const healthPercent = a.hp / a.maxHp;
    let healthColor = '#27d07e'; // Green
    if (healthPercent <= 0.25) {
      healthColor = '#ff4444'; // Red when critical
    } else if (healthPercent <= 0.5) {
      healthColor = '#ffaa00'; // Orange when low
    } else if (healthPercent <= 0.7) {
      healthColor = '#ffff00'; // Yellow when needs healing
    }
    
    ctx.fillStyle = healthColor;
    ctx.fillRect(-a.r, -a.r-10, hpw * healthPercent, 4);
    
    // Animal health bar border
    ctx.strokeStyle = '#ffffff';
    ctx.lineWidth = 1;
    ctx.strokeRect(-a.r, -a.r-10, hpw, 4);
    
    // Critical health warning effect
    if (healthPercent <= 0.25) {
      const pulse = Math.sin(state.time * 8) * 0.3 + 0.7;
      ctx.strokeStyle = `rgba(255,68,68,${pulse})`;
      ctx.lineWidth = 2;
      ctx.strokeRect(-a.r, -a.r-10, hpw, 4);
    }

    ctx.restore();
  }

  function drawTracer(x,y,ang,color,len,w) {
    ctx.save();
    ctx.translate(x,y);
    ctx.rotate(ang);
    const grad = ctx.createLinearGradient(0,0,len,0);
    grad.addColorStop(0, color);
    grad.addColorStop(1, 'rgba(0,0,0,0)');
    ctx.strokeStyle = grad;
    ctx.lineWidth = w;
    ctx.beginPath();
    ctx.moveTo(0,0);
    ctx.lineTo(len,0);
    ctx.stroke();
    ctx.restore();
  }

  function drawPickup(p) {
    ctx.save();
    ctx.translate(p.x,p.y);
    ctx.rotate(p.spin);
    ctx.fillStyle = p.type==='med' ? '#27d07e' : p.type==='stam' ? '#3a86ff' : p.type==='weapon' ? '#ff6b6b' : p.type==='turret' ? '#4a90e2' : p.type==='barricade' ? '#8b4513' : p.type==='spike' ? '#ff4444' : p.type==='healingPlatform' ? '#00ff88' : '#ffbf00';
    roundRect(-10,-10,20,20,6); ctx.fill();
    ctx.fillStyle = 'rgba(0,0,0,0.4)';
    if (p.type==='med') { ctx.fillRect(-2,-6,4,12); ctx.fillRect(-6,-2,12,4); }
    else if (p.type==='stam') { ctx.fillRect(-6,-2,12,4); }
    else if (p.type==='weapon') { ctx.fillRect(-4,-4,8,8); }
    else if (p.type==='turret') { ctx.fillRect(-6,-2,12,4); ctx.fillRect(-2,-6,4,12); }
    else if (p.type==='barricade') { ctx.fillRect(-8,-2,16,4); }
    else if (p.type==='spike') { ctx.fillRect(-4,-6,8,12); ctx.fillRect(-6,-4,12,8); }
    else if (p.type==='healingPlatform') { 
      // Healing platform symbol - cross with circle
      ctx.fillRect(-2,-6,4,12); ctx.fillRect(-6,-2,12,4);
      ctx.beginPath();
      ctx.arc(0,0,8,0,TAU);
      ctx.stroke();
    }
    else { ctx.fillRect(-2,-6,4,12); }
    ctx.restore();
  }

  function drawBarricade(b) {
    // Very subtle shadow
    ctx.fillStyle = 'rgba(0,0,0,0.15)';
    ctx.beginPath();
    ctx.ellipse(b.x, b.y+4, b.width*0.9, b.height*0.6, 0, 0, TAU);
    ctx.fill();

    ctx.save();
    ctx.translate(b.x, b.y);
    ctx.rotate(b.angle);

    // Barricade body (elongated)
    ctx.fillStyle = '#8b4513';
    ctx.fillRect(-b.width/2, -b.height/2, b.width, b.height);
    
    // Barricade details
    ctx.fillStyle = '#654321';
    ctx.fillRect(-b.width/2 + 5, -b.height/2 + 3, b.width - 10, 4);
    ctx.fillRect(-b.width/2 + 5, b.height/2 - 7, b.width - 10, 4);

    ctx.restore();

    // Health bar
    const hpw = b.width;
    ctx.fillStyle = '#0b1118';
    ctx.fillRect(b.x - b.width/2, b.y - b.height/2 - 15, hpw, 4);
    ctx.fillStyle = '#27d07e';
    ctx.fillRect(b.x - b.width/2, b.y - b.height/2 - 15, hpw * (b.health/b.maxHealth), 4);
  }

  function drawTurret(t) {
    if (t.health <= 0) return;
    
    // Enhanced shadow with depth
    ctx.fillStyle = 'rgba(0,0,0,0.5)';
    ctx.beginPath();
    ctx.ellipse(t.x, t.y+10, t.r*0.9, t.r*0.6, 0, 0, TAU);
    ctx.fill();
    ctx.fillStyle = 'rgba(0,0,0,0.3)';
    ctx.beginPath();
    ctx.ellipse(t.x, t.y+5, t.r*0.9, t.r*0.6, 0, 0, TAU);
    ctx.fill();

    ctx.save();
    ctx.translate(t.x, t.y);
    ctx.rotate(t.angle);

    // Enhanced base with metallic finish
    const baseGrad = ctx.createRadialGradient(0, 0, 0, 0, 0, t.r);
    baseGrad.addColorStop(0, '#3a4a5a');
    baseGrad.addColorStop(1, '#2a3a4a');
    ctx.fillStyle = baseGrad;
    roundRect(-t.r, -t.r*0.8, t.r*2, t.r*1.6, t.r*0.4);
    ctx.fill();

    // Base details and bolts
    ctx.fillStyle = '#1a2a3a';
    for (let i = 0; i < 4; i++) {
      const angle = (i / 4) * TAU;
      const boltX = Math.cos(angle) * t.r * 0.7;
      const boltY = Math.sin(angle) * t.r * 0.7;
      ctx.beginPath();
      ctx.arc(boltX, boltY, 2, 0, TAU);
      ctx.fill();
    }

    // Enhanced turret body with gradient
    const bodyGrad = ctx.createRadialGradient(0, 0, 0, 0, 0, t.r * 0.7);
    bodyGrad.addColorStop(0, t.color);
    bodyGrad.addColorStop(1, adjustColor(t.color, -30));
    ctx.fillStyle = bodyGrad;
    roundRect(-t.r*0.7, -t.r*0.6, t.r*1.4, t.r*1.2, t.r*0.3);
    ctx.fill();

    // Turret type-specific enhancements
    if (t.type === 0) { // Basic turret
      // Standard design with targeting scope
      ctx.fillStyle = '#ffffff';
      ctx.beginPath();
      ctx.arc(t.r*0.3, -t.r*0.2, 3, 0, TAU);
      ctx.fill();
      ctx.strokeStyle = '#4a90e2';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.arc(t.r*0.3, -t.r*0.2, 5, 0, TAU);
      ctx.stroke();
      
    } else if (t.type === 1) { // Heavy turret
      // Heavy armor plating
      ctx.fillStyle = '#ff4444';
      ctx.fillRect(-t.r*0.5, -t.r*0.4, t.r, t.r*0.8);
      // Cooling vents
      ctx.fillStyle = '#cc3333';
      for (let i = 0; i < 3; i++) {
        ctx.fillRect(-t.r*0.3 + i * t.r*0.3, -t.r*0.3, 2, t.r*0.6);
      }
      
    } else if (t.type === 2) { // Sniper turret
      // Long-range scope
      ctx.fillStyle = '#9b59b6';
      ctx.beginPath();
      ctx.arc(0, 0, t.r*0.4, 0, TAU);
      ctx.fill();
      // Scope details
      ctx.fillStyle = '#ffffff';
      ctx.beginPath();
      ctx.arc(0, 0, 2, 0, TAU);
      ctx.fill();
      ctx.strokeStyle = '#9b59b6';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(0, 0, t.r*0.3, 0, TAU);
      ctx.stroke();
      
    } else if (t.type === 3) { // Shotgun turret
      // Multiple barrels
      ctx.fillStyle = '#ffaa00';
      for (let i = 0; i < 3; i++) {
        const angle = (i - 1) * 0.2;
        const barrelX = Math.cos(angle) * 8;
        const barrelY = Math.sin(angle) * 8;
        ctx.fillRect(barrelX, barrelY - 2, 20, 4);
      }
      
    } else if (t.type === 4) { // Flamethrower turret
      // Flame nozzle
      ctx.fillStyle = '#ff4444';
      ctx.beginPath();
      ctx.arc(0, 0, t.r*0.3, 0, TAU);
      ctx.fill();
      // Flame details
      ctx.fillStyle = '#ff8800';
      ctx.beginPath();
      ctx.arc(0, 0, t.r*0.2, 0, TAU);
      ctx.fill();
      // Heat glow
      const heatGlow = ctx.createRadialGradient(0, 0, 0, 0, 0, t.r*0.4);
      heatGlow.addColorStop(0, 'rgba(255,68,68,0.3)');
      heatGlow.addColorStop(1, 'rgba(255,68,68,0)');
      ctx.fillStyle = heatGlow;
      ctx.beginPath();
      ctx.arc(0, 0, t.r*0.4, 0, TAU);
      ctx.fill();
    }

    // Enhanced barrel with metallic finish
    const barrelGrad = ctx.createLinearGradient(0, -4, 25, -4);
    barrelGrad.addColorStop(0, '#1a2a3a');
    barrelGrad.addColorStop(1, '#2a3a4a');
    ctx.fillStyle = barrelGrad;
    ctx.fillRect(0, -4, 25, 8);
    ctx.fillRect(-2, -2, 4, 4);
    
    // Barrel details
    ctx.fillStyle = '#0a1a2a';
    ctx.fillRect(20, -3, 3, 6);
    ctx.fillRect(15, -2, 2, 4);

    // Enhanced health bar with gradient
    const hpw = t.r*2.2;
    const barHeight = 6;
    ctx.fillStyle = 'rgba(0,0,0,0.8)';
    ctx.fillRect(-t.r*1.1, -t.r-15, hpw, barHeight);
    ctx.fillStyle = 'rgba(0,0,0,0.9)';
    ctx.fillRect(-t.r*1.1, -t.r-15, hpw, barHeight);
    
    const healthPercent = t.health/t.maxHealth;
    const healthGrad = ctx.createLinearGradient(-t.r*1.1, -t.r-15, -t.r*1.1 + hpw, -t.r-15);
    if (healthPercent > 0.6) {
      healthGrad.addColorStop(0, '#27d07e');
      healthGrad.addColorStop(1, '#1a8f5a');
    } else if (healthPercent > 0.3) {
      healthGrad.addColorStop(0, '#ffaa00');
      healthGrad.addColorStop(1, '#cc8800');
    } else {
      healthGrad.addColorStop(0, '#ff4444');
      healthGrad.addColorStop(1, '#cc3333');
    }
    ctx.fillStyle = healthGrad;
    ctx.fillRect(-t.r*1.1, -t.r-15, hpw * healthPercent, barHeight);

    // Enhanced target indicator with pulsing
    if (t.target) {
      const pulse = Math.sin(state.time * 8) * 0.3 + 0.7;
      ctx.strokeStyle = `rgba(74,144,226,${pulse})`;
      ctx.lineWidth = 3;
      ctx.globalAlpha = 0.8;
      ctx.beginPath();
      ctx.moveTo(0, 0);
      ctx.lineTo(35, 0);
      ctx.stroke();
      ctx.globalAlpha = 1;
    }

    ctx.restore();
  }
  
  // Helper function to adjust color brightness
  function adjustColor(color, amount) {
    const hex = color.replace('#', '');
    const r = Math.max(0, Math.min(255, parseInt(hex.substr(0, 2), 16) + amount));
    const g = Math.max(0, Math.min(255, parseInt(hex.substr(2, 2), 16) + amount));
    const b = Math.max(0, Math.min(255, parseInt(hex.substr(4, 2), 16) + amount));
    return `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`;
  }

  function drawSpike(s) {
    if (s.health <= 0) return;
    
    // Shadow
    ctx.fillStyle = 'rgba(0,0,0,0.4)';
    ctx.beginPath();
    ctx.ellipse(s.x, s.y+8, s.r*0.9, s.r*0.6, 0, 0, TAU);
    ctx.fill();

    ctx.save();
    ctx.translate(s.x, s.y);

    // Base
    ctx.fillStyle = '#2a2a2a';
    ctx.beginPath();
    ctx.arc(0, 0, s.r*0.8, 0, TAU);
    ctx.fill();

    // Vines
    ctx.fillStyle = '#00aa00';
    for (let i = 0; i < 6; i++) {
      const angle = (i / 6) * TAU;
      const vineX = Math.cos(angle) * s.r * 0.6;
      const vineY = Math.sin(angle) * s.r * 0.6;
      
      // Draw vine tendrils
      ctx.beginPath();
      ctx.moveTo(vineX, vineY);
      ctx.lineTo(vineX + Math.cos(angle) * 10, vineY + Math.sin(angle) * 10);
      ctx.lineTo(vineX + Math.cos(angle + 0.2) * 6, vineY + Math.sin(angle + 0.2) * 6);
      ctx.lineTo(vineX + Math.cos(angle - 0.2) * 6, vineY + Math.sin(angle - 0.2) * 6);
      ctx.closePath();
      ctx.fill();
      
      // Draw vine leaves
      ctx.fillStyle = '#008800';
      ctx.beginPath();
      ctx.ellipse(vineX + Math.cos(angle) * 8, vineY + Math.sin(angle) * 8, 3, 2, angle, 0, TAU);
      ctx.fill();
      ctx.fillStyle = '#00aa00';
    }

    // Health bar
    const hpw = s.r*2;
    ctx.fillStyle = '#0b1118';
    ctx.fillRect(-s.r, -s.r-12, hpw, 4);
    ctx.fillStyle = '#27d07e';
    ctx.fillRect(-s.r, -s.r-12, hpw * (s.health/s.maxHealth), 4);

    ctx.restore();
  }

  function drawMine(m) {
    // Shadow
    ctx.fillStyle = 'rgba(0,0,0,0.4)';
    ctx.beginPath();
    ctx.ellipse(m.x, m.y+8, m.r*0.9, m.r*0.6, 0, 0, TAU);
    ctx.fill();

    ctx.save();
    ctx.translate(m.x, m.y);

    // Base
    ctx.fillStyle = '#2a2a2a';
    ctx.beginPath();
    ctx.arc(0, 0, m.r*0.8, 0, TAU);
    ctx.fill();

    // Mine body
    ctx.fillStyle = '#ffaa00';
    ctx.beginPath();
    ctx.arc(0, 0, m.r*0.6, 0, TAU);
    ctx.fill();

    // Trigger mechanism
    ctx.fillStyle = '#ff4444';
    ctx.beginPath();
    ctx.arc(0, 0, m.r*0.3, 0, TAU);
    ctx.fill();

    // Warning stripes
    ctx.fillStyle = '#000000';
    for (let i = 0; i < 4; i++) {
      const angle = (i / 4) * TAU;
      ctx.fillRect(Math.cos(angle) * m.r * 0.4 - 2, Math.sin(angle) * m.r * 0.4 - 1, 4, 2);
    }

    ctx.restore();
  }

  function drawHealingPlatform(h) {
    // Shadow
    ctx.fillStyle = 'rgba(0,0,0,0.3)';
    ctx.beginPath();
    ctx.ellipse(h.x, h.y+8, h.r*0.9, h.r*0.6, 0, 0, TAU);
    ctx.fill();

    ctx.save();
    ctx.translate(h.x, h.y);

    // Healing aura effect
    const auraAlpha = 0.3 + Math.sin(state.time * 3) * 0.1;
    ctx.fillStyle = `rgba(0,255,136,${auraAlpha})`;
    ctx.beginPath();
    ctx.arc(0, 0, h.r, 0, TAU);
    ctx.fill();

    // Platform base
    ctx.fillStyle = '#00ff88';
    ctx.beginPath();
    ctx.arc(0, 0, h.r * 0.8, 0, TAU);
    ctx.fill();

    // Platform details
    ctx.fillStyle = '#00cc66';
    ctx.beginPath();
    ctx.arc(0, 0, h.r * 0.6, 0, TAU);
    ctx.fill();

    // Healing cross symbol
    ctx.fillStyle = '#ffffff';
    ctx.fillRect(-h.r * 0.15, -h.r * 0.4, h.r * 0.3, h.r * 0.8);
    ctx.fillRect(-h.r * 0.4, -h.r * 0.15, h.r * 0.8, h.r * 0.3);

    // Pulsing effect
    const pulse = Math.sin(state.time * 4) * 0.2 + 0.8;
    ctx.strokeStyle = `rgba(255,255,255,${pulse})`;
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(0, 0, h.r * 0.9, 0, TAU);
    ctx.stroke();

    // Duration bar showing remaining time
    const timePercent = 1 - (h.time / h.duration);
    const barWidth = h.r * 1.6;
    ctx.fillStyle = '#0b1118';
    ctx.fillRect(-barWidth/2, -h.r - 15, barWidth, 4);
    ctx.fillStyle = '#00ff88';
    ctx.fillRect(-barWidth/2, -h.r - 15, barWidth * timePercent, 4);

    ctx.restore();
  }

  function drawPlayer() {
    // Shadow
    ctx.fillStyle = 'rgba(0,0,0,0.45)';
    ctx.beginPath(); ctx.ellipse(player.x,player.y+10, 14,8, 0,0,TAU); ctx.fill();

    ctx.save();
    ctx.translate(player.x, player.y);
    ctx.rotate(player.angle);

    // CUTE PENGUIN BODY - Classic black and white
    const bodyGrad = ctx.createRadialGradient(0, 0, 0, 0, 0, 16);
    bodyGrad.addColorStop(0, '#1a1a1a');
    bodyGrad.addColorStop(0.7, '#2a2a2a');
    bodyGrad.addColorStop(1, '#0a0a0a');
    ctx.fillStyle = bodyGrad;
    roundRect(-14,-10,28,20,8);
    ctx.fill();
    
    // White belly patch
    ctx.fillStyle = '#ffffff';
    ctx.beginPath();
    ctx.ellipse(0, 2, 8, 6, 0, 0, TAU);
    ctx.fill();
    
    // PENGUIN HEAD with cute features
    const headGrad = ctx.createRadialGradient(0, -8, 0, 0, -8, 12);
    headGrad.addColorStop(0, '#1a1a1a');
    headGrad.addColorStop(1, '#0a0a0a');
    ctx.fillStyle = headGrad;
    ctx.beginPath();
    ctx.arc(0, -8, 12, 0, TAU);
    ctx.fill();
    
    // Cute black eyes with white highlights
    ctx.fillStyle = '#000000';
    ctx.beginPath();
    ctx.arc(-4, -9, 2.5, 0, TAU);
    ctx.fill();
    ctx.beginPath();
    ctx.arc(4, -9, 2.5, 0, TAU);
    ctx.fill();
    
    // White eye highlights
    ctx.fillStyle = '#ffffff';
    ctx.beginPath();
    ctx.arc(-4.5, -9.5, 0.8, 0, TAU);
    ctx.fill();
    ctx.beginPath();
    ctx.arc(3.5, -9.5, 0.8, 0, TAU);
    ctx.fill();
    
    // Cute orange beak
    ctx.fillStyle = '#ff8c42';
    ctx.beginPath();
    ctx.moveTo(-2, -6);
    ctx.lineTo(2, -6);
    ctx.lineTo(0, -4);
    ctx.closePath();
    ctx.fill();
    
    // Beak highlight
    ctx.fillStyle = '#ffa562';
    ctx.beginPath();
    ctx.moveTo(-1, -6);
    ctx.lineTo(1, -6);
    ctx.lineTo(0, -5);
    ctx.closePath();
    ctx.fill();
    
    // Cute flippers (wings)
    ctx.fillStyle = '#1a1a1a';
    ctx.beginPath();
    ctx.ellipse(-12, 0, 3, 8, 0, 0, TAU);
    ctx.fill();
    ctx.beginPath();
    ctx.ellipse(12, 0, 3, 8, 0, 0, TAU);
    ctx.fill();
    
    // Flipper highlights
    ctx.fillStyle = '#2a2a2a';
    ctx.beginPath();
    ctx.ellipse(-12, -1, 2, 6, 0, 0, TAU);
    ctx.fill();
    ctx.beginPath();
    ctx.ellipse(12, -1, 2, 6, 0, 0, TAU);
    ctx.fill();

    // SPACE PENGUIN WEAPON - Cute but deadly
    ctx.fillStyle = '#4a4a4a';
    ctx.fillRect(8,-3,20,6);
    ctx.fillStyle = '#6a6a6a';
    ctx.fillRect(10,-2,16,4);
    ctx.fillStyle = '#ff8c42';
    ctx.fillRect(12,-1,2,2);
    
    // Weapon details
    ctx.fillStyle = '#ff4444';
    ctx.beginPath();
    ctx.arc(12,0,3,0,TAU);
    ctx.fill();
    
    // Cute space backpack
    ctx.fillStyle = '#2a2a2a';
    ctx.fillRect(-16, -5, 8, 10);
    ctx.fillStyle = '#ff8c42';
    ctx.fillRect(-18, -3, 2, 6);
    ctx.fillRect(-18, 3, 2, 6);
    
    // Cute antenna
    ctx.fillStyle = '#ff8c42';
    ctx.fillRect(-2, -18, 4, 8);
    ctx.beginPath();
    ctx.arc(-2, -18, 2, 0, TAU);
    ctx.fill();
    
    // Energy shield effect
    if (player.inv > 0) {
      ctx.strokeStyle = '#ff8c42';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(0, 0, 18, 0, TAU);
      ctx.stroke();
    }

    ctx.restore();

    // Night cone
    if (state.night) {
      const grd = ctx.createRadialGradient(player.x,player.y,10, player.x,player.y, 220);
      grd.addColorStop(0,'rgba(255,255,255,0.06)');
      grd.addColorStop(1,'rgba(0,0,0,0)');
      ctx.fillStyle = grd;
      ctx.beginPath();
      ctx.moveTo(player.x,player.y);
      ctx.arc(player.x,player.y, 260, player.angle-0.6, player.angle+0.6);
      ctx.closePath();
      ctx.fill();
    }
  }

  function drawParticle(p) {
    const life = p.life || 0.8;
    const a = Math.max(0, 1 - p.t / life);
    ctx.fillStyle = colorWithAlpha(p.color, a);
    ctx.beginPath();
    ctx.arc(p.x,p.y,p.r,0,TAU);
    ctx.fill();
  }

  function postFX() {
    // Flash
    if (state.flash>0) {
      ctx.fillStyle = `rgba(255,245,200,${state.flash})`;
      ctx.fillRect(0,0,state.w,state.h);
    }

    // Vignette
    const v = ctx.createRadialGradient(state.w/2,state.h/2, Math.min(state.w,state.h)*0.2, state.w/2,state.h/2, Math.max(state.w,state.h)*state.vignette);
    v.addColorStop(0, 'rgba(0,0,0,0)');
    v.addColorStop(1, 'rgba(0,0,0,0.6)');
    ctx.fillStyle = v;
    ctx.fillRect(0,0,state.w,state.h);
  }

  function drawMessages() {
    // Update and draw messages with enhanced styling
    for (let i = state.messages.length - 1; i >= 0; i--) {
      const msg = state.messages[i];
      msg.time += state.dt;
      
      if (msg.time > msg.life) {
        state.messages.splice(i, 1);
        continue;
      }
      
      // Calculate position and opacity
      const progress = msg.time / msg.life;
      const alpha = progress < 0.2 ? progress * 5 : progress > 0.8 ? (1 - progress) * 5 : 1;
      
      // Position messages in upper left corner (fixed positioning)
      const messageHeight = 35;
      const maxMessages = 3;
      const startY = 120;
      const y = startY + (i % maxMessages) * messageHeight;
      const x = 30; // Left-aligned with more spacing
      
      // Category-based colors
      let bgColor, textColor, borderColor;
      switch(msg.category) {
        case 'weapon':
          bgColor = `rgba(255,107,107,${alpha * 0.9})`;
          textColor = `rgba(255,255,255,${alpha})`;
          borderColor = `rgba(255,150,150,${alpha * 0.6})`;
          break;
        case 'heal':
          bgColor = `rgba(39,208,126,${alpha * 0.9})`;
          textColor = `rgba(255,255,255,${alpha})`;
          borderColor = `rgba(100,255,150,${alpha * 0.6})`;
          break;
        case 'ammo':
          bgColor = `rgba(255,191,0,${alpha * 0.9})`;
          textColor = `rgba(0,0,0,${alpha})`;
          borderColor = `rgba(255,220,100,${alpha * 0.6})`;
          break;
        case 'turret':
          bgColor = `rgba(74,144,226,${alpha * 0.9})`;
          textColor = `rgba(255,255,255,${alpha})`;
          borderColor = `rgba(150,200,255,${alpha * 0.6})`;
          break;
        case 'combo':
          bgColor = `rgba(255,170,0,${alpha * 0.9})`;
          textColor = `rgba(255,255,255,${alpha})`;
          borderColor = `rgba(255,200,100,${alpha * 0.6})`;
          break;
        case 'power':
          bgColor = `rgba(255,255,0,${alpha * 0.9})`;
          textColor = `rgba(0,0,0,${alpha})`;
          borderColor = `rgba(255,255,150,${alpha * 0.6})`;
          break;
        default:
          bgColor = `rgba(0,0,0,${alpha * 0.9})`;
          textColor = `rgba(255,255,255,${alpha})`;
          borderColor = `rgba(255,255,255,${alpha * 0.4})`;
      }
      
      // Enhanced background with proper positioning
      const textWidth = ctx.measureText(msg.text).width;
      const padding = 15;
      const boxWidth = textWidth + padding * 2;
      const boxHeight = 30;
      
      // Background with rounded corners
      ctx.fillStyle = bgColor;
      ctx.beginPath();
      ctx.roundRect(x, y - boxHeight/2, boxWidth, boxHeight, 6);
      ctx.fill();
      
      // Border
      ctx.strokeStyle = borderColor;
      ctx.lineWidth = 2;
      ctx.stroke();
      
      // Text
      ctx.fillStyle = textColor;
      ctx.font = 'bold 14px Arial';
      ctx.textAlign = 'left';
      ctx.textBaseline = 'middle';
      ctx.fillText(msg.text, x + padding, y);
    }
  }

  function drawSpeechBubbles() {
    // Update and draw speech bubbles
    for (let i = state.speechBubbles.length - 1; i >= 0; i--) {
      const bubble = state.speechBubbles[i];
      bubble.time += state.dt;
      
      if (bubble.time > bubble.life) {
        state.speechBubbles.splice(i, 1);
        continue;
      }
      
      // Update position to follow owner
      if (bubble.owner) {
        bubble.x = bubble.owner.x;
        bubble.y = bubble.owner.y - 40;
      } else {
        // Player speech bubble - follow player
        bubble.x = player.x;
        bubble.y = player.y - 40;
      }
      
      // Calculate opacity
      const progress = bubble.time / bubble.life;
      const alpha = progress < 0.2 ? progress * 5 : progress > 0.8 ? (1 - progress) * 5 : 1;
      
      // Draw speech bubble
      const textWidth = ctx.measureText(bubble.text).width;
      const bubbleWidth = textWidth + 20;
      const bubbleHeight = 25;
      
      // Background
      ctx.fillStyle = `rgba(255,255,255,${alpha * 0.9})`;
      ctx.fillRect(bubble.x - bubbleWidth/2, bubble.y - bubbleHeight/2, bubbleWidth, bubbleHeight);
      
      // Border
      ctx.strokeStyle = `rgba(0,0,0,${alpha * 0.3})`;
      ctx.lineWidth = 2;
      ctx.strokeRect(bubble.x - bubbleWidth/2, bubble.y - bubbleHeight/2, bubbleWidth, bubbleHeight);
      
      // Text
      ctx.fillStyle = bubble.color ? `rgba(${bubble.color === '#ff4444' ? '255,68,68' : '0,0,0'},${alpha})` : `rgba(0,0,0,${alpha})`;
      ctx.font = 'bold 12px Arial';
      ctx.textAlign = 'center';
      ctx.fillText(bubble.text, bubble.x, bubble.y + 4);
      
      // Speech bubble tail
      ctx.fillStyle = `rgba(255,255,255,${alpha * 0.9})`;
      ctx.beginPath();
      ctx.moveTo(bubble.x, bubble.y + bubbleHeight/2);
      ctx.lineTo(bubble.x - 5, bubble.y + bubbleHeight/2 + 8);
      ctx.lineTo(bubble.x + 5, bubble.y + bubbleHeight/2 + 8);
      ctx.closePath();
      ctx.fill();
      
      ctx.strokeStyle = `rgba(0,0,0,${alpha * 0.3})`;
      ctx.lineWidth = 2;
      ctx.stroke();
    }
  }

  function drawPowerModeEffects() {
    // Power mode visual effects
    ctx.save();
    ctx.globalAlpha = 0.3;
    ctx.fillStyle = '#ffaa00';
    
    // Pulsing effect around player
    const pulseSize = 100 + Math.sin(state.time * 8) * 20;
    ctx.beginPath();
    ctx.arc(player.x, player.y, pulseSize, 0, TAU);
    ctx.fill();
    
    // Power mode text
    ctx.fillStyle = '#ffaa00';
    ctx.font = 'bold 24px Arial';
    ctx.textAlign = 'center';
    ctx.fillText('POWER MODE', player.x, player.y - 80);
    ctx.fillText(`${Math.ceil(state.powerModeTimer)}s`, player.x, player.y - 60);
    
    ctx.restore();
  }

  function drawDamageNumbers() {
    for (const dn of state.damageNumbers) {
      const progress = dn.time / dn.life;
      const alpha = progress < 0.3 ? progress * 3.33 : progress > 0.7 ? (1 - progress) * 3.33 : 1;
      
      ctx.save();
      ctx.globalAlpha = alpha;
      ctx.fillStyle = dn.color;
      ctx.font = 'bold 16px Arial';
      ctx.textAlign = 'center';
      ctx.fillText(dn.damage.toString(), dn.x, dn.y);
      ctx.restore();
    }
  }

  function drawGraveyard() {
    for (const grave of state.graveyard) {
      // Draw grave marker (cross)
      ctx.save();
      ctx.translate(grave.x, grave.y);
      
      // Grave shadow
      ctx.fillStyle = 'rgba(0,0,0,0.4)';
      ctx.beginPath();
      ctx.ellipse(0, 8, 12, 6, 0, 0, TAU);
      ctx.fill();
      
      // Grave cross
      ctx.strokeStyle = '#8b4513';
      ctx.lineWidth = 3;
      ctx.lineCap = 'round';
      
      // Vertical part of cross
      ctx.beginPath();
      ctx.moveTo(0, -8);
      ctx.lineTo(0, 8);
      ctx.stroke();
      
      // Horizontal part of cross
      ctx.beginPath();
      ctx.moveTo(-6, 0);
      ctx.lineTo(6, 0);
      ctx.stroke();
      
      // Grave base
      ctx.fillStyle = '#654321';
      ctx.fillRect(-8, 4, 16, 4);
      
      // Subtle glow effect
      ctx.shadowColor = grave.color;
      ctx.shadowBlur = 8;
      ctx.globalAlpha = 0.3;
      ctx.beginPath();
      ctx.arc(0, 0, 15, 0, TAU);
      ctx.fill();
      ctx.shadowBlur = 0;
      ctx.globalAlpha = 1;
      
      // Name plaque
      ctx.fillStyle = '#ffffff';
      ctx.font = 'bold 10px Arial';
      ctx.textAlign = 'center';
      ctx.fillText(grave.name, 0, -15);
      
      // Time since death
      const timeSinceDeath = Math.floor((state.time - grave.time) / 60);
      if (timeSinceDeath > 0) {
        ctx.fillStyle = '#cccccc';
        ctx.font = '8px Arial';
        ctx.fillText(`${timeSinceDeath}m ago`, 0, -5);
      }
      
      ctx.restore();
    }
  }

  function drawBloodSplatter() {
    if (state.bloodSplatter <= 0) return;
    
    // Create blood splatter effect
    const alpha = state.bloodSplatter / 0.5; // Fade out over 0.5 seconds
    ctx.save();
    ctx.globalAlpha = alpha * 0.3;
    
    // Draw multiple blood drops
    for (let i = 0; i < 8; i++) {
      const angle = (i / 8) * TAU;
      const distance = 20 + Math.random() * 30;
      const x = state.bloodSplatterX + Math.cos(angle) * distance;
      const y = state.bloodSplatterY + Math.sin(angle) * distance;
      const size = 3 + Math.random() * 4;
      
      ctx.fillStyle = '#8b0000';
      ctx.beginPath();
      ctx.arc(x, y, size, 0, TAU);
      ctx.fill();
    }
    
    ctx.restore();
    
    // Update timer
    state.bloodSplatter -= state.dt;
  }

  function drawMinimap() {
    const mapSize = 120;
    const mapX = state.w - mapSize - 20;
    const mapY = 20;
    const mapScale = mapSize / Math.max(state.w, state.h);
    
    // Minimap background
    ctx.fillStyle = 'rgba(0,0,0,0.7)';
    ctx.fillRect(mapX, mapY, mapSize, mapSize);
    ctx.strokeStyle = '#ffffff';
    ctx.lineWidth = 2;
    ctx.strokeRect(mapX, mapY, mapSize, mapSize);
    
    // Draw player
    ctx.fillStyle = '#00ff00';
    ctx.beginPath();
    ctx.arc(mapX + player.x * mapScale, mapY + player.y * mapScale, 3, 0, TAU);
    ctx.fill();
    
    // Draw enemies
    ctx.fillStyle = '#ff0000';
    for (const e of enemies) {
      ctx.beginPath();
      ctx.arc(mapX + e.x * mapScale, mapY + e.y * mapScale, 2, 0, TAU);
      ctx.fill();
    }
    
    // Draw allies
    ctx.fillStyle = '#00aaff';
    for (const a of allies) {
      ctx.beginPath();
      ctx.arc(mapX + a.x * mapScale, mapY + a.y * mapScale, 2, 0, TAU);
      ctx.fill();
    }
    
    // Draw healing platforms
    ctx.fillStyle = '#00ff88';
    for (const h of healingPlatforms) {
      ctx.beginPath();
      ctx.arc(mapX + h.x * mapScale, mapY + h.y * mapScale, 4, 0, TAU);
      ctx.fill();
    }
    
    // Draw pickups
    ctx.fillStyle = '#ffff00';
    for (const p of pickups) {
      ctx.beginPath();
      ctx.arc(mapX + p.x * mapScale, mapY + p.y * mapScale, 1.5, 0, TAU);
      ctx.fill();
    }
  }

  // Geometry helpers
  function roundRect(x,y,w,h,r) {
    const rr = Math.min(r, w/2, h/2);
    ctx.beginPath();
    ctx.moveTo(x+rr, y);
    ctx.arcTo(x+w,y, x+w,y+h, rr);
    ctx.arcTo(x+w,y+h, x,y+h, rr);
    ctx.arcTo(x,y+h, x,y, rr);
    ctx.arcTo(x,y, x+w,y, rr);
    ctx.closePath();
  }

  // Utils
  function clamp(v, a, b) { return Math.max(a, Math.min(b, v)); }
  function lerp(a,b,t) { return a + (b - a) * t; }
  function rand(a=0, b=1) { return a + Math.random()*(b-a); }
  function knockback(obj, ang, power) {
    obj.x -= Math.cos(ang) * (power/60);
    obj.y -= Math.sin(ang) * (power/60);
  }
  function colorWithAlpha(hexOrRgba, a) {
    if (hexOrRgba.startsWith('#')) {
      const c = hexOrRgba.slice(1);
      const r = parseInt(c.length===3 ? c[0]+c[0] : c.slice(0,2), 16);
      const g = parseInt(c.length===3 ? c[1]+c[1] : c.slice(2,4), 16);
      const b = parseInt(c.length===3 ? c[2]+c[2] : c.slice(4,6), 16);
      return `rgba(${r},${g},${b},${a})`;
    }
    return hexOrRgba.replace(/rgba?\(([^)]+)\)/, (m, inner) => {
      const parts = inner.split(',').map(s => s.trim());
      const [r,g,b] = parts;
      return `rgba(${r},${g},${b},${a})`;
    });
  }

  // Boot
  function init() {
    resize();
    renderWeaponHUD();
    loadSettings();
    showScreen('start');
    
    // Setup button event listeners after DOM is ready
    setupButtonListeners();
    
    // Don't start the game loop until player clicks start
  }
  window.addEventListener('load', init);
  </script>
</body>
</html>






